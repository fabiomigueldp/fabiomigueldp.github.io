<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Canvas de Texto — Editor v3</title>
  <!-- Importar DM Sans para UI -->
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,300;400;600;800&display=swap" rel="stylesheet">
  <style>
    /* ======= FASE 0: Fundamentos - Bridge Tokens ======= */
    :root{
      color-scheme: dark;
      --bg:#0b0b0d; --bg-2:#0f1013;
      --panel:rgba(255,255,255,.06); --panel-strong:rgba(255,255,255,.10);
      --stroke:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92); --text-dim:rgba(255,255,255,.70); --text-muted:rgba(255,255,255,.55);
      --accent:#0A84FF; --accent-2:#5E5CE6;
      --dur:.25s; --ease:cubic-bezier(.2,.7,.2,1);
      --code-font: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "DejaVu Sans Mono", "Courier New", monospace;
      --font-size:14px; --editor-font-size:10px; --line-height:1.55; --editor-padding: clamp(8px, 1.5vw, 16px);
      --gutter-w:48px; --mini-w:120px;
      
      /* Bridge tokens para o Kit Liquid Glass */
      --c-bg: var(--bg);
      --c-content: var(--text);
      --c-action: var(--accent);
      --c-glass: color-mix(in oklab, var(--bg), white 60%);
      --c-light: #fff;
      --c-dark: #000;
      --glass-reflex-dark: 1;
      --glass-reflex-light: 1;
      --saturation: 150%;
      --fz: 14px;
      
      /* LiquidGlass tuning original mantido para compatibilidade */
      --lg-blur:clamp(12px, 1.2vw, 22px); 
      --lg-sat:clamp(120%, 10%, 160%); 
      --lg-contrast:clamp(1, 0.02, 1.08); 
      --lg-highlight:rgba(255,255,255,.45);
      --lg-highlight-strong:rgba(255,255,255,.65);
      --lg-highlight-subtle:rgba(255,255,255,.25);
      --lg-edge:rgba(255,255,255,.20); 
      --lg-edge-dark:rgba(0,0,0,.35);
      --lg-reflex-light:1; --lg-reflex-dark:1;
      
      /* Font principal DM Sans para UI */
      font-family: "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    html[data-theme="light"] {
      color-scheme: light;
      --bg:#f3f3f8; --bg-2:#e9e9f0;
      --panel:rgba(0,0,0,.04); --panel-strong:rgba(0,0,0,.08);
      --stroke:rgba(0,0,0,.10);
      --text:rgba(0,0,0,.88); --text-dim:rgba(0,0,0,.65); --text-muted:rgba(0,0,0,.45);
      --accent:#007AFF; --accent-2:#5856D6;
      
      /* Bridge tokens para modo claro */
      --c-bg: var(--bg);
      --c-content: var(--text);
      --c-action: var(--accent);
      --c-glass: color-mix(in oklab, var(--bg), white 60%);
      --saturation: 100%;
      
      /* LiquidGlass tuning for light mode */
      --lg-blur:clamp(14px, 1.4vw, 22px); 
      --lg-sat:clamp(100%, 10%, 130%); 
      --lg-contrast:clamp(1, 0.02, 1.05); 
      --lg-highlight:rgba(255,255,255,.75);
      --lg-highlight-strong:rgba(255,255,255,.95);
      --lg-highlight-subtle:rgba(255,255,255,.45);
      --lg-edge:rgba(255,255,255,.65); 
      --lg-edge-dark:rgba(0,0,0,.15);
    }
    body {
        transition: background var(--dur) var(--ease), color var(--dur) var(--ease);
    }
    @media (prefers-reduced-motion: reduce){ :root{ --dur:0s } *{ animation:none!important; transition:none!important } }

    /* ======= Componentes Liquid Glass Kit ======= */
    /* Estilo base "LIQUID GLASS" */
    .glass-ui {
        position: relative; display: inline-flex; align-items: center; justify-content: center;
        border: none; cursor: pointer; isolation: isolate;
        transition: all 250ms cubic-bezier(0.5, 0, 0, 1);
        background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
        backdrop-filter: blur(12px) saturate(var(--saturation));
        -webkit-backdrop-filter: blur(12px) saturate(var(--saturation));
        box-shadow:
            inset 0 0 0 1.5px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent),
            inset 1.8px 3px 0 -2px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 90%), transparent),
            inset -2px -2px 0 -2px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 80%), transparent),
            inset -3px -8px 1px -6px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 60%), transparent),
            inset -0.3px -1px 4px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent),
            inset -1.5px 2.5px 0 -2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 20%), transparent),
            inset 0 3px 4px -2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 20%), transparent),
            inset 2px -6.5px 1px -4px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
            0 1px 5px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
            0 6px 16px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 8%), transparent);
    }
    .glass-ui:focus-visible { 
        outline: 2px solid var(--c-action);
        outline-offset: 4px;
    }

    /* ===== TOOLBAR: unified toolbar (HIG-aligned) ===== */
    .header-toolbar{
      position: sticky; top: 0; z-index: 1000;
      /* padding horizontal consistente com a grade do app */
      padding: max(0px, env(safe-area-inset-top)) clamp(16px, 4vw, 32px) 0;
      backdrop-filter: none; /* o cristal fica na .toolbar */
    }

    /* Base da toolbar */
    .toolbar{
      --tb-h: 48px;
      --tb-gap: 8px;
      --tb-pad-x: 8px;
      --tb-radius: 14px;
      position: relative;
      display: flex; align-items: center; gap: var(--tb-gap);
      padding: 6px var(--tb-pad-x);
      border-radius: var(--tb-radius);
      background-color: color-mix(in srgb, var(--c-glass) 10%, transparent);
      backdrop-filter: blur(10px) saturate(var(--saturation));
      -webkit-backdrop-filter: blur(10px) saturate(var(--saturation));
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 0 0 1px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 8%), transparent),
        inset 1.2px 2px 0 -1px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 70%), transparent),
        inset -1px -1px 0 -1px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 15%), transparent),
        0 6px 16px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 8%), transparent);
      transition: background-color 400ms cubic-bezier(1,0,0.4,1), box-shadow 400ms cubic-bezier(1,0,0.4,1), border-color 400ms cubic-bezier(1,0,0.4,1);
    }

    /* === MODO UNIFICADO (recomendado) === */
    .toolbar--attached{
      /* mantém cantos arredondados para integração visual suave */
      border-radius: var(--tb-radius) !important;
      border-top: 1px solid color-mix(in srgb, var(--c-light) 8%, transparent);
      /* hairline na base, sombras reduzidas mas com profundidade sutil */
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 8%, transparent),
        0 2px 8px color-mix(in srgb, var(--c-dark) 6%, transparent);
      background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
      margin: 8px 16px 0;
    }

    /* altura consistente e espaçamento vertical mínimo */
    .header-toolbar .toolbar{
      min-height: calc(var(--tb-h) + 8px);
      padding-top: 6px; padding-bottom: 6px;
    }

    /* Estado scrollado: deixa a base mais definida (feedback sutil) */
    .header-toolbar.is-scrolled .toolbar--attached{
      background-color: color-mix(in srgb, var(--c-glass) 85%, var(--c-bg-surface));
      backdrop-filter: blur(22px) saturate(1.4);
      border-radius: var(--tb-radius) !important;
      border-bottom-color: color-mix(in srgb, var(--c-light) 18%, transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 12%, transparent),
        0 2px 12px color-mix(in srgb, var(--c-dark) 8%, transparent),
        0 1px 3px color-mix(in srgb, var(--c-dark) 12%, transparent);
    }
    
    /* Backdrop mais intenso quando scrolled para melhor legibilidade */
    .header-toolbar.is-scrolled::after{
      background: linear-gradient(
        to bottom,
        var(--c-bg-surface) 0%,
        color-mix(in srgb, var(--c-bg-surface) 92%, transparent) 25%,
        transparent 65%
      );
      backdrop-filter: blur(16px) saturate(1.3);
      mask-image: linear-gradient(
        to bottom,
        black 0% 50%,
        transparent 80% 100%
      );
    }

    /* === MODO FLUTUANTE (opcional) === */
    .toolbar--floating{
      border-radius: var(--tb-radius) !important;
      margin-top: clamp(8px, 2vh, 14px);
      /* sombra mais pronunciada, já que é um "objeto" flutuando */
      box-shadow:
        0 8px 24px color-mix(in srgb, var(--c-dark) 20%, transparent),
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 50%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
    }

    /* Responsivo: em telas muito pequenas, reduz interno */
    @media (max-width: 480px){
      .header-toolbar .toolbar{ padding-left: 6px; padding-right: 6px; }
    }

    /* Grupos e espaçadores */
    .tgroup{ display:flex; align-items:center; gap:6px; }
    .tspacer{ flex:1; }

    /* Botão de toolbar */
    .tbtn{
      --hit: 36px;
      display:inline-flex; align-items:center; gap:8px; justify-content:center;
      height: var(--hit); padding: 0 12px; border-radius: 12px; cursor:pointer;
      color: var(--c-content); background: color-mix(in srgb, var(--c-glass) 14%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 45%), transparent),
        inset 0 -1px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
        0 1px 2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent);
      transition: transform 140ms ease, box-shadow 200ms ease, color 200ms ease, background-color 200ms ease, border-color 200ms ease;
      font: 600 12px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .tbtn:hover{ color: var(--c-action); transform: translateY(-1px); }
    .tbtn:active{ transform: translateY(0); }
    .tbtn:focus-visible{ outline: 2px solid color-mix(in srgb, var(--c-action) 60%, transparent); outline-offset: 2px; }
    .tbtn[disabled]{ opacity:.55; cursor:not-allowed; }
    .tbtn[aria-pressed="true"]{
      color: var(--c-light);
      background: linear-gradient(135deg, color-mix(in srgb, var(--c-action) 60%, transparent), color-mix(in srgb, var(--c-action) 25%, var(--c-dark)));
      border-color: color-mix(in srgb, var(--c-action) 40%, transparent);
    }

    /* Botão apenas ícone */
    .tbtn--icon{ width: var(--hit); padding:0; }
    .ticon{ width:20px; height:20px; display:block; }

    /* Campo de busca */
    .tsearch{ position:relative; min-width: 240px; }
    .tsearch__input{
      height: var(--hit); width:100%;
      padding:0 12px 0 36px; border-radius:12px; border:1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      color: var(--c-content); background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 40%), transparent);
      outline:none;
      font-family: "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .tsearch__icon{ position:absolute; left:10px; top:50%; transform:translateY(-50%); width:18px; height:18px; opacity:.8; }

    /* Overflow popover */
    .popover{
      position:absolute; top: calc(100% + 8px); right: 8px; min-width: 220px; padding:8px;
      border-radius: 14px; z-index: 10;
      background: color-mix(in srgb, var(--c-glass) 22%, transparent);
      backdrop-filter: blur(10px) saturate(var(--saturation));
      -webkit-backdrop-filter: blur(10px) saturate(var(--saturation));
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 12%), transparent);
      box-shadow:
        0 10px 26px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 20%), transparent),
        inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 45%), transparent);
    }
    .popover[hidden]{ display:none; }
    .popover__item{ width:100%; }
    .popover__btn{ width:100%; justify-content:flex-start; }

    /* Toolbar acoplada deve ser STICKY (não fixed) para seguir o fluxo do header */
    .header-toolbar{
      position: sticky;
      top: 0;
      left: auto;
      right: auto;
      z-index: 1000;
      padding: max(0px, env(safe-area-inset-top)) clamp(8px, 2vw, 16px) 8px;
    }
    
    /* Backdrop elegante para "engolir" o conteúdo que passa por baixo */
    .header-toolbar::after{
      content: '';
      position: absolute;
      inset: 0;
      height: 200%;
      background: linear-gradient(
        to bottom,
        var(--c-bg-surface) 0%,
        color-mix(in srgb, var(--c-bg-surface) 85%, transparent) 30%,
        transparent 70%
      );
      backdrop-filter: blur(12px) saturate(1.2);
      mask-image: linear-gradient(
        to bottom,
        black 0% 45%,
        transparent 75% 100%
      );
      pointer-events: none;
      z-index: -1;
    }
    
    .toolbar--attached{
      /* mantém cantos arredondados para integração visual suave */
      border-radius: var(--tb-radius) !important;
      border-top: 1px solid color-mix(in srgb, var(--c-light) 8%, transparent);
      /* hairline na base, sombras reduzidas mas com profundidade sutil */
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 8%, transparent),
        0 2px 8px color-mix(in srgb, var(--c-dark) 6%, transparent);
      background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
      margin: 0;
      position: relative;
      z-index: 1;
    }

    /* ======= FASE 2: Ponte de compatibilidade para botões legados ======= */
    /* Mantém compatibilidade com .btn enquanto migra para .tbtn */
    .btn { 
      all: unset; 
      display:inline-flex; align-items:center; gap:6px;
      height:36px; padding:0 12px; border-radius:12px; cursor:pointer; 
      color: var(--c-content); background: color-mix(in srgb, var(--c-glass) 14%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 45%), transparent),
        inset 0 -1px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
        0 1px 2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent);
      transition: transform 140ms ease, box-shadow 200ms ease, color 200ms ease, background-color 200ms ease, border-color 200ms ease;
      font: 600 12px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .btn:hover{ color: var(--c-action); transform: translateY(-1px); }
    .btn[aria-pressed="true"]{
      color: var(--c-light);
      background: linear-gradient(135deg, color-mix(in srgb, var(--c-action) 60%, transparent), color-mix(in srgb, var(--c-action) 25%, var(--c-dark)));
      border-color: color-mix(in srgb, var(--c-action) 40%, transparent);
    }
    .btn-icon { width:36px; padding:0; }
    .btn svg { width:20px; height:20px; }

    /* Slider Kit com output flutuante */
    .glass-slider {
        -webkit-appearance: none; appearance: none;
        width: 100%; height: 24px; background: transparent;
        outline: none; cursor: pointer;
    }
    .glass-slider::-webkit-slider-runnable-track {
        width: 100%; height: 16px; border-radius: 99em; margin-top: 4px;
        background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
        box-shadow: inset 0 1px 2px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 15%), transparent),
                    inset 0 0 0 1.5px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 5%), transparent);
    }
    .glass-slider::-webkit-slider-thumb {
        -webkit-appearance: none; appearance: none;
        position: relative; width: 32px; height: 32px; border-radius: 50%;
        margin-top: -8px; z-index: 2;
        background-color: color-mix(in srgb, var(--c-glass) 36%, transparent);
        box-shadow:
            inset 0 0 0 1.5px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent),
            0 3px 6px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 15%), transparent);
        transition: transform 150ms ease;
    }
    .glass-slider:active::-webkit-slider-thumb { transform: scale(1.15); }
    .glass-slider:focus-visible { 
        outline: 2px solid var(--c-action);
        outline-offset: 4px;
    }

    .slider-with-output-container { position: relative; width: 80%; max-width: 300px; }
    .slider-output {
        position: absolute; bottom: 45px; min-width: 40px; padding: 6px 10px;
        border-radius: 8px; text-align: center;
        font-weight: 600; font-size: 0.9rem; transform: translateX(-50%);
        transition: opacity 200ms ease; opacity: 0; pointer-events: none;
        background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
        backdrop-filter: blur(12px) saturate(var(--saturation));
        -webkit-backdrop-filter: blur(12px) saturate(var(--saturation));
        color: var(--c-content);
    }
    .slider-with-output-container:hover .slider-output,
    .slider-with-output-container:has(:active) .slider-output { opacity: 1; }

    /* ======= Liquid Glass Kit Switches ======= */
    .glass-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.15);
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(8px) saturate(1.4);
    }

    .glass-switch:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.25);
    }

    .glass-switch input {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }

    .glass-switch .switch-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.8);
      transition: transform 0.2s ease, background 0.2s ease;
      backdrop-filter: blur(4px);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    .glass-switch input:checked + .switch-slider {
      transform: translateX(20px);
      background: var(--c-action);
    }

    .glass-switch input:focus + .switch-slider {
      outline: 2px solid var(--c-action);
      outline-offset: 2px;
    }

    .glass-switch input:disabled + .switch-slider {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .glass-switch:has(input:disabled) {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* ===== Sheets: unificação do material ===== */
    .dialog-sheet{
      --sheet-radius: 18px;
      --sheet-pad: 0;
      --sheet-blur: var(--lg-blur);
      --sheet-sat: var(--lg-sat);
      --sheet-ctr: var(--lg-contrast);

      padding: var(--sheet-pad);
      border-radius: var(--sheet-radius);
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      backdrop-filter: blur(var(--sheet-blur)) saturate(var(--sheet-sat)) contrast(var(--sheet-ctr));
      -webkit-backdrop-filter: blur(var(--sheet-blur)) saturate(var(--sheet-sat)) contrast(var(--sheet-ctr));
      border: 1px solid color-mix(in srgb, var(--c-light) 18%, transparent);
      box-shadow:
        inset 0 0 0 1px color-mix(in srgb, var(--c-light) 8%, transparent),
        0 20px 60px color-mix(in srgb, var(--c-dark) 35%, transparent),
        0 6px 20px color-mix(in srgb, var(--c-dark) 22%, transparent);
    }

    /* Backdrop consistente (sem "apagar" a UI) */
    dialog::backdrop{
      background: color-mix(in srgb, black 45%, transparent);
      -webkit-backdrop-filter: blur(2px);
      backdrop-filter: blur(2px);
    }

    /* Cabeçalho enxuto + hairline */
    .glass-panel-header{
      background: color-mix(in srgb, var(--c-glass) 10%, transparent);
      backdrop-filter: blur(10px) saturate(var(--saturation));
      -webkit-backdrop-filter: blur(10px) saturate(var(--saturation));
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      min-height: 44px;
      padding: 16px 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 600;
      font-size: 1.1em;
      color: var(--c-content);
    }

    /* Conteúdo com scroll-shadow (indica overflow) */
    .glass-panel-content{
      position: relative;
      mask-image: linear-gradient(to bottom, transparent 0, black 12px, black calc(100% - 12px), transparent 100%);
      padding: 20px;
      color: var(--c-content);
    }
    .glass-panel-content::before,
    .glass-panel-content::after{
      content:""; position: sticky; left:0; right:0; height:12px; pointer-events:none; z-index:2;
    }
    .glass-panel-content::before{ top:0;
      background: linear-gradient(to bottom, color-mix(in srgb, var(--c-dark) 18%, transparent), transparent);
    }
    .glass-panel-content::after{ bottom:0;
      background: linear-gradient(to top, color-mix(in srgb, var(--c-dark) 18%, transparent), transparent);
    }

    /* Rodapé: keyline superior e altura mínima */
    .glass-panel-footer{
      border-top: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      min-height: 44px;
      padding: 16px 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    /* Botões principais do sheet – alvos confortáveis */
    .glass-panel-footer .tbtn{ min-height: 32px; }

    /* Pequenas melhorias de foco */
    dialog .tbtn:focus-visible,
    dialog [role="tab"]:focus-visible,
    dialog input:focus-visible{
      outline: 2px solid color-mix(in srgb, var(--c-action) 60%, transparent);
      outline-offset: 2px;
      border-radius: 10px;
    }

    /* ======= Liquid Glass Kit Toasts ======= */
    .glass-toast {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      min-width: 280px;
      max-width: 400px;
      padding: 16px 20px;
      background: color-mix(in srgb, var(--c-glass) 15%, transparent);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      backdrop-filter: blur(20px) saturate(var(--saturation)) contrast(var(--contrast));
      -webkit-backdrop-filter: blur(20px) saturate(var(--saturation)) contrast(var(--contrast));
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.15),
        0 4px 16px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.25);
      color: var(--c-content);
      font-weight: 500;
      transform: translateX(120%);
      transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
    }

    .glass-toast.show {
      transform: translateX(0);
    }

    .glass-toast.success {
      border-color: rgba(52, 211, 153, 0.4);
      background: color-mix(in srgb, #34d399 8%, color-mix(in srgb, var(--c-glass) 15%, transparent));
    }

    .glass-toast.error {
      border-color: rgba(248, 113, 113, 0.4);
      background: color-mix(in srgb, #f87171 8%, color-mix(in srgb, var(--c-glass) 15%, transparent));
    }

    .glass-toast.info {
      border-color: rgba(96, 165, 250, 0.4);
      background: color-mix(in srgb, #60a5fa 8%, color-mix(in srgb, var(--c-glass) 15%, transparent));
    }

    /* ======= Liquid Glass Kit Accessibility ======= */
    @media (prefers-reduced-motion: reduce) {
      .glass-slider,
      .glass-switch,
      .glass-panel,
      .glass-toast,
      .tbtn {
        transition: none !important;
        animation: none !important;
      }
      
      .glass-toast {
        transform: translateX(0) !important;
      }
    }

    @media (prefers-contrast: high) {
      .glass-panel,
      .glass-toast {
        background: var(--c-bg);
        border-color: var(--c-content);
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }
      
      .glass-slider,
      .glass-switch {
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        border-width: 2px;
      }
    }

    /* Focus ring improvements for glass components */
    .glass-slider:focus-visible,
    .glass-switch input:focus-visible + .switch-slider,
    .tbtn:focus-visible {
      outline: 2px solid var(--c-action);
      outline-offset: 3px;
      border-radius: 8px;
    }

    /* ======= PATCHES: Find Bar, Footer, Toolbar fixes ======= */
    
    /* 1) Qualquer [hidden] deve sumir, mesmo com display declarado em CSS */
    [hidden] { display: none !important; }

    /* 2) Find Bar REDESIGNED: Posicionamento inteligente e UX melhorada */
    #findBar { 
      /* Posicionamento relativo ao editor, não absoluto global */
      position: absolute;
      top: 12px;
      right: 12px;
      left: auto;
      z-index: 1500; /* Maior que toolbar (900) e header (1000) */
      max-width: min(90vw, 520px);
      min-width: 320px;
      
      /* Remove conflitos de layout */
      transform: none;
      margin: 0;
    }

    /* Evita que findbar fique sob minimap ou em mobile */
    .editor-shell.minimap-on #findBar {
      right: calc(var(--mini-w) + 12px);
    }
    
    @media (max-width: 640px) {
      #findBar {
        position: fixed;
        top: calc(48px + 60px); /* header + toolbar height + margin */
        right: 8px; 
        left: 8px;
        min-width: auto;
        max-width: none;
        z-index: 1600; /* Ainda maior em mobile */
      }
      
      /* Em mobile, findbar sempre fica acima de tudo */
      .editor-shell.minimap-on #findBar {
        right: 8px; /* Reset minimap offset em mobile */
      }
    }

    /* 3) Footer colado ao fundo (dentro do layout de grid) */
    footer.status {
      grid-row: 4;
      position: static;
      height: 32px;
      z-index: 800;
    }

    /* 4) Unificar comportamento da header-toolbar: STICKY, não fixed */
    .header + .header-toolbar { /* já existe esta regra */
      position: sticky;
      top: 48px;
      z-index: 900;
      padding: 8px 32px 0;
    }
    /* (mantido acima) regra única já garante sticky sem !important */

    /* ======= Acessibilidade aprimorada (HIG) ======= */
    @media (prefers-reduced-motion: reduce){
      .toolbar, .tbtn, .btn { transition: none !important; }
      .glass-ui, .glass-panel, .glass-toast { transition: none !important; animation: none !important; }
      .note-row { transition: none !important; }
      .find-option-toggle { transition: none !important; }
    }

    /* Alto contraste para acessibilidade */
    @media (prefers-contrast: high) {
      .glass-panel, .glass-toast, .toolbar, #findBar {
        background: var(--c-bg) !important;
        border-color: var(--c-content) !important;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
      }
      
      .glass-slider, .glass-switch {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        border-width: 2px !important;
      }

      .note-row {
        background: var(--c-bg) !important;
        border-color: var(--c-content) !important;
      }

      .tbtn:focus-visible,
      dialog .tbtn:focus-visible,
      dialog [role="tab"]:focus-visible,
      dialog input:focus-visible{
        outline: 3px solid var(--c-action) !important;
        outline-offset: 3px !important;
      }
    }

    html,body{height:100%}
    body{margin:0;overflow:hidden;color:var(--text);font:400 var(--font-size)/var(--line-height) var(--code-font);background:var(--bg)}
    body::before{content:"";position:fixed;inset:0;z-index:-2;pointer-events:none;background:
      radial-gradient(120vh 80vh at 80% -10%, rgba(10,132,255,0.10), transparent 60%),
      radial-gradient(110vh 70vh at -10% -20%, rgba(94,92,230,0.08), transparent 55%),
      linear-gradient(180deg, var(--bg), var(--bg-2));background-size:100% 100%;background-repeat:no-repeat;background-attachment:fixed}
    body::after{content:"";position:fixed;inset:0;z-index:-1;pointer-events:none;background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAPElEQVR4nO3QMQEAAAgDIN8/9E0gY0oYj8q6CwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANw8g1gAAU6l8mEAAAAASUVORK5CYII=');opacity:.06;image-rendering:pixelated}

    /* ===== Layout ===== */
    .layout{
      display:grid;
      grid-template-rows: min-content 1fr 32px;
      height:100svh;
      min-height:0;
      width:100%;
      overflow:hidden;
    }
    .editor-shell,.editor-wrap,#editor,.gutter,.minimap{min-height:0}

    /* a barra única agora gruda no topo da viewport */
    .header-toolbar{
      grid-row: 1;
      position: sticky;
      top: 0;
      z-index: 1000;
      padding: max(0px, env(safe-area-inset-top)) clamp(16px, 4vw, 32px) 0;
    }
    .toolbar--attached{
      border-top-left-radius: 0;
      border-top-right-radius: 0;
      border-top: none;
    }

    .title-chip{
      display:inline-flex; align-items:center; gap:8px;
      height: 32px; padding: 0 10px; border-radius: 10px;
      cursor: text;
      color: var(--c-content);
      background: color-mix(in srgb, var(--c-glass) 14%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 40%), transparent);
      font: 600 12px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .title-chip:hover{ color: var(--c-action); transform: translateY(-1px); }
    .title-chip:focus-visible{ outline: 2px solid color-mix(in srgb, var(--c-action) 60%, transparent); outline-offset: 2px; }
    .title-chip .ticon{ width:16px; height:16px; opacity:.7 }

    .menu-section{
      font-size:10px; font-weight:700; letter-spacing:.06em;
      color: var(--text-muted); text-transform: uppercase;
      padding: 6px 8px 4px;
    }
    .menu-divider{
      height:1px; margin:6px 4px;
      background: color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
    }
    .popover__btn[role="menuitemcheckbox"][aria-checked="true"]{
      color: var(--c-light);
      background: linear-gradient(135deg, color-mix(in srgb, var(--c-action) 60%, transparent), color-mix(in srgb, var(--c-action) 25%, var(--c-dark)));
      border-color: color-mix(in srgb, var(--c-action) 40%, transparent);
    }

    /* LiquidGlass surface helper */
    .lg-surface{
      background:color-mix(in oklab, var(--bg), white 6%);
      backdrop-filter: blur(var(--lg-blur)) saturate(var(--lg-sat)) contrast(var(--lg-contrast));
      -webkit-backdrop-filter: blur(var(--lg-blur)) saturate(var(--lg-sat)) contrast(var(--lg-contrast));
      border:1px solid var(--stroke);
      box-shadow:
        inset 0 0 0 1px color-mix(in oklab, var(--lg-highlight), transparent 70%),
        0 1px 8px rgba(0,0,0,.18);
    }

    /* Footer override para evitar conflitos de layout */
    footer.lg-surface {
      grid-row: 3;
      background: color-mix(in oklab, var(--bg), white 5%);
      border: none;
      border-top: 1px solid var(--stroke);
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      box-shadow: none;
    }

    /* Toolbar acoplada - usa padrão do Kit */
    .header-toolbar{
      position: sticky; top: 0;
      left: auto; right: auto;
      z-index: 1000;
      padding: 8px 32px 0;
    }

    .brand{display:inline-flex;align-items:center;gap:8px;font-weight:600;font-size:14px;color:var(--c-content);font-family:"DM Sans",system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    .brand-dot{width:7px;height:7px;border-radius:999px;background:linear-gradient(180deg,var(--accent),var(--accent-2));box-shadow:0 0 0 2px color-mix(in oklab, var(--accent), transparent 70%)}
    .spacer{flex:1}

    /* Botões antigos removidos - usando ponte de compatibilidade agora */

    .btn-active {
      background: color-mix(in oklab, var(--accent), transparent 85%) !important;
      border-color: color-mix(in oklab, var(--accent), black 30%) !important;
      box-shadow: inset 0 1px 2px color-mix(in oklab, var(--accent), black 80%) !important;
      color: var(--text) !important;
    }

    .title-editor {
      background: var(--panel-strong);
      border: 1px solid var(--accent);
      color: var(--text);
      font-family: inherit;
      font-size: inherit;
      padding: 1px 4px;
      border-radius: 4px;
      outline: none;
      width: 300px;
      margin-left: -4px;
    }

    /* Font Controls */
    .font-controls {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      padding: 1px;
      background: color-mix(in oklab, var(--bg), white 4%);
      border: 1px solid var(--stroke);
      border-radius: 10px;
      
      /* Liquid Glass Effect */
      backdrop-filter: blur(8px) saturate(130%) brightness(1.08);
      -webkit-backdrop-filter: blur(8px) saturate(130%) brightness(1.08);
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.12),
        inset 1px 0 0 rgba(255,255,255,0.08),
        inset 0 -1px 0 rgba(0,0,0,0.08),
        0 1px 3px rgba(0,0,0,0.1);
    }
    
    .font-btn {
      width: 24px;
      height: 24px;
      padding: 0;
      border-radius: 6px;
      background: transparent;
      border: 1px solid transparent;
      transition: all 0.2s cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .font-btn:hover {
      background: color-mix(in oklab, var(--panel), white 8%);
      border-color: color-mix(in oklab, var(--stroke), white 20%);
      transform: translateY(-1px) scale(1.05);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    
    .font-btn:active {
      transform: translateY(0) scale(0.95);
      background: color-mix(in oklab, var(--panel), white 4%);
    }
    
    .font-btn svg {
      width: 12px;
      height: 12px;
      opacity: 0.85;
    }
    
    .font-size-display {
      min-width: 20px;
      padding: 0 4px;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-dim);
      text-align: center;
      line-height: 1.2;
      font-family: var(--code-font);
      user-select: none;
      transition: all 0.3s cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .font-size-display.changed {
      color: var(--accent);
      transform: scale(1.1);
    }

    .progress{position:fixed;top:0;left:0;height:3px;width:0%;z-index:9;background:linear-gradient(90deg,var(--accent),var(--accent-2));box-shadow:0 0 12px color-mix(in oklab, var(--accent), transparent 40%)}

    /* Editor shell */
    .editor-shell{
      display:grid;
      grid-template-columns:0px 1fr 0px;
      height:100%;
      position:relative;
      overflow:hidden;
      min-height:0;
    }
    .editor-shell.lines-on{grid-template-columns:var(--gutter-w) 1fr 0px}
    .editor-shell.minimap-on{grid-template-columns:0px 1fr var(--mini-w)}
    .editor-shell.lines-on.minimap-on{grid-template-columns:var(--gutter-w) 1fr var(--mini-w)}

    .gutter{position:relative;overflow:hidden;border-right:1px solid var(--stroke);background:color-mix(in oklab, var(--bg), white 3%);font:400 var(--editor-font-size)/var(--line-height) var(--code-font);text-align:right;padding:var(--editor-padding) 6px var(--editor-padding) 4px;user-select:none;scrollbar-width:none;-ms-overflow-style:none;width:0;min-width:0;box-sizing:border-box}
    .gutter::-webkit-scrollbar{display:none}
    .gutter .ln{opacity:.6;padding:0 3px;line-height:inherit;transition:opacity var(--dur) var(--ease),color var(--dur) var(--ease),background var(--dur) var(--ease);white-space:nowrap;border-radius:4px;box-sizing:border-box;cursor:pointer;position:relative}
    .gutter .ln:hover{opacity:.9;background:color-mix(in oklab, var(--accent), transparent 92%)}
    .gutter .ln.current{opacity:1;color:var(--accent);background:color-mix(in oklab, var(--accent), transparent 90%);font-weight:600}

    /* Marcador (bookmark) discreto no gutter */
    .gutter .ln.bookmark::before {
      content: "";
      position: absolute;
      left: 6px;
      top: 50%;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      transform: translateY(-50%);
      background: color-mix(in oklab, var(--accent-2), white 10%);
      box-shadow: 0 0 0 1px color-mix(in oklab, var(--accent-2), black 35%);
      opacity: .9;
    }

    /* Faixa de hover/seleção desenhada no overlay */
    .highlights-overlay .line-hover,
    .highlights-overlay .line-selection {
      position: absolute;
      left: 0; right: 0;
      border-radius: 4px;
      background: color-mix(in oklab, var(--accent), transparent 90%);
      pointer-events: none;
    }
    .highlights-overlay .line-selection {
      background: color-mix(in oklab, var(--accent-2), transparent 85%);
    }

    /* Pontinho sutil para sublinhas quando wrap ativo (opcional) */
    .gutter .ln.continuation::after {
      content: "·";
      opacity: .45;
      margin-left: 4px;
      font-weight: 700;
    }
    .editor-shell.lines-on .gutter{width:auto;min-width:var(--gutter-w)}
    
    /* Gutter pode rolar (barra invisível) – JS sincroniza com o editor */
    .editor-shell.lines-on .gutter {
      overflow-y: auto;
    }
    .editor-shell.lines-on .gutter::-webkit-scrollbar{ display:none }
    .editor-shell.lines-on .gutter{ scrollbar-width:none }

    .editor-wrap{
      position:relative;
      overflow:hidden;
      min-height:0;
      height:100%;
    }
    #editor{
      box-sizing:border-box;
      width:100%;
      height:100%;
      padding:var(--editor-padding);
      border:0;
      outline:none;
      resize:none;
      background:transparent;
      color:var(--text);
      font:400 var(--editor-font-size)/var(--line-height) var(--code-font);
      caret-color:var(--accent);
      tab-size:2;
      white-space:pre;
      overflow:auto;
      scrollbar-color:var(--panel-strong) transparent;
      scrollbar-width:thin;
      contain:content;
      min-height:100%;
    }

    .highlights-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      box-sizing: border-box;
      padding: var(--editor-padding);
      font: 400 var(--editor-font-size)/var(--line-height) var(--code-font);
      white-space: pre;
      overflow: hidden;
      pointer-events: none;
      tab-size: 2;
      color: transparent; /* O texto é invisível, apenas os destaques aparecem */
    }
    .highlights-overlay mark,
    .highlights-overlay .find-hit {
      border-radius: 3px;
      background: color-mix(in oklab, var(--accent), transparent 75%);
      color: transparent;
    }
    .highlights-overlay mark.current,
    .highlights-overlay .find-hit.current {
      background: color-mix(in oklab, var(--accent-2), transparent 65%);
      box-shadow: 0 0 8px color-mix(in oklab, var(--accent-2), transparent 70%);
    }

    /* ======= Find Bar Redesigned - Interface Consistente ======= */
    #findBar {
      position: absolute;
      right: 12px;
      top: 12px;
      border-radius: 16px;
      z-index: 1500;
      min-width: 360px;
      max-width: min(90vw, 580px);
      
      /* Layout vertical organizado */
      display: flex; 
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      
      /* Usa exatamente o mesmo estilo da toolbar para consistência */
      background-color: color-mix(in srgb, var(--c-glass) 10%, transparent);
      backdrop-filter: blur(10px) saturate(var(--saturation));
      -webkit-backdrop-filter: blur(10px) saturate(var(--saturation));
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 0 0 1px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 8%), transparent),
        inset 1.2px 2px 0 -1px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 70%), transparent),
        inset -1px -1px 0 -1px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 15%), transparent),
        0 8px 24px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent);
      transition: background-color 400ms cubic-bezier(1,0,0.4,1), box-shadow 400ms cubic-bezier(1,0,0.4,1), border-color 400ms cubic-bezier(1,0,0.4,1);
    }
    
    /* Evita que findbar fique sob minimap ou em mobile */
    .editor-shell.minimap-on #findBar {
      right: calc(var(--mini-w) + 12px);
    }
    
    @media (max-width: 640px) {
      #findBar {
        position: fixed;
        top: calc(48px + 60px); /* header + toolbar height + margin */
        right: 8px; 
        left: 8px;
        min-width: auto;
        max-width: none;
        z-index: 1600; /* Ainda maior em mobile */
      }
      
      /* Em mobile, findbar sempre fica acima de tudo */
      .editor-shell.minimap-on #findBar {
        right: 8px; /* Reset minimap offset em mobile */
      }
    }
    
    /* Primeira linha: busca + navegação + fechar */
    .find-primary-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    /* Segunda linha: substituir (quando ativa) */
    .find-replace-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    /* Terceira linha: opções */
    .find-options-row {
      display: flex;
      gap: 6px;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
    }
    
    /* Input fields consistentes */
    .find-input {
      height: 36px;
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      border-radius: 12px;
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      color: var(--c-content);
      padding: 0 12px;
      font-size: 13px;
      outline: none;
      flex: 1;
      min-width: 0;
      font-family: "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 40%), transparent);
      transition: border-color 200ms ease, box-shadow 200ms ease;
    }
    
    .find-input:focus {
      border-color: var(--c-action);
      box-shadow: 0 0 0 2px color-mix(in srgb, var(--c-action) 60%, transparent);
    }
    
    .find-input::placeholder {
      color: color-mix(in srgb, var(--c-content) 60%, transparent);
    }
    
    /* Inputs específicos */
    #findInput {
      min-width: 200px;
    }
    
    #replaceInput {
      min-width: 180px;
    }
    
    /* Contador de matches melhorado */
    .find-count-display {
      color: var(--c-content);
      font-size: 12px;
      font-weight: 600;
      padding: 6px 10px;
      background: color-mix(in srgb, var(--c-glass) 16%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      border-radius: 8px;
      min-width: 50px;
      text-align: center;
      white-space: nowrap;
      font-family: "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-variant-numeric: tabular-nums;
    }
    
    /* Botões da findbar - usando .tbtn consistente */
    #findBar .tbtn {
      height: 36px;
      flex-shrink: 0;
    }
    
    #findBar .tbtn--icon {
      width: 36px;
      padding: 0;
    }
    
    /* Option toggles redesigned */
    .find-option-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 32px;
      padding: 0;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
      transition: all 200ms ease;
      
      /* Mesmo padrão visual dos botões da toolbar */
      color: var(--c-content); 
      background: color-mix(in srgb, var(--c-glass) 14%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 45%), transparent),
        inset 0 -1px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
        0 1px 2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent);
    }
    
    .find-option-toggle:hover {
      color: var(--c-action); 
      transform: translateY(-1px);
    }
    
    .find-option-toggle:active {
      transform: translateY(0);
    }
    
    .find-option-toggle[aria-pressed="true"] {
      color: var(--c-light);
      background: linear-gradient(135deg, color-mix(in srgb, var(--c-action) 60%, transparent), color-mix(in srgb, var(--c-action) 25%, var(--c-dark)));
      border-color: color-mix(in srgb, var(--c-action) 40%, transparent);
    }
    
    /* Responsive behavior aprimorado */
    @media (max-width: 640px) {
      #findBar {
        position: fixed;
        top: 70px; /* Espaço para header + toolbar */
        right: 8px;
        left: 8px;
        min-width: auto;
        max-width: none;
        z-index: 1600;
      }
      
      .find-primary-row,
      .find-replace-row {
        flex-wrap: wrap;
        gap: 6px;
      }
      
      .find-input {
        min-width: 0;
        flex: 1 1 120px;
      }
      
      .find-options-row {
        justify-content: center;
        gap: 4px;
      }
      
      .find-option-toggle {
        width: 32px;
        height: 28px;
        font-size: 10px;
      }
    }
    
    /* Estados especiais para highlights */
    .find-hit {
      border-radius: 3px;
      background: color-mix(in oklab, var(--accent), transparent 75%);
      color: transparent;
    }
    
    .find-hit.current {
      background: color-mix(in oklab, var(--accent-2), transparent 65%);
      box-shadow: 0 0 8px color-mix(in oklab, var(--accent-2), transparent 70%);
    }

    .overlay-dialog {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 1100; /* Maior que o header-toolbar (z-index: 1000) */
      padding: 6px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,.25);
    }

    /* Go To Line Bar - usando mesmo estilo da findBar */
    #goToLine { 
      position: absolute;
      top: 12px;
      right: 12px;
      left: auto;
      z-index: 1500; /* Mesmo z-index da findBar */
      max-width: min(90vw, 360px);
      min-width: 280px;
      
      /* Remove conflitos de layout */
      transform: none;
      margin: 0;
    }

    /* Remove as setinhas padrão do input number */
    #goToLineInput::-webkit-outer-spin-button,
    #goToLineInput::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    #goToLineInput[type=number] {
      appearance: textfield; /* Padrão */
      -moz-appearance: textfield; /* Firefox */
    }

    /* Evita que goToLine fique sob minimap */
    .editor-shell.minimap-on #goToLine {
      right: calc(var(--mini-w) + 12px);
    }
    
    @media (max-width: 640px) {
      #goToLine {
        position: fixed;
        top: calc(48px + 60px); /* header + toolbar height + margin */
        right: 8px; 
        left: 8px;
        min-width: auto;
        max-width: none;
        z-index: 1600;
      }
      
      .editor-shell.minimap-on #goToLine {
        right: 8px;
        left: 8px;
      }
    }
    .overlay-dialog.shake {
        animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
    }
    @keyframes shake {
      10%, 90% { transform: translate3d(-1px, 0, 0); }
      20%, 80% { transform: translate3d(2px, 0, 0); }
      30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
      40%, 60% { transform: translate3d(4px, 0, 0); }
    }

    /* ===== Minimal Dropzone with Clean Liquid Glass ===== */
    .dropzone-overlay {
      position: fixed;
      inset: 0;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.25s ease-out, visibility 0.25s ease-out;
      
      /* Clean Liquid Glass Background */
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(20px) saturate(120%);
      -webkit-backdrop-filter: blur(20px) saturate(120%);
    }
    
    .dropzone-overlay.show {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
    
    .dropzone-content {
      position: relative;
      padding: 40px 48px;
      border-radius: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      pointer-events: none;
      
      /* Minimal Liquid Glass */
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(24px) saturate(130%);
      -webkit-backdrop-filter: blur(24px) saturate(130%);
      
      box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 8px 32px rgba(0, 0, 0, 0.3);
      
      transform: scale(0.95);
      transition: transform 0.3s cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .dropzone-overlay.show .dropzone-content {
      transform: scale(1);
    }
    
    .dropzone-icon {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 16px;
      
      /* Simple glass container */
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      
      transition: all 0.2s ease-out;
    }
    
    .dropzone-content svg {
      width: 28px;
      height: 28px;
      stroke: var(--text);
      stroke-width: 1.8;
      opacity: 0.9;
    }
    
    .dropzone-title {
      font-size: 1.1rem;
      font-weight: 500;
      color: var(--text);
      text-align: center;
      margin: 0;
      letter-spacing: -0.01em;
    }
    
    .dropzone-subtitle {
      font-size: 0.875rem;
      color: var(--text-dim);
      text-align: center;
      margin: 0;
      opacity: 0.8;
    }
    
    /* Responsive Design */
    @media (max-width: 640px) {
      .dropzone-content {
        padding: 32px 36px;
        border-radius: 16px;
        gap: 16px;
      }
      
      .dropzone-icon {
        width: 52px;
        height: 52px;
        border-radius: 14px;
      }
      
      .dropzone-content svg {
        width: 24px;
        height: 24px;
      }
      
      .dropzone-title {
        font-size: 1rem;
      }
      
      .dropzone-subtitle {
        font-size: 0.8rem;
      }
    }

    /* ===== Minimal Toast Notifications ===== */
    .toast {
      position: fixed;
      top: 24px;
      right: 24px;
      z-index: 1000;
      padding: 12px 20px;
      border-radius: 12px;
      color: var(--text);
      font-size: 13px;
      font-weight: 500;
      max-width: 320px;
      text-align: center;
      
      /* Clean Liquid Glass */
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(20px) saturate(120%);
      -webkit-backdrop-filter: blur(20px) saturate(120%);
      
      box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 4px 16px rgba(0, 0, 0, 0.2);
      
      /* Animation */
      transform: translateX(120%) scale(0.95);
      transition: all 0.3s cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .toast.show {
      transform: translateX(0) scale(1);
    }
    
    .toast-success {
      color: #10b981;
      border-color: rgba(16, 185, 129, 0.3);
    }
    
    .toast-error {
      color: #ef4444;
      border-color: rgba(239, 68, 68, 0.3);
    }
    
    .toast-info {
      color: var(--accent);
      border-color: color-mix(in oklab, var(--accent), transparent 70%);
    }
    
    @media (max-width: 640px) {
      .toast {
        left: 16px;
        right: 16px;
        top: 16px;
        max-width: none;
        transform: translateY(-120%) scale(0.95);
      }
      
      .toast.show {
        transform: translateY(0) scale(1);
      }
    }

    .minimap{position:relative;border-left:1px solid var(--stroke);background:color-mix(in oklab, var(--bg), white 3%);overflow:hidden;user-select:none}
    .minimap pre{margin:0;padding:var(--editor-padding) 4px;font:400 2px/2px var(--code-font);opacity:.6;white-space:pre;pointer-events:none}

    /* LiquidGlass Lens for minimap viewport */
    .mini-viewport{
      position:absolute;
      left:4px;
      right:4px;
      border-radius:12px;
      pointer-events:auto;
      cursor:grab;
      
      /* Ultra-transparent glass background */
      background: 
        radial-gradient(ellipse 80% 60% at 25% 20%, rgba(255,255,255,0.15), transparent 70%),
        radial-gradient(ellipse 60% 80% at 75% 80%, rgba(255,255,255,0.08), transparent 60%),
        rgba(255,255,255,0.03);
      
      /* Minimal glass border */
      border: 1px solid rgba(255,255,255,0.12);
      
      /* Glass lens effect with refraction */
      box-shadow: 
        /* Sharp inner highlight edge */
        inset 0 1px 0 0 rgba(255,255,255,0.25),
        inset 1px 0 0 0 rgba(255,255,255,0.15),
        
        /* Curved glass reflection */
        inset 2px 2px 4px -2px rgba(255,255,255,0.2),
        inset -1px -1px 3px -1px rgba(255,255,255,0.1),
        
        /* Bottom lens refraction */
        inset 0 -1px 0 0 rgba(0,0,0,0.1),
        inset -1px 0 0 0 rgba(0,0,0,0.05),
        
        /* Subtle depth shadow */
        inset 0 -2px 8px -3px rgba(0,0,0,0.08),
        
        /* External lens shadow */
        0 1px 3px -1px rgba(0,0,0,0.15),
        0 2px 8px -2px rgba(0,0,0,0.1);
      
      /* Crystal clear backdrop filter */
      backdrop-filter: blur(2px) saturate(120%) brightness(1.1);
      -webkit-backdrop-filter: blur(2px) saturate(120%) brightness(1.1);
      
      /* Smooth lens transitions */
      transition: 
        background 200ms cubic-bezier(0.2, 0.7, 0.2, 1),
        box-shadow 200ms cubic-bezier(0.2, 0.7, 0.2, 1),
        border-color 200ms cubic-bezier(0.2, 0.7, 0.2, 1),
        transform 120ms cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .mini-viewport:hover{
      /* Enhanced lens clarity on hover */
      background: 
        radial-gradient(ellipse 80% 60% at 25% 20%, rgba(255,255,255,0.2), transparent 70%),
        radial-gradient(ellipse 60% 80% at 75% 80%, rgba(255,255,255,0.12), transparent 60%),
        rgba(255,255,255,0.05);
      
      border-color: rgba(255,255,255,0.18);
      
      box-shadow: 
        /* Brighter edge highlights */
        inset 0 1px 0 0 rgba(255,255,255,0.35),
        inset 1px 0 0 0 rgba(255,255,255,0.22),
        
        /* Enhanced glass curvature */
        inset 2px 2px 4px -2px rgba(255,255,255,0.28),
        inset -1px -1px 3px -1px rgba(255,255,255,0.15),
        
        /* Defined lens edges */
        inset 0 -1px 0 0 rgba(0,0,0,0.12),
        inset -1px 0 0 0 rgba(0,0,0,0.08),
        
        /* Slight floating effect */
        0 2px 6px -1px rgba(0,0,0,0.18),
        0 4px 12px -2px rgba(0,0,0,0.12);
      
      /* Enhanced lens optics */
      backdrop-filter: blur(3px) saturate(130%) brightness(1.15);
      -webkit-backdrop-filter: blur(3px) saturate(130%) brightness(1.15);
      
      transform: translateY(-1px);
    }
    
    .mini-viewport:active{
      cursor:grabbing;
      transform: translateY(0px) scale(0.99);
      
      /* Pressed lens effect */
      background: 
        radial-gradient(ellipse 80% 60% at 25% 20%, rgba(255,255,255,0.12), transparent 70%),
        radial-gradient(ellipse 60% 80% at 75% 80%, rgba(255,255,255,0.06), transparent 60%),
        rgba(255,255,255,0.02);
      
      border-color: rgba(255,255,255,0.1);
      
      box-shadow: 
        /* Reduced highlights when pressed */
        inset 0 1px 0 0 rgba(255,255,255,0.18),
        inset 1px 0 0 0 rgba(255,255,255,0.1),
        
        /* Compressed glass effect */
        inset 1px 1px 3px -1px rgba(255,255,255,0.15),
        inset 0 -1px 2px -1px rgba(0,0,0,0.08),
        
        /* Minimal shadow when pressed */
        0 1px 2px -1px rgba(0,0,0,0.12);
      
      /* Focused lens clarity */
      backdrop-filter: blur(1px) saturate(110%) brightness(1.05);
      -webkit-backdrop-filter: blur(1px) saturate(110%) brightness(1.05);
    }
    @supports not (backdrop-filter: blur(2px)){
      .mini-viewport{
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.15);
      }
      .mini-viewport:hover{
        background: rgba(255,255,255,0.12);
      }
    }
    @media (prefers-contrast: more){
      .mini-viewport{box-shadow:none;border-color: color-mix(in oklab, var(--accent), black 55%)}
    }

    /* Minimap disabled state */
    .minimap.mini-disabled {
      opacity: 0.6;
    }
    .minimap.mini-disabled .mini-viewport {
      cursor: default !important;
      pointer-events: none !important;
      opacity: 0.5;
    }

    /* Touch improvements */
    .minimap, .mini-viewport { 
      touch-action: none; 
    }

    footer.status{
      display:flex;
      align-items:center;
      gap:8px;
      padding:0 8px;
      border-top:1px solid var(--stroke);
      background:color-mix(in oklab, var(--bg), white 5%);
      font-size:11px;
      color:var(--text-muted);
      height:32px;
      min-height:32px;
      max-height:32px;
      flex-shrink:0;
      box-sizing:border-box;
      overflow:hidden;
      white-space:nowrap;
      grid-row: 3;
      position: static;
      z-index: 800;
    }
    
    footer.status > * {
      flex-shrink:0;
    }
    
    footer.status .spacer {
      flex:1;
      min-width:0;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:3px 6px;
      border:1px solid var(--stroke);
      background:var(--panel);
      border-radius:999px;
      font-size:10px;
      white-space:nowrap;
      flex-shrink:0;
    }
    .sep{
      width:1px;
      height:12px;
      background:var(--stroke);
      flex-shrink:0;
    }
    .spacer{
      flex:1;
      min-width:0;
    }

    dialog{background:color-mix(in oklab, var(--bg), white 6%);color:var(--text);border:1px solid var(--stroke);border-radius:16px;backdrop-filter:saturate(140%) blur(16px);-webkit-backdrop-filter:saturate(140%) blur(16px)}
    dialog::backdrop{background:rgba(0,0,0,.45)}

    dialog#settings{width:min(96vw, 680px);padding:14px 14px 10px}
    .settings-grid{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center}
    .settings-grid h3{grid-column:1/-1;margin:0 0 6px;font-weight:700}
    .settings-grid label{color:var(--text-dim)}
    .settings-grid input[type=range]{width:260px}


    /* ========= Liquid Glass Range Controls (Ultra Discretos) ========= */
    .range-control {
      position: relative;
      width: 240px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 4px;
      gap: 12px;
    }
    
    .range-control input[type="range"] {
      flex: 1;
      height: 20px;
      background: transparent;
      outline: none;
      border: none;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
      position: relative;
      z-index: 2;
    }
    
    /* Display de valor discreto */
    .range-value {
      font-size: 12px;
      font-weight: 500;
      color: color-mix(in oklab, var(--text), transparent 30%);
      background: color-mix(in oklab, var(--panel), var(--stroke) 15%);
      padding: 2px 6px;
      border-radius: 6px;
      border: 0.5px solid color-mix(in oklab, var(--stroke), transparent 70%);
      min-width: 32px;
      text-align: center;
      font-variant-numeric: tabular-nums;
      
      /* Sombra interna sutil */
      box-shadow: inset 0 0.5px 1px rgba(0,0,0,0.04);
      
      transition: all 0.2s ease;
    }
    
    /* Track discreto mas SEMPRE visível */
    .range-control input[type="range"]::-webkit-slider-track {
      width: 100%;
      height: 4px;
      border-radius: 6px;
      
      /* Trilho mais visível em tons neutros */
      background: color-mix(in oklab, var(--panel), var(--stroke) 45%);
      border: 1px solid color-mix(in oklab, var(--stroke), transparent 40%);
      
      /* Sombra interna para definição clara */
      box-shadow: 
        inset 0 1px 2px rgba(0,0,0,0.1),
        inset 0 -0.5px 0 rgba(255,255,255,0.08);
      
      transition: all 0.2s ease;
    }
    
    .range-control input[type="range"]::-moz-range-track {
      width: 100%;
      height: 4px;
      border-radius: 6px;
      background: color-mix(in oklab, var(--panel), var(--stroke) 45%);
      border: 1px solid color-mix(in oklab, var(--stroke), transparent 40%);
      box-shadow: 
        inset 0 1px 2px rgba(0,0,0,0.1),
        inset 0 -0.5px 0 rgba(255,255,255,0.08);
    }
    
    /* Thumb ultra discreto em tons neutros */
    .range-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      cursor: grab;
      
      /* Fundo neutro discreto */
      background: 
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.15), transparent 70%),
        color-mix(in oklab, var(--panel), var(--stroke) 60%);
      
      /* Borda sutil neutra */
      border: 1px solid color-mix(in oklab, var(--stroke), white 15%);
      
      /* Sombra mínima */
      box-shadow: 
        inset 0 0.5px 0 rgba(255,255,255,0.15),
        0 0.5px 2px rgba(0,0,0,0.08),
        0 0 0 0.5px color-mix(in oklab, var(--stroke), transparent 85%);
      
      transition: 
        transform 0.15s ease,
        box-shadow 0.15s ease,
        border-color 0.15s ease;
    }
    
    .range-control input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      cursor: grab;
      border: 1px solid color-mix(in oklab, var(--stroke), white 15%);
      background: 
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.15), transparent 70%),
        color-mix(in oklab, var(--panel), var(--stroke) 60%);
      box-shadow: 
        inset 0 0.5px 0 rgba(255,255,255,0.15),
        0 0.5px 2px rgba(0,0,0,0.08),
        0 0 0 0.5px color-mix(in oklab, var(--stroke), transparent 85%);
    }
    
    /* Hover mais visível */
    .range-control input[type="range"]:hover::-webkit-slider-track {
      background: color-mix(in oklab, var(--panel), var(--stroke) 55%);
      border-color: color-mix(in oklab, var(--stroke), transparent 30%);
      box-shadow: 
        inset 0 1px 2px rgba(0,0,0,0.12),
        inset 0 -0.5px 0 rgba(255,255,255,0.1);
    }
    
    .range-control input[type="range"]:hover::-webkit-slider-thumb {
      transform: scale(1.05);
      background: 
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2), transparent 70%),
        color-mix(in oklab, var(--panel), var(--stroke) 70%);
      border-color: color-mix(in oklab, var(--stroke), white 25%);
      box-shadow: 
        inset 0 0.5px 0 rgba(255,255,255,0.2),
        0 1px 3px rgba(0,0,0,0.12),
        0 0 0 1px color-mix(in oklab, var(--stroke), transparent 75%);
    }
    
    .range-control input[type="range"]:hover + .range-value {
      background: color-mix(in oklab, var(--panel), var(--stroke) 20%);
      border-color: color-mix(in oklab, var(--stroke), transparent 60%);
      color: color-mix(in oklab, var(--text), transparent 20%);
    }
    
    /* Estado ativo */
    .range-control input[type="range"]:active::-webkit-slider-thumb {
      cursor: grabbing;
      transform: scale(0.95);
      box-shadow: 
        inset 0 0.5px 0 rgba(255,255,255,0.1),
        0 0.5px 1px rgba(0,0,0,0.15),
        0 0 0 1px color-mix(in oklab, var(--stroke), transparent 70%);
    }
    
    /* Foco acessível */
    .range-control input[type="range"]:focus-visible {
      outline: none;
    }
    
    .range-control input[type="range"]:focus-visible::-webkit-slider-thumb {
      box-shadow: 
        inset 0 0.5px 0 rgba(255,255,255,0.15),
        0 0.5px 2px rgba(0,0,0,0.08),
        0 0 0 2px color-mix(in oklab, var(--stroke), transparent 50%);
    }

    /* ========= Switches Ultra Discretos ========= */
    .switch {
      position: relative;
      width: 44px;
      height: 24px;
      border-radius: 999px;
      cursor: pointer;
      
      /* Fundo neutro discreto */
      background: color-mix(in oklab, var(--panel), var(--stroke) 20%);
      border: 1px solid color-mix(in oklab, var(--stroke), transparent 40%);
      
      /* Sombra interna suave */
      box-shadow: 
        inset 0 1px 2px rgba(0,0,0,0.06),
        inset 0 -0.5px 0 rgba(255,255,255,0.04);
      
      transition: all 0.2s cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .switch[aria-checked="true"] {
      /* Estado ativo em tom neutro discreto */
      background: color-mix(in oklab, var(--panel), var(--stroke) 45%);
      border-color: color-mix(in oklab, var(--stroke), white 10%);
      box-shadow: 
        inset 0 1px 2px rgba(0,0,0,0.08),
        inset 0 -0.5px 0 rgba(255,255,255,0.06);
    }
    
    .switch .knob {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      
      /* Knob neutro e limpo */
      background: 
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.3), transparent 70%),
        color-mix(in oklab, var(--panel), white 90%);
      
      /* Borda neutra */
      border: 0.5px solid color-mix(in oklab, var(--stroke), transparent 70%);
      
      /* Sombra discreta */
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.4),
        0 1px 2px rgba(0,0,0,0.1),
        0 0 0 0.5px rgba(0,0,0,0.03);
      
      transition: 
        transform 0.2s cubic-bezier(0.2, 0.7, 0.2, 1),
        box-shadow 0.15s ease;
    }
    
    .switch[aria-checked="true"] .knob {
      transform: translateX(20px);
      background: 
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.35), transparent 70%),
        color-mix(in oklab, var(--panel), white 85%);
      border-color: color-mix(in oklab, var(--stroke), transparent 60%);
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.3),
        0 1px 3px rgba(0,0,0,0.12),
        0 0 0 0.5px rgba(0,0,0,0.04);
    }
    
    /* Hover discreto nos switches */
    .switch:hover .knob {
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.5),
        0 1px 4px rgba(0,0,0,0.15),
        0 0 0 1px rgba(0,0,0,0.05);
    }

    /* ========= Scroll Perfeitamente Integrado ========= */
    .sheet-content {
      padding: 16px 18px 14px;
      overflow: auto;
      
      /* Scroll customizado */
      scrollbar-width: thin;
      scrollbar-color: color-mix(in oklab, var(--stroke), transparent 70%) transparent;
    }
    
    .sheet-content::-webkit-scrollbar {
      width: 6px;
    }
    
    .sheet-content::-webkit-scrollbar-track {
      background: transparent;
      border-radius: 8px;
      margin: 4px 0;
    }
    
    .sheet-content::-webkit-scrollbar-thumb {
      background: color-mix(in oklab, var(--stroke), transparent 80%);
      border-radius: 8px;
      border: 1px solid transparent;
      background-clip: content-box;
      
      /* Sombra interna discreta */
      box-shadow: inset 0 0 2px rgba(0,0,0,0.1);
      
      transition: all 0.2s ease;
    }
    
    .sheet-content::-webkit-scrollbar-thumb:hover {
      background: color-mix(in oklab, var(--stroke), transparent 60%);
      box-shadow: inset 0 0 3px rgba(0,0,0,0.15);
    }
    
    .sheet-content::-webkit-scrollbar-thumb:active {
      background: color-mix(in oklab, var(--stroke), transparent 50%);
    }

    /* Lista como listbox acessível */
    #notesList{
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    /* Cartão de nota */
    .note-row{
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 35%, transparent);
      cursor: pointer;
      transition: all 200ms ease;
    }

    .note-row[aria-selected="true"]{
      background: linear-gradient(180deg,
        color-mix(in srgb, var(--c-action) 14%, transparent),
        color-mix(in srgb, var(--c-glass) 10%, transparent));
      border-color: color-mix(in srgb, var(--c-action) 30%, transparent);
    }

    .note-row:hover{
      background: color-mix(in srgb, var(--c-glass) 18%, transparent);
      border-color: color-mix(in srgb, var(--c-light) 18%, transparent);
    }

    .note-title{
      font-weight: 600;
      margin: 0;
      color: var(--c-content);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .note-meta{
      font-size: 11px; color: var(--text-muted);
      margin-top: 4px;
    }

    /* Ações alinhadas e discretas */
    .note-actions{
      display: flex; gap: 6px;
    }
    .note-actions .tbtn{ height: 28px; }

    .shortcuts-grid {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 8px 16px;
      align-items: center;
    }
    .shortcuts-grid code {
      background: var(--panel-strong);
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid var(--stroke);
      font-size: 12px;
    }

    @media print {
      @page {
        margin: 1in;
      }
      body {
        background: #fff !important;
        color: #000 !important;
        font-size: 12pt;
        line-height: 1.4;
        font-family: 'Times New Roman', serif;
      }
      .layout, .editor-shell, .editor-wrap, #editor {
        display: block !important;
        height: auto !important;
        overflow: visible !important;
      }
      header, footer, .gutter, .minimap, .progress, #findBar, #dropzone, dialog {
        display: none !important;
      }
      #editor {
        color: #000 !important;
        background: transparent !important;
        padding: 0 !important;
        white-space: pre-wrap !important; /* Ensure content wraps for printing */
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }
    }

    @media (max-width: 760px){ .notes-list{grid-template-columns: 1fr auto} .note-meta{display:none} }
    @media (max-width: 640px){ .btn .label{display:none} .font-controls{display:none} }
    @media (max-width: 520px){ .brand{display:none} }
    @media (max-width: 480px){ header.toolbar{gap:4px;padding:0 6px} .btn{height:26px;padding:0 6px} .btn-icon{padding:0 4px} }

    /* ========= Liquid Glass tokens extras ========= */
    :root{
      --lg-glass-bg: color-mix(in oklab, var(--bg), white 6%);
      --lg-card-bg: color-mix(in oklab, var(--bg), white 8%);
      --lg-border: var(--stroke);
      --lg-radius: 16px;
      --lg-radius-lg: 20px;
      --focus-ring: 0 0 0 2px color-mix(in oklab, var(--accent), transparent 70%);
    }

    /* Alto contraste opcional (Acessibilidade) */
    html.contrast-plus {
      --panel: rgba(255,255,255,.14);
      --panel-strong: rgba(255,255,255,.20);
      --stroke: rgba(255,255,255,.28);
      --text: #fff;
      --text-dim: #f3f3f3;
      --text-muted: #e6e6e6;
    }

    /* ========= Modal base (sheet) ========= */
    .dialog-sheet {
      width: min(96vw, 880px);
      padding: 0;
      border: 1px solid var(--lg-border);
      border-radius: var(--lg-radius-lg);
      background: var(--lg-glass-bg);
      backdrop-filter: blur(var(--lg-blur)) saturate(var(--lg-sat)) contrast(var(--lg-contrast));
      -webkit-backdrop-filter: blur(var(--lg-blur)) saturate(var(--lg-sat)) contrast(var(--lg-contrast));
      box-shadow:
        inset 0 0 0 1px color-mix(in oklab, var(--lg-highlight), transparent 70%),
        0 24px 60px rgba(0,0,0,.35);
    }
    dialog::backdrop{ background: rgba(0,0,0,.45) }

    /* Header do modal */
    .sheet-header{
      display:flex;align-items:center;gap:10px;
      padding:14px 16px;border-bottom:1px solid var(--stroke);
      background: color-mix(in oklab, var(--bg), white 6%);
      backdrop-filter: blur(16px) saturate(140%);
    }
    .sheet-header h3{ margin:0; font-weight:700; font-size:15px }
    .sheet-close{ margin-left:auto }

    /* Layout de conteúdo: sidebar + area */
    .sheet-body{ display:grid; grid-template-columns: 220px 1fr; min-height: 420px }
    .sheet-sidebar{
      border-right:1px solid var(--stroke);
      padding:10px; background: color-mix(in oklab, var(--bg), white 4%);
    }
    .sheet-sidebar .nav{
      display:flex; flex-direction:column; gap:4px;
    }
    .sheet-sidebar .nav button{
      text-align:left; padding:8px 10px; border-radius:10px;
      border:1px solid transparent; background:transparent; color:var(--text);
      cursor:pointer; font-size:12px;
    }
    .sheet-sidebar .nav button:hover{ background: var(--panel) }
    .sheet-sidebar .nav button[aria-current="true"]{
      background: color-mix(in oklab, var(--accent), transparent 88%);
      border-color: color-mix(in oklab, var(--accent), black 35%);
    }

    .sheet-content{ padding:16px 18px 14px; overflow:auto }
    .section{ display:grid; gap:12px; margin-bottom:18px }
    .section h4{ margin:4px 0 2px; font-size:13px }

    /* Cartões de grupo */
    .group{
      padding:12px; border:1px solid var(--stroke); border-radius:14px;
      background: var(--lg-card-bg);
    }

    /* Linha de controle (label à esquerda, controle à direita) */
    .row{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center }
    .hint{ color: var(--text-muted); font-size:11px }
    label .hint{ margin-left:8px; opacity:.8 }

    /* Segmented control (Liquid Glass), em cima do switcher que você enviou */
    .segmented{
      display:inline-flex; padding:4px; gap:4px; border-radius:999px;
      background: color-mix(in oklab, var(--c-glass) 14%, transparent);
      backdrop-filter: blur(10px) saturate(var(--lg-sat));
      border:1px solid var(--stroke);
    }
    .segmented input{ position:absolute; opacity:0; width:0; height:0 }
    .segmented label{
      position:relative; padding:6px 10px; border-radius:999px; font-size:12px;
      cursor:pointer; user-select:none; border:1px solid transparent;
    }
    .segmented label:hover{ background: var(--panel-strong) }
    .segmented input:checked + label{
      background: color-mix(in oklab, var(--accent), transparent 85%);
      border-color: color-mix(in oklab, var(--accent), black 30%);
      box-shadow: inset 0 1px 2px rgba(0,0,0,.15);
      color: var(--text);
    }

    /* Sliders já estão lindos; só foco visível */
    .range-control input[type="range"]:focus-visible{
      outline: none; box-shadow: var(--focus-ring);
    }

    /* Switch foco */
    .switch:focus-visible{ outline: none; box-shadow: var(--focus-ring) }

    /* ========= Help Center ========= */
    .help-hero{
      display:grid; gap:8px; padding:14px 16px; border-bottom:1px solid var(--stroke);
      background: color-mix(in oklab, var(--bg), white 5%);
    }
    .help-tabs{ display:flex; gap:6px }
    .help-tabs button{ padding:6px 10px; border-radius:10px; border:1px solid var(--stroke); background:var(--panel); font-size:12px }
    .help-tabs button[aria-current="true"]{
      background: color-mix(in oklab, var(--accent), transparent 85%);
      border-color: color-mix(in oklab, var(--accent), black 30%);
    }
    .help-body{ padding:14px 16px; max-height:60vh; overflow:auto }
    .cards{ display:grid; gap:12px; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); }
    .card{
      padding:12px; border:1px solid var(--stroke); border-radius:14px; background: var(--lg-card-bg);
    }
    .shortcut-row{ display:grid; grid-template-columns: 1fr auto; gap:6px; align-items:center; padding:6px 8px; border-bottom:1px dashed color-mix(in oklab, var(--stroke), white 20%) }
    .shortcut-row:last-child{ border-bottom:0 }
    kbd{ font-family: var(--code-font); font-size:11px; padding:.15em .45em; border:1px solid var(--stroke); border-radius:6px; background:var(--panel) }

    @media (max-width: 720px){
      .sheet-body{ grid-template-columns: 1fr } /* sidebar vira topo */
      .sheet-sidebar{ border-right:0; border-bottom:1px solid var(--stroke) }
    }
  </style>
  <!-- SVG filter noise for liquid-y feel (degrades gracefully) -->
  <svg width="0" height="0" style="position:absolute">
    <filter id="lg-wobble" x="-20%" y="-20%" width="140%" height="140%">
      <feTurbulence type="fractalNoise" baseFrequency=".75" numOctaves="2" seed="2" result="noise"/>
      <feDisplacementMap in="SourceGraphic" in2="noise" scale="1.2" xChannelSelector="R" yChannelSelector="G"/>
    </filter>
  </svg>
</head>
<body>
  <div class="layout">
    <div class="progress" id="progress"></div>
    
    <!-- Toolbar integrada como AppBar única -->
    <div class="header-toolbar">
      <div class="toolbar toolbar--attached" role="toolbar" aria-label="Ferramentas do editor">
        <!-- ESQUERDA: marca + título da nota -->
        <div class="tgroup" role="group" aria-label="Contexto">
          <span class="brand-dot" aria-hidden="true"></span>
          <button id="noteTitleChip" class="title-chip" title="Renomear (F2)" aria-label="Título da nota (duplo clique para renomear)">
            <svg class="ticon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 20h4l10-10a2.828 2.828 0 0 0-4-4L4 16v4z"></path><path d="M13.5 6.5l4 4"/></svg>
            <span id="noteTitleChipText">—</span>
          </button>
        </div>

        <!-- Grupo: Notas/Arquivo (sem Abrir/Salvar/Imprimir) -->
        <div class="tgroup" role="group" aria-label="Notas">
          <button class="tbtn" id="btnNotes" title="Notas (⌘O)">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M3 7h18"/><path d="M3 12h18"/><path d="M3 17h12"/></svg>
            <span>Notas</span>
          </button>
          <button class="tbtn" id="btnNew" title="Nova nota (⌘N)">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M5 12h14"/></svg>
            <span>Nova</span>
          </button>
        </div>

        <!-- Formatação -->
        <div class="tgroup" role="group" aria-label="Formatação">
          <button class="tbtn" id="btnToggleWrap" data-toggle aria-pressed="false" title="Quebra automática (Alt+Z)">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M3 7h10"/><path d="M21 7h-6"/><path d="M3 12h14"/><path d="M3 17h10"/><path d="m21 17-3 3-3-3"/></svg>
            <span>Quebra</span>
          </button>

          <button class="tbtn tbtn--icon" id="btnFontDown" title="Diminuir letra (Ctrl+-)" aria-label="Diminuir tamanho da letra">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M4 7V4h16v3M9 20h6M12 4v16"/>
              <path d="m8 14 2-2 2 2"/>
            </svg>
          </button>
          <span id="fontSizeDisplay" style="min-width:20px;padding:0 4px;font-size:10px;font-weight:600;color:var(--c-content);text-align:center;line-height:1.2;font-family:var(--code-font);user-select:none">10</span>
          <button class="tbtn tbtn--icon" id="btnFontUp" title="Aumentar letra (Ctrl++)" aria-label="Aumentar tamanho da letra">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M4 7V4h16v3M9 20h6M12 4v16"/>
              <path d="m8 10 2 2 2-2"/>
            </svg>
          </button>

          <button class="tbtn" id="btnToggleLines" data-toggle aria-pressed="false" title="Números de linha">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h13"/><path d="M8 12h13"/><path d="M8 18h13"/><path d="M3 6h2"/><path d="M3 12h2"/><path d="M3 18h2"/></svg>
            <span>Linhas</span>
          </button>
          <button class="tbtn" id="btnToggleMini" data-toggle aria-pressed="false" title="Minimap">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="5" width="10" height="14" rx="2"/><rect x="16" y="5" width="5" height="14" rx="2"/></svg>
            <span>Minimap</span>
          </button>
        </div>

        <div class="tspacer" aria-hidden="true"></div>

        <!-- Busca -->
        <div class="tgroup" role="group" aria-label="Busca">
          <label class="tsearch">
            <input class="tsearch__input" id="globalSearch" type="search" placeholder="Buscar…" title="Buscar no documento (⌘F)" aria-controls="findBar" aria-expanded="false"/>
            <svg class="tsearch__icon" viewBox="0 0 24 24" aria-hidden="true">
              <circle cx="11" cy="11" r="6" stroke="currentColor" stroke-width="2" fill="none"/>
              <path d="m17 17 4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </label>
        </div>

        <!-- Mais -->
        <div class="tgroup" role="group" aria-label="Mais">
          <button class="tbtn tbtn--icon" id="btnSettings" title="Ajustes (⌘,)" aria-haspopup="dialog" aria-controls="settings">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V22a2 2 0 1 1-4 0v-.09A1.65 1.65 0 0 0 9 20.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.6 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06A2 2 0 1 1 7.04 4.3l.06.06A1.65 1.65 0 0 0 8.92 4a1.65 1.65 0 0 0 1-1.51V2a2 2 0 1 1 4 0v.09A1.65 1.65 0 0 0 15 3.6c.41.17.75.43 1.02.77l.06.06a2 2 0 1 1 2.83 2.83l-.06.06c-.34.27-.6.61-.77 1.02.29.69.45 1.44.45 2.22s-.16 1.53-.45 2.22Z"/></svg>
          </button>
          <button class="tbtn tbtn--icon" id="btnHelp" title="Ajuda (⌘/)" aria-haspopup="dialog" aria-controls="help">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>
          </button>
          <button class="tbtn tbtn--icon" aria-label="Mais" aria-haspopup="menu" aria-expanded="false" data-popover="#more-menu">
            <svg class="ticon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="5" cy="12" r="1.5" fill="currentColor"/><circle cx="12" cy="12" r="1.5" fill="currentColor"/><circle cx="19" cy="12" r="1.5" fill="currentColor"/></svg>
          </button>

          <!-- MORE MENU expandido -->
          <div id="more-menu" class="popover" role="menu" hidden>
            <div class="menu-section" aria-label="Arquivo">Arquivo</div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmOpen">Abrir…</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmSave">Salvar como .md</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="btnImportFromPopover">Importar…</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="btnExportFromPopover">Exportar…</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmPrint">Imprimir (⌘P)</button></div>

            <div class="menu-divider" role="separator"></div>

            <div class="menu-section" aria-label="Notas">Notas</div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmRename">Renomear</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmDuplicate">Duplicar</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmExportAll">Exportar Tudo</button></div>

            <div class="menu-divider" role="separator"></div>

            <div class="menu-section" aria-label="Exibir">Exibir</div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitemcheckbox" aria-checked="false" id="mmToggleWrap">Quebra automática</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitemcheckbox" aria-checked="false" id="mmToggleLines">Números de linha</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitemcheckbox" aria-checked="false" id="mmToggleMini">Minimap</button></div>

            <div class="menu-divider" role="separator"></div>

            <div class="menu-section" aria-label="Ajuda">Ajuda</div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmSettings">Ajustes</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmShortcuts">Atalhos</button></div>
          </div>
        </div>
      </div>
    </div>

    <main class="editor-shell" id="shell" style="grid-row: 2; overflow: hidden; min-height: 0;">
      <aside class="gutter" id="gutter" aria-hidden="true"></aside>
      <section class="editor-wrap">
        <div id="highlights" class="highlights-overlay" aria-hidden="true"></div>
        <textarea id="editor" wrap="off" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false" aria-label="Área de edição"></textarea>
        
        <div id="findBar" class="toolbar" role="toolbar" aria-label="Buscar e Substituir" hidden>
          <!-- Linha principal: busca + navegação + contador + fechar -->
          <div class="find-primary-row">
            <input class="find-input" id="findInput" placeholder="Buscar…" autocomplete="off" spellcheck="false"/>
            
            <button class="tbtn tbtn--icon" id="btnFindPrev" title="Anterior (Shift+Enter)" aria-label="Resultado anterior">
              <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
            </button>
            
            <button class="tbtn tbtn--icon" id="btnFindNext" title="Próximo (Enter)" aria-label="Próximo resultado">
              <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
            </button>
            
            <span class="find-count-display" id="findCount" aria-live="polite">0/0</span>
            
            <button class="tbtn tbtn--icon" id="btnFindClose" title="Fechar (Esc)" aria-label="Fechar busca">
              <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
            </button>
          </div>
          
          <!-- Linha de substituir (inicialmente oculta) -->
          <div class="find-replace-row" id="replaceRow" hidden>
            <input class="find-input" id="replaceInput" placeholder="Substituir por…" autocomplete="off" spellcheck="false"/>
            
            <button class="tbtn" id="btnDoReplace" title="Substituir atual (Enter)">
              <span>Substituir</span>
            </button>
            
            <button class="tbtn" id="btnDoReplaceAll" title="Substituir todos (Ctrl+Enter)">
              <span>Todos</span>
            </button>
          </div>
          
          <!-- Linha de opções -->
          <div class="find-options-row">
            <button id="optCase" class="find-option-toggle" type="button" title="Diferenciar maiúsculas e minúsculas" aria-pressed="false">
              <span>Aa</span>
            </button>
            
            <button id="optRegex" class="find-option-toggle" type="button" title="Expressão Regular (RegEx)" aria-pressed="false">
              <span>.*</span>
            </button>
            
            <button id="optMultiline" class="find-option-toggle" type="button" title="Busca Multilinha" aria-pressed="false">
              <span>^$</span>
            </button>
            
            <button class="tbtn" id="btnToggleReplace" title="Alternar modo substituir" aria-pressed="false">
              <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12h18m-9-9l9 9-9 9"/></svg>
              <span>Substituir</span>
            </button>
          </div>
        </div>
        
        <div id="goToLine" class="toolbar" role="toolbar" aria-label="Ir para Linha" hidden>
            <div class="find-primary-row">
                <input class="find-input" id="goToLineInput" type="number" placeholder="Ir para linha..." min="1" autocomplete="off"/>
                
                <button class="tbtn tbtn--icon" id="btnGoToLineExecute" title="Ir (Enter)" aria-label="Ir para linha">
                    <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
                </button>
                
                <button class="tbtn tbtn--icon" id="btnGoToLineClose" title="Fechar (Esc)" aria-label="Fechar ir para linha">
                    <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                </button>
            </div>
        </div>

      </section>
      <aside class="minimap" id="minimap" aria-hidden="true" hidden tabindex="0" title="Navegação do Minimap: Setas, PageUp/Down, Home/End. Enter para voltar ao editor.">
        <pre id="miniText"></pre>
        <div class="mini-viewport" id="miniViewport" style="top:0;height:40px"></div>
      </aside>
    </main>

    <div id="dropzone" class="dropzone-overlay" hidden>
      <div class="dropzone-content glass-panel">
        <div class="dropzone-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" x2="12" y1="3" y2="15"/>
          </svg>
        </div>
        <h2 class="dropzone-title">Solte o arquivo aqui</h2>
        <p class="dropzone-subtitle">Suporte para arquivos .txt e .md</p>
      </div>
    </div>

    <footer class="status lg-surface">
      <span class="pill"><strong id="lncol">Ln 1, Col 1</strong></span>
      <span class="sep"></span>
      <span id="wordCount">0 palavras</span>
      <span class="sep" id="selectionSep" hidden></span>
      <span id="selectionStats" hidden></span>
      <span class="sep"></span>
      <span id="wrapState">Sem quebra</span>
      <span class="sep"></span>
      <span id="noteTitle">—</span>
      <div class="spacer"></div>
      <span id="saveStatus" aria-live="polite"></span>
    </footer>
  </div>

  <input type="file" id="file" accept=".txt,.md,.markdown,.rtf,.html,.htm" hidden />

  <!-- ========== Ajustes (novo) ========== -->
  <dialog id="settings" class="dialog-sheet glass-panel large" aria-modal="true" aria-labelledby="settingsTitle">
    <div class="glass-panel-header">
      <h3 id="settingsTitle">Ajustes</h3>
      <button class="tbtn sheet-close" value="cancel" title="Fechar">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>

    <div class="glass-panel-content" id="settingsBody">
      <aside class="sheet-sidebar">
        <nav class="nav" aria-label="Seções de ajustes">
          <button type="button" data-sec="appearance" aria-current="true">Aparência</button>
          <button type="button" data-sec="editor">Editor</button>
          <button type="button" data-sec="interface">Interface</button>
          <button type="button" data-sec="accessibility">Acessibilidade</button>
          <button type="button" data-sec="files">Notas & Arquivos</button>
          <button type="button" data-sec="advanced">Avançado</button>
          <button type="button" data-sec="about">Sobre</button>
        </nav>
      </aside>

      <section class="sheet-content">
        <!-- Aparência -->
        <div class="section" data-section="appearance">
          <h4>Tema</h4>
          <div class="group">
            <div class="row">
              <div>
                <div class="hint">Aparência do sistema</div>
              </div>
              <div class="segmented" role="radiogroup" aria-label="Tema">
                <input id="theme-auto" type="radio" name="theme" value="auto" checked>
                <label for="theme-auto">Auto</label>
                <input id="theme-light" type="radio" name="theme" value="light">
                <label for="theme-light">Claro</label>
                <input id="theme-dark" type="radio" name="theme" value="dark">
                <label for="theme-dark">Escuro</label>
              </div>
            </div>
          </div>

          <h4>Liquid Glass</h4>
          <div class="group" role="group" aria-label="Intensidade do vidro">
            <div class="row">
              <label for="glassBlur">Desfoque</label>
              <div class="slider-with-output-container" id="glassBlurWrap">
                <output class="glass-ui slider-output" for="glassBlur" id="glassBlurValue">18px</output>
                <input id="glassBlur" class="glass-slider" type="range" min="8" max="28" step="1">
              </div>
            </div>
            <div class="row">
              <label for="glassSat">Saturação</label>
              <div class="slider-with-output-container" id="glassSatWrap">
                <output class="glass-ui slider-output" for="glassSat" id="glassSatValue">135%</output>
                <input id="glassSat" class="glass-slider" type="range" min="100" max="170" step="5">
              </div>
            </div>
            <div class="row">
              <label for="glassContrast">Contraste</label>
              <div class="slider-with-output-container" id="glassContrastWrap">
                <output class="glass-ui slider-output" for="glassContrast" id="glassContrastValue">1.05</output>
                <input id="glassContrast" class="glass-slider" type="range" min="1.00" max="1.10" step="0.01">
              </div>
            </div>
            <div class="hint">Mantemos limites seguros para legibilidade conforme HIG (evite vidro "leitoso" demais).</div>
          </div>
        </div>

        <!-- Editor -->
        <div class="section" data-section="editor" hidden>
          <h4>Tipografia</h4>
          <div class="group">
            <div class="row">
              <label for="fontSize">
                Tamanho da letra
                <span id="fontSizeHint" class="hint" aria-live="polite"></span>
              </label>
              <div class="slider-with-output-container" id="fontSizeWrap">
                <output class="glass-ui slider-output" for="fontSize" id="fontSizeValueDisplay">16px</output>
                <input id="fontSize" class="glass-slider" type="range" min="8" max="24" step="1" />
              </div>
            </div>
            <div class="row">
              <label for="lineHeight">
                Altura da linha
                <span id="lineHeightHint" class="hint" aria-live="polite"></span>
              </label>
              <div class="slider-with-output-container" id="lineHeightWrap">
                <output class="glass-ui slider-output" for="lineHeight" id="lineHeightValueDisplay">1.60</output>
                <input id="lineHeight" class="glass-slider" type="range" min="1.30" max="1.90" step="0.05" />
              </div>
            </div>
            <div class="row">
              <label for="padX">
                Espaçamento interno
                <span id="padXHint" class="hint" aria-live="polite"></span>
              </label>
              <div class="slider-with-output-container" id="padXWrap">
                <output class="glass-ui slider-output" for="padX" id="padXValueDisplay">24px</output>
                <input id="padX" class="glass-slider" type="range" min="8" max="40" step="1" />
              </div>
            </div>
            <div class="hint">Dica: 10–12px no editor com 1.5–1.6 de linha costuma ser o "ponto doce".</div>
          </div>

          <h4>Visual do Editor</h4>
          <div class="group">
            <div class="row"><label>Quebra automática</label><div class="switch" id="switchWrap" role="switch" aria-checked="false" tabindex="0"><div class="knob"></div></div></div>
            <div class="row"><label>Números de linha</label><div class="switch" id="switchLines" role="switch" aria-checked="false" tabindex="0"><div class="knob"></div></div></div>
            <div class="row"><label>Minimap</label><div class="switch" id="switchMini" role="switch" aria-checked="false" tabindex="0"><div class="knob"></div></div></div>
            <div class="hint">Sem quebra = experiência de editor de código.</div>
          </div>
        </div>

        <!-- Interface -->
        <div class="section" data-section="interface" hidden>
          <h4>Animações & Densidade</h4>
          <div class="group">
            <div class="row"><label>Reduzir animações</label><div class="switch" id="switchMotion" role="switch" aria-checked="false" tabindex="0"><div class="knob"></div></div></div>
            <div class="row">
              <label>Densidade</label>
              <div class="segmented" role="radiogroup" aria-label="Densidade" id="densitySeg">
                <input id="dense-comf" type="radio" name="density" value="comfortable" checked>
                <label for="dense-comf">Confortável</label>
                <input id="dense-comp" type="radio" name="density" value="compact">
                <label for="dense-comp">Compacta</label>
              </div>
            </div>
          </div>
        </div>

        <!-- Acessibilidade -->
        <div class="section" data-section="accessibility" hidden>
          <h4>Contraste & Foco</h4>
          <div class="group">
            <div class="row"><label>Aumentar contraste</label><div class="switch" id="switchContrast" role="switch" aria-checked="false" tabindex="0"><div class="knob"></div></div></div>
            <div class="hint">Melhora legibilidade de textos/controles; segue boas práticas de contraste (WCAG/APCA). </div>
          </div>
        </div>

        <!-- Notas & Arquivos -->
        <div class="section" data-section="files" hidden>
          <h4>Gerenciar</h4>
          <div class="group">
            <div class="row">
              <div>
                <div class="hint">Backup de notas</div>
              </div>
              <div style="display:flex; gap:8px">
                <button class="btn" id="btnExportFromSettings">Exportar Tudo</button>
                <button class="btn" id="btnImportFromSettings">Importar</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Avançado -->
        <div class="section" data-section="advanced" hidden>
          <h4>Configurações</h4>
          <div class="group" style="display:flex; gap:8px; justify-content:flex-end">
            <button class="btn" id="btnExportSettings">Exportar Config</button>
            <button class="btn" id="btnResetSettings">Restaurar Padrões</button>
          </div>
        </div>

        <!-- Sobre -->
        <div class="section" data-section="about" hidden>
          <h4>Sobre este app</h4>
          <div class="group">
            <div class="hint">Canvas de Texto — Editor v3. Design baseado no material translúcido do sistema (Materials/Vibrancy). </div>
          </div>
        </div>
      </section>
    </div>
  </dialog>

  <!-- ========== Centro de Ajuda (novo) ========== -->
  <dialog id="help" class="dialog-sheet glass-panel large" aria-modal="true" aria-labelledby="helpTitle">
    <div class="glass-panel-header">
      <h3 id="helpTitle">Ajuda</h3>
      <div class="help-tabs" role="tablist" aria-label="Seções de ajuda">
        <button type="button" role="tab" data-tab="overview" aria-current="true">Visão geral</button>
        <button type="button" role="tab" data-tab="shortcuts">Atalhos</button>
        <button type="button" role="tab" data-tab="tips">Dicas</button>
        <button type="button" role="tab" data-tab="about">Sobre</button>
      </div>
      <button class="tbtn sheet-close" value="cancel" title="Fechar">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>

    <div class="glass-panel-content" id="helpBody">
      <!-- Overview -->
      <div data-tabpanel="overview">
        <div class="cards">
          <div class="card"><strong>1) Crie/abra</strong><br>Use <kbd>⌘N</kbd> para nova nota ou <kbd>⌘O</kbd> para abrir o gerenciador.</div>
          <div class="card"><strong>2) Escreva</strong><br>Editor rápido com números de linha, minimap e busca/substituir (<kbd>⌘F</kbd>/<kbd>⌘H</kbd>).</div>
          <div class="card"><strong>3) Formate</strong><br>Ajuste fonte/linha no <em>Ajustes</em> (<kbd>⌘,</kbd>). </div>
          <div class="card"><strong>4) Compartilhe</strong><br>Salve como <kbd>.md</kbd> ou imprima (<kbd>⌘P</kbd>).</div>
        </div>
      </div>

      <!-- Shortcuts -->
      <div data-tabpanel="shortcuts" hidden>
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px">
          <input id="helpSearch" placeholder="Buscar atalho…" style="flex:1;height:28px;border:1px solid var(--stroke);border-radius:8px;background:var(--panel);color:var(--text);padding:0 10px;font-size:12px;outline:none">
          <button class="btn" id="btnCopyShortcuts">Copiar</button>
        </div>
        <div id="shortcutList"></div>
      </div>

      <!-- Tips -->
      <div data-tabpanel="tips" hidden>
        <div class="cards">
          <div class="card"><strong>Find avançado</strong><br>Ative <kbd>.*</kbd> para RegEx e <kbd>^$</kbd> para multilinha.</div>
          <div class="card"><strong>Mover/duplicar</strong><br><kbd>Alt</kbd>+<kbd>↑/↓</kbd> move; <kbd>⌘D</kbd> duplica seleção/linha.</div>
          <div class="card"><strong>Minimap</strong><br>Arraste a lente para navegar por textos grandes.</div>
        </div>
      </div>

      <!-- About -->
      <div data-tabpanel="about" hidden>
        <p class="hint">Ajuda concisa e acionável (HIG: "Offering help"). Feche com <kbd>Esc</kbd> ou clique em "Fechar".</p>
      </div>
    </div>
  </dialog>

  <!-- ========== Gerenciador de notas ========== -->
  <dialog id="notes" class="dialog-sheet glass-panel large" aria-modal="true" aria-labelledby="notesTitle">
    <div class="glass-panel-header">
      <h3 id="notesTitle">Notas</h3>
      <input type="text" id="noteFilter" placeholder="Filtrar notas…" style="margin-left: 16px; font-size: 12px; height: 28px; flex: 1; max-width: 200px; border: 1px solid var(--stroke); border-radius: 8px; background: var(--panel); color: var(--text); padding: 0 10px; outline: none;">
      <div style="display: flex; gap: 8px;">
        <button class="tbtn" id="btnImport" title="Importar backup (.json)">Importar</button>
        <button class="tbtn" id="btnExport" title="Exportar tudo (.json)">Exportar Tudo</button>
        <button class="tbtn" id="btnDup" title="Duplicar como nova">Duplicar</button>
        <button class="tbtn" id="btnDelAll" title="Apagar todas">Apagar todas</button>
      </div>
      <button class="tbtn sheet-close" value="cancel" title="Fechar">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>

    <div class="glass-panel-content">
      <div class="notes-list" id="notesList" role="list"></div>
    </div>
    
    <div class="glass-panel-footer">
      <button class="tbtn" id="btnNewInside">Nova nota</button>
    </div>
  </dialog>

  <input type="file" id="importFile" accept=".json" hidden />

  <script>
    // ===== Toolbar scrolled state =====
    (function(){
      const hdr = document.querySelector('.header-toolbar');
      const main = document.querySelector('main');
      if (!hdr || !main) return;
      const onScroll = () => {
        const y = main.scrollTop || document.documentElement.scrollTop || window.scrollY;
        hdr.classList.toggle('is-scrolled', y > 2);
      };
      main?.addEventListener('scroll', onScroll, {passive:true});
      window.addEventListener('scroll', onScroll, {passive:true});
      onScroll();
    })();

    // ====== Elements ======
    const shell = document.getElementById('shell');
    const editor = document.getElementById('editor');
    const gutter = document.getElementById('gutter');
    const minimap = document.getElementById('minimap');
    const miniText = document.getElementById('miniText');
    const miniViewport = document.getElementById('miniViewport');
    const highlights = document.getElementById('highlights');

    const progress = document.getElementById('progress');
    const lnCol = document.getElementById('lncol');
    const wordCountEl = document.getElementById('wordCount');
    const selectionSep = document.getElementById('selectionSep');
    const selectionStats = document.getElementById('selectionStats');
    const wrapStateEl = document.getElementById('wrapState');
    const noteTitleEl = document.getElementById('noteTitle');
    const saveStatus = document.getElementById('saveStatus');

    const btnNotes = document.getElementById('btnNotes');
    const btnNew = document.getElementById('btnNew');
    const btnOpen = document.getElementById('btnOpen');
    const btnSaveFile = document.getElementById('btnSaveFile');
    const btnPrint = document.getElementById('btnPrint');
    const btnToggleWrap = document.getElementById('btnToggleWrap');
    const btnToggleLines = document.getElementById('btnToggleLines');
    const btnToggleMini = document.getElementById('btnToggleMini');

    // Elementos do chip de título
    const noteTitleChip = document.getElementById('noteTitleChip');
    const noteTitleChipText = document.getElementById('noteTitleChipText');

    // ---------- Popover Controller (btn "Mais" e afins) ----------
    const popoverButtons = document.querySelectorAll('[data-popover]');
    let openPopover = null;

    function positionPopover(pop, anchorBtn) {
      // usa posição fixa ancorada ao botão, evitando overflow
      pop.style.position = 'fixed';
      const r = anchorBtn.getBoundingClientRect();
      const margin = 8;
      // mede rapidamente (mostra para medir, depois recoloca)
      pop.removeAttribute('hidden');
      const w = pop.offsetWidth;
      const h = pop.offsetHeight;
      const left = Math.min(window.innerWidth - w - margin, Math.max(margin, r.right - w));
      const top  = Math.min(window.innerHeight - h - margin, r.bottom + margin);
      pop.style.left = `${left}px`;
      pop.style.top  = `${top}px`;
    }

    function closeOpenPopover(returnFocus = false) {
      if (!openPopover) return;
      openPopover.setAttribute('hidden','');
      openPopover.opener?.setAttribute('aria-expanded','false');
      if (returnFocus) openPopover.opener?.focus();
      openPopover = null;
    }

    function togglePopover(btn) {
      const sel = btn.getAttribute('data-popover');
      const pop = document.querySelector(sel);
      if (!pop) return;

      const willOpen = pop.hasAttribute('hidden');
      // fecha outro aberto
      if (openPopover && openPopover !== pop) closeOpenPopover(false);

      if (willOpen) {
        btn.setAttribute('aria-expanded','true');
        pop.opener = btn;
        positionPopover(pop, btn);
        openPopover = pop;
        // foco no primeiro item
        const first = pop.querySelector('[role="menuitem"], button, a, [tabindex]');
        first?.focus();
      } else {
        closeOpenPopover(true);
      }
    }

    popoverButtons.forEach(btn => {
      btn.addEventListener('click', e => {
        e.stopPropagation();
        togglePopover(btn);
      });
      btn.addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowDown') {
          e.preventDefault();
          togglePopover(btn);
        }
      });
    });

    document.addEventListener('click', (e) => {
      if (openPopover && !openPopover.contains(e.target)) {
        closeOpenPopover(false);
      }
    });

    document.addEventListener('keydown', (e) => {
      if (!openPopover) return;
      if (e.key === 'Escape') {
        e.preventDefault();
        closeOpenPopover(true);
      } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        e.preventDefault();
        const items = Array.from(openPopover.querySelectorAll('[role="menuitem"], button, a, [tabindex]'))
          .filter(el => !el.hasAttribute('disabled'));
        if (!items.length) return;
        let i = items.indexOf(document.activeElement);
        if (i < 0) i = 0;
        i = e.key === 'ArrowDown' ? (i + 1) % items.length : (i - 1 + items.length) % items.length;
        items[i].focus();
      }
    });

    // liga os itens do menu "Mais" às ações existentes
    document.getElementById('btnImportFromPopover')?.addEventListener('click', () => {
      closeOpenPopover(false);
      document.getElementById('importFile')?.click();
    });
    document.getElementById('btnExportFromPopover')?.addEventListener('click', () => {
      closeOpenPopover(false);
      // usa sua função existente
      if (typeof exportAllNotes === 'function') exportAllNotes();
    });

    // Arquivo
    document.getElementById('mmOpen')?.addEventListener('click', () => {
      closeOpenPopover(false);
      fileInput.click();
    });
    document.getElementById('mmSave')?.addEventListener('click', () => {
      closeOpenPopover(false);
      // reaproveita lógica do salvar
      btnSaveFile?.click();
    });
    document.getElementById('mmPrint')?.addEventListener('click', () => {
      closeOpenPopover(false);
      window.print();
    });

    // Notas
    document.getElementById('mmRename')?.addEventListener('click', () => {
      closeOpenPopover(false);
      startTitleEditOn(noteTitleChip || noteTitleEl);
    });
    document.getElementById('mmDuplicate')?.addEventListener('click', () => {
      closeOpenPopover(false);
      const id = createNote(editor.value);
      openNote(id);
    });
    document.getElementById('mmExportAll')?.addEventListener('click', () => {
      closeOpenPopover(false);
      exportAllNotes();
    });

    // Exibir (checkboxes sincronizados)
    const mmWrap  = document.getElementById('mmToggleWrap');
    const mmLines = document.getElementById('mmToggleLines');
    const mmMini  = document.getElementById('mmToggleMini');

    function syncMenuChecks(){
      if (mmWrap)  mmWrap.setAttribute('aria-checked', String(wrapOn));
      if (mmLines) mmLines.setAttribute('aria-checked', String(linesVisible));
      if (mmMini)  mmMini.setAttribute('aria-checked', String(miniVisible));
    }
    mmWrap?.addEventListener('click',  () => { setWrap(!wrapOn);  syncMenuChecks(); closeOpenPopover(false); });
    mmLines?.addEventListener('click', () => { setLineNumbers(!linesVisible); syncMenuChecks(); closeOpenPopover(false); });
    mmMini?.addEventListener('click',  () => { setMinimap(!miniVisible); syncMenuChecks(); closeOpenPopover(false); });

    // Ajuda
    document.getElementById('mmSettings')?.addEventListener('click', () => { closeOpenPopover(false); dlgSettings.showModal(); focusTrap(dlgSettings); });
    document.getElementById('mmShortcuts')?.addEventListener('click', () => {
      closeOpenPopover(false);
      dlgHelp.showModal();
      focusTrap(dlgHelp);
      // selecionar aba "Atalhos"
      document.querySelector('#help .help-tabs [data-tab="shortcuts"]')?.click();
    });

    // garantir sync sempre que os toggles mudarem
    const _origReflect = reflectToggles;
    reflectToggles = function(){
      _origReflect.call(this);
      syncMenuChecks();
    };
    const btnSettings = document.getElementById('btnSettings');
    const btnHelp = document.getElementById('btnHelp');
    
    // Font controls
    const btnFontDown = document.getElementById('btnFontDown');
    const btnFontUp = document.getElementById('btnFontUp');
    const fontSizeDisplay = document.getElementById('fontSizeDisplay');

    const dlgSettings = document.getElementById('settings');
    const switchWrap = document.getElementById('switchWrap');
    const switchLines = document.getElementById('switchLines');
    const switchMini = document.getElementById('switchMini');
    const fontSize = document.getElementById('fontSize');
    const lineHeight = document.getElementById('lineHeight');
    const padX = document.getElementById('padX');
    const fontSizeHint = document.getElementById('fontSizeHint');
    const lineHeightHint = document.getElementById('lineHeightHint');
    const padXHint = document.getElementById('padXHint');

    const dlgNotes = document.getElementById('notes');
    const notesList = document.getElementById('notesList');
    const btnDup = document.getElementById('btnDup');
    const btnDelAll = document.getElementById('btnDelAll');
    const btnNewInside = document.getElementById('btnNewInside');
    const noteFilter = document.getElementById('noteFilter');
    const dropzone = document.getElementById('dropzone');
    const btnImport = document.getElementById('btnImport');
    const btnExport = document.getElementById('btnExport');
    const importFile = document.getElementById('importFile');

    const fileInput = document.getElementById('file');

    // Find & Replace elements - updated for new structure
    const findBar = document.getElementById('findBar');
    const findInput = document.getElementById('findInput');
    const replaceInput = document.getElementById('replaceInput');
    const replaceRow = document.getElementById('replaceRow');
    const btnFindClose = document.getElementById('btnFindClose');
    const btnFindNext = document.getElementById('btnFindNext');
    const btnFindPrev = document.getElementById('btnFindPrev');
    const btnDoReplace = document.getElementById('btnDoReplace');
    const btnDoReplaceAll = document.getElementById('btnDoReplaceAll');
    const btnToggleReplace = document.getElementById('btnToggleReplace');
    const optCase = document.getElementById('optCase');
    const optRegex = document.getElementById('optRegex');
    const optMultiline = document.getElementById('optMultiline');
    const findCount = document.getElementById('findCount');

    // State tracking for options
    const findOptions = {
      case: false,
      regex: false,
      multiline: false
    };
    const goToLine = document.getElementById('goToLine');
    const goToLineInput = document.getElementById('goToLineInput');
    const btnGoToLineExecute = document.getElementById('btnGoToLineExecute');
    const btnGoToLineClose = document.getElementById('btnGoToLineClose');

    // ====== Storage Keys ======
    const INDEX_KEY = 'notes:index:v1';
    const CURRENT_KEY = 'notes:current:v1';
    const SETTINGS_KEY = 'editor:settings:v5'; // v5: novos campos glass/ui
    const NOTE_KEY = id => `note:${id}`;

    // ===== Utils =====
    const setVar = (k,v)=> document.documentElement.style.setProperty(k,v);
    function nowISO(){ return new Date().toISOString(); }
    function fmtDateTime(d){ const dt = typeof d === 'string' ? new Date(d) : d; const pad = n=> String(n).padStart(2,'0'); return `${dt.getFullYear()}-${pad(dt.getMonth()+1)}-${pad(dt.getDate())} ${pad(dt.getHours())}:${pad(dt.getMinutes())}`; }
    function genId(){ return Date.now().toString(36) + Math.random().toString(36).slice(2,6); }

    // ===== Glass & UI defaults =====
    const GLASS_DEFAULTS = { blur: 12, sat: 150, contrast: 1.04 };
    let uiReduceMotion = false;
    let uiDensity = 'comfortable';
    let uiHighContrast = false;

    function applyGlass({blur, sat, contrast}) {
      setVar('--lg-blur', `${blur}px`);
      setVar('--lg-sat', `${sat}%`);
      setVar('--lg-contrast', contrast);
    }

    function applyDensity(mode){
      // Compacta reduz padding global de botões e editor
      document.documentElement.dataset.density = mode;
      const pad = parseInt(padX.value || 16, 10);
      setVar('--editor-padding', (mode === 'compact' ? Math.max(6, pad - 4) : pad) + 'px');
    }

    function applyMotion(reduce){
      // Além do @media nativo, forçamos 0s quando ativado no app
      document.documentElement.style.setProperty('--dur', reduce ? '0s' : '.25s');
    }

    function applyContrast(high){
      document.documentElement.classList.toggle('contrast-plus', !!high);
    }

    function focusTrap(dialog){
      // foco inicial e retorno ao fechar
      const opener = document.activeElement;
      dialog.addEventListener('close', () => { if (opener && opener.focus) opener.focus(); }, { once:true });
      const first = dialog.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      if (first) first.focus();
    }

    function loadIndex(){ return JSON.parse(localStorage.getItem(INDEX_KEY) || '[]'); }
    function saveIndex(arr){ localStorage.setItem(INDEX_KEY, JSON.stringify(arr)); }
    function getCurrentId(){ return localStorage.getItem(CURRENT_KEY); }
    function setCurrentId(id){ localStorage.setItem(CURRENT_KEY, id); }
    function saveNote(id, text, meta){ 
      try {
        localStorage.setItem(NOTE_KEY(id), JSON.stringify({ text, ...meta })); 
      } catch (e) {
        if (e.name === 'QuotaExceededError') {
          alert('Armazenamento cheio! Exclua notas antigas ou exporte um backup para liberar espaço.');
        }
      }
    }
    function loadNote(id){ const j = localStorage.getItem(NOTE_KEY(id)); return j ? JSON.parse(j) : null; }
    function deleteNoteStorage(id){ localStorage.removeItem(NOTE_KEY(id)); }

    // ===== State =====
    let currentId = null;
    let debounceSave = null;
    const baseTitle = 'Canvas de Texto — Editor v3';
    let isDirty = false;
    let lastSaveTime = null;
    let lastRenderedLineCount = 0;
    let wrapOn = false; // single source of truth agora
    let linesVisible = false;
    let miniVisible = false;

    // ===== Interação de linhas =====
    const lineUX = {
      hoverLine: null,
      anchorLine: null,       // para Shift+click/arraste
      bookmarks: new Set(),   // guarda números de linha (1-based)
      dragging: false,
    };

    // Cria elementos de realce no overlay (uma vez)
    const hoverEl = document.createElement('div');
    hoverEl.className = 'line-hover';
    const selEl = document.createElement('div');
    selEl.className = 'line-selection';
    highlights.appendChild(hoverEl);
    highlights.appendChild(selEl);
    hoverEl.style.display = 'none';
    selEl.style.display = 'none';

    function timeAgo(date) {
      if (!date) return '';
      const seconds = Math.floor((new Date() - date) / 1000);
      if (seconds < 5) return "agora mesmo";
      
      let interval = seconds / 31536000;
      if (interval > 1) { const n = Math.floor(interval); return `há ${n} ano${n > 1 ? 's' : ''}`; }
      interval = seconds / 2592000;
      if (interval > 1) { const n = Math.floor(interval); return `há ${n} mês${n > 1 ? 'es' : ''}`; }
      interval = seconds / 86400;
      if (interval > 1) { const n = Math.floor(interval); return `há ${n} dia${n > 1 ? 's' : ''}`; }
      interval = seconds / 3600;
      if (interval > 1) { const n = Math.floor(interval); return `há ${n} hora${n > 1 ? 's' : ''}`; }
      interval = seconds / 60;
      if (interval > 1) { const n = Math.floor(interval); return `há ${n} min`; }
      
      return `há ${Math.floor(seconds)}s`;
    }

    function updateLastSavedTime() {
        if (lastSaveTime && !isDirty) {
            saveStatus.textContent = `Salvo ${timeAgo(lastSaveTime)}`;
        }
    }

    function updateDocTitle(){
      const idx = loadIndex();
      const meta = currentId ? idx.find(n=>n.id===currentId) : null;
      const t = (meta && meta.title) ? meta.title : baseTitle;
      document.title = (isDirty ? '• ' : '') + t;
    }

    // ===== Notes Ops =====
    function createNote(initialText=''){
      const id = genId();
      const createdAt = nowISO();
      const updatedAt = createdAt;
      const title = `Nota de ${fmtDateTime(createdAt)}`;
      const idx = loadIndex();
      idx.unshift({ id, title, createdAt, updatedAt });
      saveIndex(idx);
      saveNote(id, initialText, { createdAt, updatedAt });
      setCurrentId(id);
      return id;
    }
    function openNote(id){
      if(currentId){ doSave(); }
      const item = loadNote(id);
      if(!item){ alert('Nota não encontrada.'); return; }
      currentId = id; setCurrentId(id);
      editor.value = item.text || '';
      editor.scrollTop = 0; editor.scrollLeft = 0;
      
      // Carregar bookmarks se existirem
      lineUX.bookmarks.clear();
      if (item.bookmarks && Array.isArray(item.bookmarks)) {
        item.bookmarks.forEach(lineNum => lineUX.bookmarks.add(lineNum));
      }
      
      updateAllMeta();
      const idx = loadIndex();
      const meta = idx.find(n=>n.id===id);
      noteTitleEl.textContent = meta? meta.title : '—';
      if (noteTitleChipText) noteTitleChipText.textContent = meta ? meta.title : '—';
      isDirty = false; 
      lastSaveTime = meta ? new Date(meta.updatedAt) : new Date();
      updateDocTitle();
      updateLastSavedTime();
      updateMinimap(true); renderGutter(true);
    }
    function doSave(isManual=false){
      if(!currentId || !isDirty && !isManual) return;
      const text = editor.value; 
      const updatedAt = nowISO();
      const old = loadNote(currentId) || { createdAt: updatedAt };
      
      // Salvar bookmarks junto com a nota
      const bookmarksArray = Array.from(lineUX.bookmarks);
      saveNote(currentId, text, { 
        createdAt: old.createdAt, 
        updatedAt,
        bookmarks: bookmarksArray 
      });
      
      let idx = loadIndex();
      let meta = idx.find(n => n.id === currentId);
      
      if (meta) {
          meta.updatedAt = updatedAt;
      } else {
          // Should not happen if app logic is correct
          return;
      }

      // Move updated note to the top
      idx = idx.filter(n => n.id !== currentId);
      idx.unshift(meta);
      saveIndex(idx);
      
      if (dlgNotes.open) buildNotesList(); 
      
      isDirty = false; 
      lastSaveTime = new Date();
      updateDocTitle();
      updateLastSavedTime();
    }
    function deleteNote(id){
      let idx = loadIndex();
      idx = idx.filter(n=>n.id!==id); saveIndex(idx);
      deleteNoteStorage(id);
      if(currentId===id){
        if(idx.length){ openNote(idx[0].id); }
        else { const nid = createNote(''); openNote(nid); }
      }
      if (dlgNotes.open) buildNotesList();
    }
    function deleteAllNotes(){
      if(!confirm('Apagar TODAS as notas?')) return;
      if(!confirm('Tem certeza? Esta ação não pode ser desfeita.')) return;
      const idx = loadIndex();
      idx.forEach(n=> deleteNoteStorage(n.id));
      saveIndex([]); currentId=null; localStorage.removeItem(CURRENT_KEY);
      const nid = createNote(''); openNote(nid);
      if (dlgNotes.open) buildNotesList();
    }

    // ===== Import / Export =====
    function exportAllNotes() {
        const index = loadIndex();
        const notes = index.map(meta => {
            const note = loadNote(meta.id);
            return {
                id: meta.id,
                title: meta.title,
                text: note ? note.text : '',
                createdAt: meta.createdAt,
                updatedAt: meta.updatedAt,
                bookmarks: note ? (note.bookmarks || []) : []
            };
        });
        
        const backup = {
            version: '1.0',
            exportedAt: nowISO(),
            notes: notes,
        };

        const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `canvas_backup_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function handleImport(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const backup = JSON.parse(event.target.result);
                if (!backup.notes || !Array.isArray(backup.notes)) {
                    throw new Error('Invalid backup file format.');
                }

                let existingIndex = loadIndex();
                let importedCount = 0;

                backup.notes.forEach(note => {
                    // Simple import: add as new, don't check for duplicates
                    const newId = genId(); // Ensure unique ID
                    saveNote(newId, note.text, { 
                        createdAt: note.createdAt, 
                        updatedAt: note.updatedAt,
                        bookmarks: note.bookmarks || []
                    });
                    existingIndex.unshift({
                        id: newId,
                        title: note.title,
                        createdAt: note.createdAt,
                        updatedAt: note.updatedAt,
                    });
                    importedCount++;
                });

                saveIndex(existingIndex);
                buildNotesList();
                alert(`${importedCount} notes importadas com sucesso!`);

            } catch (err) {
                alert('Erro ao importar backup: ' + err.message);
            } finally {
                // Reset file input
                e.target.value = '';
            }
        };
        reader.readAsText(file);
    }

    // ===== Line Editing Shortcuts =====
    function getLineInfo() {
        const text = editor.value;
        const start = editor.selectionStart;
        const end = editor.selectionEnd;
        const hasSelection = start !== end;

        let lineStart, lineEnd;

        if (hasSelection) {
            lineStart = text.lastIndexOf('\n', start - 1) + 1;
            lineEnd = text.indexOf('\n', end);
            if (lineEnd === -1) lineEnd = text.length;
        } else {
            lineStart = text.lastIndexOf('\n', start - 1) + 1;
            lineEnd = text.indexOf('\n', start);
            if (lineEnd === -1) lineEnd = text.length;
        }
        
        return { text, start, end, lineStart, lineEnd, hasSelection };
    }

    function duplicateLineOrSelection() {
        const { text, start, end, lineStart, lineEnd, hasSelection } = getLineInfo();
        
        const contentToDuplicate = hasSelection 
            ? text.substring(start, end)
            : text.substring(lineStart, lineEnd) + '\n';
        
        const insertPosition = hasSelection ? end : lineEnd;
        
        editor.value = text.slice(0, insertPosition) + contentToDuplicate + text.slice(insertPosition);
        
        editor.setSelectionRange(insertPosition, insertPosition + contentToDuplicate.length);
        editor.dispatchEvent(new Event('input'));
    }

    function moveLineOrSelection(direction) {
        let { text, start, end, lineStart, lineEnd, hasSelection } = getLineInfo();
        
        if (text[lineEnd] === '\n') lineEnd++;
        const block = text.substring(lineStart, lineEnd);

        if (direction === 'up') {
            if (lineStart === 0) return;
            
            const prevLineStart = text.lastIndexOf('\n', lineStart - 2) + 1;
            const between = text.substring(prevLineStart, lineStart);
            
            editor.value = text.substring(0, prevLineStart) + block + between + text.substring(lineEnd);
            editor.setSelectionRange(start - between.length, end - between.length);

        } else { // down
            if (lineEnd === text.length) return;

            let nextLineEnd = text.indexOf('\n', lineEnd);
            if (nextLineEnd === -1) nextLineEnd = text.length; else nextLineEnd++;
            
            const between = text.substring(lineEnd, nextLineEnd);

            editor.value = text.substring(0, lineStart) + between + block + text.substring(nextLineEnd);
            editor.setSelectionRange(start + between.length, end + between.length);
        }
        editor.dispatchEvent(new Event('input'));
    }

    // ===== UI: Notes Dialog =====
    function buildNotesList(filter = ''){
      let idx = loadIndex();
      const q = (filter||'').toLowerCase().trim();
      if (q) {
        idx = idx.filter(n => {
          const note = loadNote(n.id);
          const content = note ? note.text : '';
          return n.title.toLowerCase().includes(q) || content.toLowerCase().includes(q);
        });
      }

      notesList.innerHTML = '';
      notesList.setAttribute('role','listbox');
      notesList.tabIndex = 0;

      if (!idx.length){
        const empty = document.createElement('div');
        empty.style.opacity = '.7'; empty.style.padding = '10px';
        empty.textContent = filter ? 'Nenhuma nota encontrada.' : 'Nenhuma nota.';
        notesList.appendChild(empty);
        return;
      }

      idx.forEach((n, i) => {
        const note = loadNote(n.id);
        const row = document.createElement('div');
        row.className = 'note-row';
        row.setAttribute('role','option');
        row.dataset.id = n.id;
        row.ariaSelected = String(n.id === currentId);

        const left = document.createElement('div');
        left.style.display = 'grid';
        left.style.gridTemplateColumns = '1fr';
        left.style.gap = '4px';

        const title = document.createElement('div');
        title.className = 'note-title';
        title.textContent = n.title;

        const meta = document.createElement('div');
        meta.className = 'note-meta';
        const kb = ((note?.text||'').length/1024).toFixed(1);
        meta.textContent = `${fmtDateTime(n.updatedAt)} • ${kb} KB`;

        left.append(title, meta);

        const actions = document.createElement('div');
        actions.className = 'note-actions';
        const openBtn = document.createElement('button');
        openBtn.className = 'tbtn'; openBtn.textContent = 'Abrir';
        openBtn.onclick = () => { dlgNotes.close(); openNote(n.id); };

        const delBtn = document.createElement('button');
        delBtn.className = 'tbtn'; delBtn.textContent = 'Apagar';
        delBtn.onclick = () => { deleteNote(n.id); };

        actions.append(openBtn, delBtn);

        row.append(left, actions);
        row.addEventListener('dblclick', () => { dlgNotes.close(); openNote(n.id); });
        row.addEventListener('click', () => {
          notesList.querySelectorAll('[aria-selected="true"]').forEach(el=>el.ariaSelected='false');
          row.ariaSelected = 'true';
        });

        notesList.appendChild(row);
      });
    }

    /* Navegação por teclado no modal de notas */
    dlgNotes.addEventListener('keydown', (e) => {
      const options = [...notesList.querySelectorAll('[role="option"]')];
      const current = options.findIndex(el => el.getAttribute('aria-selected') === 'true');
      if (!options.length) return;

      if (e.key === 'ArrowDown' || e.key === 'ArrowUp'){
        e.preventDefault();
        let next = current;
        if (e.key === 'ArrowDown') next = Math.min(options.length-1, Math.max(0, current + 1));
        else next = Math.max(0, current - 1);
        options.forEach(el => el.ariaSelected = 'false');
        options[next].ariaSelected = 'true';
        options[next].scrollIntoView({block:'nearest'});
      }
      else if (e.key === 'Enter'){
        e.preventDefault();
        const sel = options.find(el => el.getAttribute('aria-selected') === 'true') || options[0];
        if (sel) { dlgNotes.close(); openNote(sel.dataset.id); }
      }
      else if (e.key === 'Delete' || e.key === 'Backspace'){
        e.preventDefault();
        const sel = options.find(el => el.getAttribute('aria-selected') === 'true');
        if (sel) { deleteNote(sel.dataset.id); }
      }
    });

    // ===== Editor Meta =====
    function updateLnCol(){
      const pos = editor.selectionStart || 0; 
      const until = editor.value.slice(0, pos);
      const lines = until.split('\n'); 
      const ln = lines.length; // Esta é sempre a linha física (quebra \n)
      const col = lines[lines.length-1].length + 1;
      lnCol.textContent = `Ln ${ln}, Col ${col}`;
      
      if (linesVisible) {
        // Destaca se a linha estiver no range renderizado
        highlightCurrentLineInGutter(ln);
      }
    }
    
    function highlightCurrentLineInGutter(currentLine) {
      // Remove destaque anterior
      document.querySelectorAll('.gutter .ln.current').forEach(el => {
        el.classList.remove('current');
      });
      
      // Adiciona destaque à linha atual
      const gutterLines = document.querySelectorAll('.gutter .ln');
      gutterLines.forEach(el => {
        if (parseInt(el.textContent) === currentLine) {
          el.classList.add('current');
        }
      });
    }
    function updateWordCount(){ const words = editor.value.trim() ? editor.value.trim().split(/\s+/).length : 0; wordCountEl.textContent = `${words.toLocaleString('pt-BR')} ${words===1?'palavra':'palavras'}`; }
    
    function updateFooterInfo() {
      // Atualizar estado do wrap
      wrapStateEl.textContent = wrapOn ? 'Com quebra' : 'Sem quebra';
      
      // Tornar estado do wrap clicável
      if (!wrapStateEl.onclick) {
        wrapStateEl.style.cursor = 'pointer';
        wrapStateEl.title = 'Alternar quebra de linha (Alt+Z)';
        wrapStateEl.onclick = () => setWrap(!wrapOn);
      }
      
      // Adicionar informações sobre bookmarks se houver
      const bookmarkCount = lineUX.bookmarks.size;
      if (bookmarkCount > 0) {
        wrapStateEl.textContent += ` • ${bookmarkCount} marcador${bookmarkCount === 1 ? '' : 'es'}`;
      }
    }
    
    function updateProgress(){ 
      const el = editor; 
      const max = el.scrollHeight - el.clientHeight; 
      const pct = max > 0 ? (el.scrollTop / max) * 100 : 0; 
      progress.style.width = pct + '%'; 
      updateMiniViewport(); 
      
      if(linesVisible) {
        // Renderiza o gutter com sincronização inteligente
        renderGutter();
      }
    }
    function updateAllMeta(){ updateLnCol(); updateWordCount(); updateFooterInfo(); updateProgress(); }

    // ===== Wrap / Lines / Minimap (sincronizados) =====
    function reflectToggles(){
      // Toolbar
      btnToggleWrap.setAttribute('aria-pressed', String(wrapOn));
      btnToggleLines.setAttribute('aria-pressed', String(linesVisible));
      btnToggleMini.setAttribute('aria-pressed', String(miniVisible));
      // Switches
      switchWrap.setAttribute('aria-checked', String(wrapOn));
      switchLines.setAttribute('aria-checked', String(linesVisible));
      switchMini.setAttribute('aria-checked', String(miniVisible));
    }

    function setWrap(on){
      wrapOn = !!on;
      if(wrapOn){ 
        editor.setAttribute('wrap','soft'); 
        editor.style.whiteSpace='pre-wrap'; 
      } else { 
        editor.setAttribute('wrap','off'); 
        editor.style.whiteSpace='pre'; 
      }
      
      // Limpeza COMPLETA do gutter para evitar sobreposições
      if (linesVisible) {
        // Preservar posição de scroll atual
        const currentScrollTop = editor.scrollTop;
        
        // Limpeza total - remover todo conteúdo
        gutter.innerHTML = '';
        
        // Resetar referencias de containers
        gutter._inner = null;
        gutter._container = null;
        gutter._lastScrollTop = 0;
        lastRenderedLineCount = -1;
        
        // Restaurar scroll após limpeza
        editor.scrollTop = currentScrollTop;
      }
      
      // Invalidar métricas para forçar nova medição
      if (wrapOn) {
        wrapMetrics.heights = wrapMetrics.prefix = null;
        wrapMetrics.total = 0;
        wrapMetrics.widthsKey = '';
      }
      
      reflectToggles();
      updateFooterInfo();
      persistSettings(); 
      updateMinimap(true); 
      
      // Re-renderização imediata sem delay para evitar blink
      if (linesVisible) {
        renderGutter(true);
      }
      
      // Atualiza a posição/estado do cursor
      requestAnimationFrame(() => updateLnCol());
    }
    function setLineNumbers(on){
      linesVisible = !!on;
      
      // Limpa timeouts pendentes para evitar renderizações conflitantes
      clearTimeout(renderGutter._debounce);
      
      shell.classList.toggle('lines-on', linesVisible);
      gutter.setAttribute('aria-hidden', String(!linesVisible));

      // Acessibilidade: gutter focusável quando ativo
      if (linesVisible) {
        gutter.setAttribute('tabindex', '0');
        gutter.setAttribute('role', 'listbox');
        gutter.setAttribute('aria-label', 'Números de linha - Use setas para navegar, Enter para selecionar, Espaço para marcar');
        setTimeout(() => renderGutter(true), 10);
      } else {
        gutter.removeAttribute('tabindex');
        gutter.removeAttribute('role');
        gutter.removeAttribute('aria-label');
        gutter.innerHTML = '';
        gutter._inner = null;        // <- evita referência órfã
        gutter._lastScrollTop = 0;   // <- limpa cache de scroll
      }

      reflectToggles();
      persistSettings();
    }
    function setMinimap(on){
      miniVisible = !!on;
      shell.classList.toggle('minimap-on', miniVisible);
      minimap.hidden = !miniVisible; minimap.setAttribute('aria-hidden', String(!miniVisible));
      reflectToggles(); persistSettings(); updateMinimap(true);
    }

    // ===== Minimap text + lens =====
    function updateMinimap(force=false){
      if(!miniVisible) return;
      if(!force){ clearTimeout(updateMinimap._t); updateMinimap._t = setTimeout(()=> updateMinimap(true), 120); return; }
      const text = editor.value;
      if(text.length > 400000){ miniText.textContent = '[conteúdo grande — minimap simplificado]'; }
      else { miniText.textContent = text || ' '; }
      updateMiniViewport();
    }
    function getMiniTrackMetrics() {
      const mapH = minimap.clientHeight;
      const cs = getComputedStyle(miniText);
      const padTop = parseFloat(cs.paddingTop) || 0;
      const padBottom = parseFloat(cs.paddingBottom) || 0;
      const trackTop = padTop;                                // início da pista
      const trackHeight = Math.max(0, mapH - padTop - padBottom); // altura útil
      return { mapH, trackTop, trackHeight };
    }
    function updateMiniViewport() {
      if (!miniVisible) return;

      const { trackTop, trackHeight } = getMiniTrackMetrics();

      const scrollRange = Math.max(0, editor.scrollHeight - editor.clientHeight);
      const isScrollable = scrollRange > 1;

      // tamanho do visor proporcional ao que o editor mostra
      const ratio = editor.scrollHeight > 0 ? (editor.clientHeight / editor.scrollHeight) : 1;
      const lensH = Math.min(trackHeight, Math.max(24, Math.floor(trackHeight * Math.min(1, ratio))));

      const trackRange = Math.max(0, trackHeight - lensH);
      const topRel = (isScrollable && trackRange > 0)
        ? (editor.scrollTop / scrollRange) * trackRange
        : 0;

      miniViewport.style.height = lensH + 'px';
      miniViewport.style.top = (trackTop + topRel) + 'px';

      const disabled = !isScrollable || trackRange === 0;
      minimap.classList.toggle('mini-disabled', disabled);
      miniViewport.style.cursor = disabled ? 'default' : 'grab';
      miniViewport.style.pointerEvents = disabled ? 'none' : 'auto';
    }

    // Scrub & drag
    let dragging = false; let dragStartY = 0; let lensStartTop = 0;
    function scrollFromMinimap(clientY) {
      const { trackTop, trackHeight } = getMiniTrackMetrics();
      const lensH = miniViewport.clientHeight;

      const trackRange = Math.max(0, trackHeight - lensH);
      const scrollRange = Math.max(0, editor.scrollHeight - editor.clientHeight);
      if (trackRange === 0 || scrollRange === 0) return;

      const rect = minimap.getBoundingClientRect();
      const desiredRel = clientY - rect.top - trackTop - (lensH / 2);
      const yRel = Math.max(0, Math.min(desiredRel, trackRange));
      const pct = yRel / trackRange;

      editor.scrollTop = pct * scrollRange;
      updateProgress();
    }
    
    // Previne seleção de texto durante arrastar
    function preventTextSelection(e) {
      if (dragging) {
        e.preventDefault();
        return false;
      }
    }
    
    minimap.addEventListener('pointerdown', (e)=>{ 
      e.preventDefault(); 
      e.stopPropagation();
      minimap.setPointerCapture(e.pointerId); 
      scrollFromMinimap(e.clientY); 
      dragging = true;
      document.body.style.userSelect = 'none'; // Previne seleção durante o arrastar
    });
    
    window.addEventListener('pointermove', (e)=>{ 
      if(!dragging) return; 
      e.preventDefault();
      scrollFromMinimap(e.clientY); 
    });
    
    window.addEventListener('pointerup', (e)=>{ 
      if (dragging) {
        dragging = false; 
        document.body.style.userSelect = ''; // Restaura seleção
        if (minimap.hasPointerCapture(e.pointerId)) {
          minimap.releasePointerCapture(e.pointerId);
        }
      }
    });
    
    miniViewport.addEventListener('pointerdown', (e)=>{ 
      e.stopPropagation(); 
      e.preventDefault();
      dragging = true; 
      minimap.setPointerCapture(e.pointerId);
      document.body.style.userSelect = 'none';
    });
    
    // Previne seleção durante mouse move
    document.addEventListener('selectstart', preventTextSelection);
    document.addEventListener('dragstart', preventTextSelection);
    
    minimap.addEventListener('wheel', (e)=>{ 
      if (!miniVisible) return; 
      const scrollRange = Math.max(0, editor.scrollHeight - editor.clientHeight);
      if (scrollRange === 0) { e.preventDefault(); return; }
      e.preventDefault();
      editor.scrollTop += e.deltaY; 
      updateProgress(); 
    }, {passive: false});

    minimap.addEventListener('keydown', e => {
        if (!miniVisible) return;
        e.preventDefault();
        const page = editor.clientHeight;
        switch(e.key) {
            case 'ArrowUp': editor.scrollTop -= 20; break;
            case 'ArrowDown': editor.scrollTop += 20; break;
            case 'PageUp': editor.scrollTop -= page; break;
            case 'PageDown': editor.scrollTop += page; break;
            case 'Home': editor.scrollTop = 0; break;
            case 'End': editor.scrollTop = editor.scrollHeight; break;
            case 'Enter': editor.focus(); break;
        }
        updateProgress();
    });

    // ===== Wrap metrics (medidor offscreen para alturas por linha) =====
    const wrapMetrics = {
      measureEl: null,
      widthsKey: '',
      heights: null,      // array de alturas por linha física
      prefix: null,       // soma prefixada (cumulativa) de alturas
      total: 0
    };

    function invalidateWrapMetrics(){
      wrapMetrics.heights = null;
      wrapMetrics.prefix = null;
      wrapMetrics.total = 0;
      wrapMetrics.widthsKey = '';
    }

    function ensureMeasureEl(){
      if (wrapMetrics.measureEl) return wrapMetrics.measureEl;
      const el = document.createElement('div');
      el.id = 'wrapMeasure';
      el.style.cssText = [
        'position:fixed','left:-10000px','top:0','visibility:hidden',
        'white-space:pre-wrap','word-break:break-word','overflow-wrap:break-word',
        'tab-size:2'
      ].join(';');
      document.body.appendChild(el);
      wrapMetrics.measureEl = el;
      return el;
    }

    function buildWidthsKey(){
      // chave para invalidar cache quando largura/fonte mudam
      const cs = getComputedStyle(editor);
      const padL = parseFloat(cs.paddingLeft)||0;
      const padR = parseFloat(cs.paddingRight)||0;
      const contentW = editor.clientWidth - padL - padR;
      return [
        'w=', Math.max(0, Math.floor(contentW)),
        ';font=', cs.font,
        ';lh=', cs.lineHeight
      ].join('');
    }

    function measureWrappedHeights(){
      const el = ensureMeasureEl();
      const cs = getComputedStyle(editor);
      // espelha a tipografia do editor
      el.style.font = cs.font;
      el.style.lineHeight = cs.lineHeight;
      el.style.letterSpacing = cs.letterSpacing;
      el.style.tabSize = cs.tabSize || '2';

      // largura do conteúdo (sem padding) para simular o wrap do textarea
      const padL = parseFloat(cs.paddingLeft)||0;
      const padR = parseFloat(cs.paddingRight)||0;
      el.style.width = Math.max(0, editor.clientWidth - padL - padR) + 'px';

      const lines = editor.value.split('\n');
      el.innerHTML = ''; // limpa

      // criamos um bloco por linha física
      const frag = document.createDocumentFragment();
      for (let i = 0; i < lines.length; i++){
        const d = document.createElement('div');
        d.className = 'm-line';
        // linha vazia precisa de conteúdo para dar altura
        d.textContent = lines[i].length ? lines[i] : '\u00A0'; // nbsp
        frag.appendChild(d);
      }
      el.appendChild(frag);

      // mede
      const heights = new Array(lines.length);
      let total = 0;
      const prefix = new Array(lines.length);
      const kids = el.children;
      for (let i = 0; i < kids.length; i++){
        const h = kids[i].getBoundingClientRect().height; // px reais (com wrap)
        heights[i] = h;
        total += h;
        prefix[i] = total;
      }

      wrapMetrics.heights = heights;
      wrapMetrics.prefix = prefix;
      wrapMetrics.total = total;
      wrapMetrics.widthsKey = buildWidthsKey();
    }

    function measureWrappedHeightsDeferred() {
      const run = () => { try { measureWrappedHeights(); } catch {} };
      (window.requestIdleCallback || setTimeout)(run, 16);
    }

    // busca binária: primeira linha cujo topo acumulado ultrapassa y
    function lineAtY(y){
      const pre = wrapMetrics.prefix;
      let lo = 0, hi = pre.length - 1, ans = pre.length - 1;
      while (lo <= hi){
        const mid = (lo + hi) >> 1;
        if (pre[mid] > y){ ans = mid; hi = mid - 1; }
        else { lo = mid + 1; }
      }
      return ans; // índice (0-based)
    }

    // ===== Geometria unificada =====
    function lineGeometry(lineIdx) {
      const lh = parseFloat(getComputedStyle(editor).lineHeight);
      if (!wrapOn) {
        return { top: (lineIdx - 1) * lh, height: lh };
      }

      // Wrap: garante medições válidas
      if (!wrapMetrics.heights || wrapMetrics.widthsKey !== buildWidthsKey()) {
        measureWrappedHeights();
      }
      const h = wrapMetrics.heights[lineIdx - 1] ?? lh;
      const top = lineIdx <= 1 ? 0 : (wrapMetrics.prefix[lineIdx - 2] || 0);
      return { top, height: h };
    }

    // y relativo ao CONTEÚDO (sem padding) -> linha (1-based)
    function lineFromY(yContent) {
      if (!wrapOn) {
        const lh = parseFloat(getComputedStyle(editor).lineHeight);
        return Math.max(1, Math.floor(yContent / lh) + 1);
      }
      // usa sua busca binária sobre prefix[]
      return (lineAtY(yContent)) + 1;
    }

    function scrollLineIntoView(lineIdx, align = 'center') {
      const { top, height } = lineGeometry(lineIdx);
      const padTop = parseFloat(getComputedStyle(editor).paddingTop) || 0;
      let target;
      if (align === 'start') target = top;
      else if (align === 'end') target = top - (editor.clientHeight - height);
      else target = top - (editor.clientHeight / 2 - height / 2);
      editor.scrollTop = Math.max(0, target);
      updateProgress();
      renderGutter(false);
      updateMiniViewport();
    }

    // ===== Seleção de linhas =====
    function selectLineRange(fromLine, toLine) {
      const startLine = Math.max(1, Math.min(fromLine, toLine));
      const endLine = Math.max(fromLine, toLine);
      const start = getLineStartPosition(startLine);
      // fim no começo da próxima linha (ou final do texto)
      const end = endLine >= totalLines()
        ? editor.value.length
        : getLineStartPosition(endLine + 1) - 1; // -1 para incluir o \n
      editor.setSelectionRange(start, end);
      editor.focus();
      updateLnCol();
      showSelectionBand(startLine, endLine);
    }

    function showHoverBand(lineIdx) {
      const padTop = parseFloat(getComputedStyle(editor).paddingTop) || 0;
      const { top, height } = lineGeometry(lineIdx);
      hoverEl.style.top = (top - editor.scrollTop + padTop) + 'px';
      hoverEl.style.height = height + 'px';
      hoverEl.style.display = 'block';
    }
    function hideHoverBand() {
      hoverEl.style.display = 'none';
    }

    function showSelectionBand(fromLine, toLine) {
      const padTop = parseFloat(getComputedStyle(editor).paddingTop) || 0;
      const a = Math.max(1, Math.min(fromLine, toLine));
      const b = Math.max(fromLine, toLine);
      const gA = lineGeometry(a), gB = lineGeometry(b);
      const top = gA.top;
      const bottom = gB.top + gB.height;
      selEl.style.top = (top - editor.scrollTop + padTop) + 'px';
      selEl.style.height = (bottom - top) + 'px';
      selEl.style.display = 'block';
    }

    function clearSelectionBand() {
      selEl.style.display = 'none';
    }

    // ===== Gutter (line numbers) =====
    function totalLines(){ return (editor.value.match(/\n/g)||[]).length + 1; }
    
    // Função para encontrar a linha física baseada na posição do cursor
    function getPhysicalLineFromPosition(pos) {
      const textBeforeCursor = editor.value.slice(0, pos);
      return textBeforeCursor.split('\n').length;
    }
    
    // Função para obter a posição inicial de uma linha física
    function getLineStartPosition(lineNumber) {
      if (lineNumber <= 1) return 0;
      const lines = editor.value.split('\n');
      let pos = 0;
      for (let i = 0; i < lineNumber - 1; i++) {
        pos += lines[i].length + 1; // +1 para o \n
      }
      return pos;
    }
    
    // Função helper para criar elementos de linha com estilo consistente
    function createLineElement(lineNum, lineHeight, top = null, position = 'relative') {
      const div = document.createElement('div');
      div.className = 'ln';
      div.textContent = lineNum;
      
      // Adicionar classe bookmark se a linha estiver marcada
      if (lineUX.bookmarks.has(lineNum)) {
        div.classList.add('bookmark');
      }
      
      // Acessibilidade e tooltip
      div.setAttribute('role', 'option');
      div.setAttribute('aria-label', `Linha ${lineNum}`);
      div.setAttribute('title', 'Clique: selecionar • Shift+clique: intervalo • Alt+clique: marcador • Duplo clique: centralizar');
      
      // Estilo base consistente
      div.style.height = lineHeight + 'px';
      div.style.lineHeight = lineHeight + 'px';
      div.style.position = position;
      div.style.padding = '0 3px';
      div.style.textAlign = 'right';
      div.style.boxSizing = 'border-box';
      
      // Posicionamento específico para elementos absolutos
      if (position === 'absolute') {
        div.style.top = (top || 0) + 'px';
        div.style.left = '0';
        div.style.right = '0';
        div.style.width = '100%';
      }
      
      return div;
    }

    function renderGutter(force=false){
      if(!linesVisible) return;
      
      // Evita renderização simultânea
      if (renderGutter._rendering && !force) return;
      renderGutter._rendering = true;
      
      // DETECTAR MUDANÇA DE MODO para limpeza total
      const previousMode = renderGutter._lastMode;
      const currentMode = wrapOn ? 'wrap' : 'nowrap';
      const modeChanged = previousMode && previousMode !== currentMode;
      
      if (modeChanged || force) {
        gutter.innerHTML = '';
        gutter._inner = null;
        gutter._container = null;
      }
      
      renderGutter._lastMode = currentMode;
      
      // CONFIGURAÇÃO CONSISTENTE DE SCROLL
      // Sempre ocultar overflow para evitar scroll independente
      gutter.style.overflowY = 'hidden';
      gutter.style.overflowX = 'hidden';
      
      const tl = totalLines(); // Sempre conta apenas linhas físicas (quebras \n)
      const lh = parseFloat(getComputedStyle(editor).lineHeight);
      
      // Comportamentos completamente distintos para wrap vs sem wrap
      if (wrapOn) {
        // TRANSIÇÃO SEGURA PARA MODO WRAP
        // Sempre limpar conteúdo ao mudar de modo
        if (force) {
          gutter.innerHTML = '';
        }
        
        // fallback p/ arquivos gigantes (evita custo alto de medição)
        const big = editor.value.length > 500000 || tl > 20000;
        const needMeasure =
          !wrapMetrics.heights ||
          wrapMetrics.widthsKey !== buildWidthsKey();

        if (!big && (force || needMeasure)) {
          try {
            measureWrappedHeights();
          } catch (e) {
            console.warn('Erro ao medir alturas:', e);
            renderGutter._rendering = false;
            return;
          }
        }

        // Se muito grande, renderiza simples (melhor do que quebrar)
        if (big || !wrapMetrics.heights) {
          gutter.innerHTML = '';
          const frag = document.createDocumentFragment();
          for (let i = 1; i <= tl; i++) {
            const div = createLineElement(i, lh, null, 'relative');
            frag.appendChild(div);
          }
          gutter.appendChild(frag);
          lastRenderedLineCount = tl;
          renderGutter._rendering = false;
          return;
        }

        // Virtualização por altura real (wrap)
        const viewTop = editor.scrollTop;
        const viewH = editor.clientHeight;
        const viewBottom = viewTop + viewH;

        // Range visível + margem
        const startIdx = Math.max(0, lineAtY(Math.max(0, viewTop) ) - 3);
        const endIdx   = Math.min(wrapMetrics.heights.length - 1,
                                  lineAtY(viewBottom) + 3);

        // container interno para elementos virtuais
        if (!gutter._inner || !gutter._inner.isConnected) {
          // Garantir que não há conteúdo residual antes de criar o container
          gutter.innerHTML = '';
          
          gutter._inner = document.createElement('div');
          gutter._inner.style.position = 'relative';
          gutter._inner.style.width = '100%';
          gutter._inner.style.textAlign = 'right';
          gutter._inner.style.height = '100%'; // Altura relativa, não fixa
          gutter.appendChild(gutter._inner);
        }

        // Re-renderiza somente o range visível
        gutter._inner.innerHTML = '';
        const frag = document.createDocumentFragment();

        for (let i = startIdx; i <= endIdx; i++){
          const absoluteTop = i === 0 ? 0 : wrapMetrics.prefix[i - 1];
          // CORREÇÃO CRÍTICA: Posição relativa ao viewport para sincronização
          const relativeTop = absoluteTop - editor.scrollTop;
          const h = wrapMetrics.heights[i];
          const div = createLineElement(i + 1, h, relativeTop, 'absolute');
          frag.appendChild(div);
        }
        gutter._inner.appendChild(frag);

        lastRenderedLineCount = tl;
        renderGutter._rendering = false;
        return;
      } else {
        // TRANSIÇÃO SEGURA DO MODO WRAP PARA SEM WRAP
        // Limpeza completa para evitar sobreposições
        if (gutter._inner) {
          gutter._inner.remove();
          gutter._inner = null;
        }
        
        // Sempre limpar conteúdo ao mudar de modo
        if (force) {
          gutter.innerHTML = '';
        }
        
        // MODO SEM WRAP: Gutter sincronizado com editor
        const virtual = tl > 5000 || editor.value.length > 400000;
        
        gutter.style.position = 'relative';

        if (virtual) {
          // Renderização virtual para arquivos grandes
          const scrollTop = editor.scrollTop;
          const viewHeight = editor.clientHeight;
          
          // Obter o padding do editor para calcular o offset correto
          const editorStyles = getComputedStyle(editor);
          const editorPaddingTop = parseFloat(editorStyles.paddingTop) || 0;
          
          // Ajustar scrollTop para considerar apenas o conteúdo do texto
          const contentScrollTop = Math.max(0, scrollTop - editorPaddingTop);
          const startLine = Math.max(1, Math.floor(contentScrollTop / lh) - 2);
          const endLine = Math.min(tl, Math.ceil((contentScrollTop + viewHeight) / lh) + 2);
          
          if (force || Math.abs(scrollTop - (gutter._lastScrollTop || 0)) > lh) {
            gutter.innerHTML = '';
            gutter._lastScrollTop = scrollTop;
            
            const frag = document.createDocumentFragment();
            
            // Obter padding do gutter para alinhamento correto
            const gutterStyles = getComputedStyle(gutter);
            const gutterPaddingTop = parseFloat(gutterStyles.paddingTop) || 0;
            
            for (let lineNum = startLine; lineNum <= endLine; lineNum++) {
              // CORREÇÃO CRÍTICA: Posição relativa ao viewport, não absoluta
              const absoluteLineTop = (lineNum - 1) * lh;
              const relativeTop = absoluteLineTop - contentScrollTop + gutterPaddingTop;
              const div = createLineElement(lineNum, lh, relativeTop, 'absolute');
              frag.appendChild(div);
            }
            
            if (frag.children.length > 0) {
              gutter.appendChild(frag);
            }
          }
        } else {
          // Renderização normal para arquivos menores
          if (force || tl !== lastRenderedLineCount) {
            gutter.innerHTML = '';
            const frag = document.createDocumentFragment();
            
            for (let i = 1; i <= tl; i++) { 
              const div = createLineElement(i, lh, null, 'relative');
              frag.appendChild(div); 
            }
            gutter.appendChild(frag); 
            lastRenderedLineCount = tl;
          }
        }
        
        // Sincroniza scroll no modo sem wrap, garantindo que
        // o offset de scroll seja idêntico ao do editor
        gutter.scrollTop = editor.scrollTop;
      }
      
      renderGutter._rendering = false;
    }

    // ===== Theme Variable Declaration =====
    let currentTheme = 'auto';
    const lightScheme = window.matchMedia('(prefers-color-scheme: light)');

    // ===== Settings persist =====
    function persistSettings(){
      const data = {
        fs: Number(fontSize.value),
        lh: Number(lineHeight.value),
        pad: Number(padX.value),
        wrap: wrapOn, lines: linesVisible, mini: miniVisible,
        theme: currentTheme,
        glass: {
          blur: Number(document.getElementById('glassBlur')?.value || GLASS_DEFAULTS.blur),
          sat: Number(document.getElementById('glassSat')?.value || GLASS_DEFAULTS.sat),
          contrast: Number(document.getElementById('glassContrast')?.value || GLASS_DEFAULTS.contrast)
        },
        ui: {
          reduceMotion: uiReduceMotion,
          density: uiDensity,
          highContrast: uiHighContrast
        },
        currentId
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(data));
    }

    function restoreSettings(){
      const s = JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}');

      // Editor
      const fs = s.fs ?? 10; setVar('--editor-font-size', fs+'px'); fontSize.value = fs; fontSizeDisplay.textContent = fs; document.getElementById('fontSizeValueDisplay').textContent = fs + 'px'; updateRangeProgress(fontSize, fs, 8, 24);
      const lh = s.lh ?? 1.55; setVar('--line-height', lh); lineHeight.value = lh; document.getElementById('lineHeightValueDisplay').textContent = lh.toFixed(2); updateRangeProgress(lineHeight, lh, 1.3, 1.9);
      const pad = s.pad ?? 16; setVar('--editor-padding', pad+'px'); padX.value = pad; document.getElementById('padXValueDisplay').textContent = pad + 'px'; updateRangeProgress(padX, pad, 8, 40);

      wrapOn = !!(s.wrap ?? false); setWrap(wrapOn);
      linesVisible = !!(s.lines ?? false); setLineNumbers(linesVisible);
      miniVisible = !!(s.mini ?? false); setMinimap(miniVisible);

      // Tema
      setTheme(s.theme || 'auto');
      // Marcar radio de tema se existir (novo UI)
      const themeRadio = document.querySelector(`input[name="theme"][value="${currentTheme}"]`);
      if (themeRadio) themeRadio.checked = true;

      // Glass
      const g = Object.assign({}, GLASS_DEFAULTS, s.glass || {});
      applyGlass(g);
      ['glassBlur','glassSat','glassContrast'].forEach((id) => {
        const el = document.getElementById(id); 
        if (el) {
          const value = g[id === 'glassBlur' ? 'blur' : id === 'glassSat' ? 'sat' : 'contrast'];
          el.value = value;
          
          // Inicializar displays de valor
          if (id === 'glassBlur') {
            document.getElementById('glassBlurValue').textContent = value + 'px';
          } else if (id === 'glassSat') {
            document.getElementById('glassSatValue').textContent = value + '%';
          } else if (id === 'glassContrast') {
            document.getElementById('glassContrastValue').textContent = value.toFixed(2);
          }
        }
      });

      // UI
      const u = Object.assign({ reduceMotion:false, density:'comfortable', highContrast:false }, s.ui || {});
      uiReduceMotion = !!u.reduceMotion; applyMotion(uiReduceMotion);
      uiDensity = u.density; applyDensity(uiDensity);
      uiHighContrast = !!u.highContrast; applyContrast(uiHighContrast);
      const dm = document.querySelector(`input[name="density"][value="${uiDensity}"]`); if (dm) dm.checked = true;
      document.getElementById('switchMotion')?.setAttribute('aria-checked', String(uiReduceMotion));
      document.getElementById('switchContrast')?.setAttribute('aria-checked', String(uiHighContrast));

      if(s.currentId) currentId = s.currentId;
      updateHints();
    }
    function updateHints(){ 
      if (fontSizeHint)   fontSizeHint.textContent   = fontSize.value + ' px'; 
      if (lineHeightHint) lineHeightHint.textContent = Number(lineHeight.value).toFixed(2); 
      if (padXHint)       padXHint.textContent       = padX.value + ' px'; 
    }

    // Update range visual progress
    function updateRangeProgress(input, value, min, max) {
      const progress = ((value - min) / (max - min)) * 100;
      input.style.setProperty('--progress', progress + '%');
    }

    // Font size control functions
    function setFontSize(size) {
      const clampedSize = Math.max(8, Math.min(24, size));
      setVar('--editor-font-size', clampedSize + 'px');
      fontSize.value = clampedSize;
      fontSizeDisplay.textContent = clampedSize;
      if (fontSizeHint) fontSizeHint.textContent = clampedSize + ' px';
      updateRangeProgress(fontSize, clampedSize, 8, 24);
      
      // Visual feedback
      fontSizeDisplay.classList.add('changed');
      setTimeout(() => fontSizeDisplay.classList.remove('changed'), 300);
      
      persistSettings();
      renderGutter(true);
      updateMinimap(true);
    }

    function increaseFontSize() {
      const current = parseInt(fontSize.value);
      setFontSize(current + 1);
    }

    function decreaseFontSize() {
      const current = parseInt(fontSize.value);
      setFontSize(current - 1);
    }

    // ===== File open/save =====
    btnOpen?.addEventListener('click', ()=> fileInput.click());
    fileInput.addEventListener('change', async (e)=>{ const file = e.target.files[0]; if(!file) return; const text = await file.text(); editor.value = text; editor.scrollTop=0; editor.scrollLeft=0; editor.dispatchEvent(new Event('input')); e.target.value=''; });
    btnSaveFile?.addEventListener('click', ()=>{ 
      const idx = loadIndex();
      const meta = currentId ? idx.find(n => n.id === currentId) : null;
      const title = (meta && meta.title) ? meta.title.split('•')[0].trim().replace(/[^a-z0-9\s-]/gi, '_') : 'canvas';
      const filename = `${title}.md`;
      const blob = new Blob([editor.value], {type:'text/markdown;charset=utf-8'}); 
      const a = document.createElement('a'); 
      a.href = URL.createObjectURL(blob); 
      a.download = filename; 
      a.click(); 
      URL.revokeObjectURL(a.href); 
    });

    // ===== Notes Dialog events =====
    btnNotes.addEventListener('click', ()=>{ buildNotesList(); dlgNotes.showModal(); });
    btnNew.addEventListener('click', ()=>{ const id = createNote(''); openNote(id); });
    btnNewInside.addEventListener('click', ()=>{ const id = createNote(''); openNote(id); buildNotesList(); });
    btnDup.addEventListener('click', ()=>{ const id = createNote(editor.value); openNote(id); buildNotesList(); });
    btnDelAll.addEventListener('click', deleteAllNotes);
    noteFilter.addEventListener('input', () => buildNotesList(noteFilter.value));
    btnPrint?.addEventListener('click', () => window.print());
    btnExport.addEventListener('click', exportAllNotes);
    btnImport.addEventListener('click', () => importFile.click());
    importFile.addEventListener('change', handleImport);

    // ===== Toolbar toggles (agora independem do estado do switch) =====
    btnToggleWrap.addEventListener('click', ()=> setWrap(!wrapOn));
    btnToggleLines.addEventListener('click', ()=> setLineNumbers(!linesVisible));
    btnToggleMini.addEventListener('click', ()=> setMinimap(!miniVisible));

    // ===== Settings inputs =====
    // ========== Settings Modal interactions ==========
    // dlgSettings já declarado anteriormente

    // abrir com foco e trap
    btnSettings.addEventListener('click', () => { dlgSettings.showModal(); focusTrap(dlgSettings); });

    // navegação lateral
    document.querySelectorAll('#settings .sheet-sidebar .nav button').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('#settings .sheet-sidebar .nav button').forEach(b=>b.setAttribute('aria-current','false'));
        btn.setAttribute('aria-current','true');
        const sec = btn.dataset.sec;
        document.querySelectorAll('#settings [data-section]').forEach(s => s.hidden = (s.dataset.section !== sec));
      });
    });

    // tema (segmented)
    document.querySelectorAll('input[name="theme"]').forEach(r=>{
      r.addEventListener('change', (e)=> setTheme(e.target.value));
    });

    // glass sliders
    ['glassBlur','glassSat','glassContrast'].forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener('input', ()=>{
        const value = Number(el.value);
        
        // Atualizar displays de valor
        if (id === 'glassBlur') {
          document.getElementById('glassBlurValue').textContent = value + 'px';
        } else if (id === 'glassSat') {
          document.getElementById('glassSatValue').textContent = value + '%';
        } else if (id === 'glassContrast') {
          document.getElementById('glassContrastValue').textContent = value.toFixed(2);
        }
        
        applyGlass({
          blur: Number(document.getElementById('glassBlur').value),
          sat: Number(document.getElementById('glassSat').value),
          contrast: Number(document.getElementById('glassContrast').value)
        });
        persistSettings();
      });
    });

    // density segmented
    document.getElementById('densitySeg')?.addEventListener('change', (e)=>{
      if (e.target.name === 'density'){
        uiDensity = e.target.value; applyDensity(uiDensity); persistSettings();
      }
    });

    // switches interface
    function toggleAriaSwitch(swId, on){
      const sw = document.getElementById(swId); if(!sw) return;
      const next = (on !== undefined) ? !!on : !(sw.getAttribute('aria-checked')==='true');
      sw.setAttribute('aria-checked', String(next));
      return next;
    }
    document.getElementById('switchMotion')?.addEventListener('click', ()=>{
      uiReduceMotion = toggleAriaSwitch('switchMotion');
      applyMotion(uiReduceMotion); persistSettings();
    });
    document.getElementById('switchContrast')?.addEventListener('click', ()=>{
      uiHighContrast = toggleAriaSwitch('switchContrast');
      applyContrast(uiHighContrast); persistSettings();
    });

    // botões utilidades
    document.getElementById('btnExportFromSettings')?.addEventListener('click', ()=> btnExport.click());
    document.getElementById('btnImportFromSettings')?.addEventListener('click', ()=> btnImport.click());

    document.getElementById('btnResetSettings')?.addEventListener('click', ()=>{
      if (!confirm('Restaurar padrões de Ajustes?')) return;
      localStorage.removeItem(SETTINGS_KEY);
      restoreSettings();
      showToast('Configurações restauradas', 'success');
    });
    document.getElementById('btnExportSettings')?.addEventListener('click', ()=>{
      const data = localStorage.getItem(SETTINGS_KEY) || '{}';
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([data],{type:'application/json'}));
      a.download = 'canvas_settings.json'; a.click(); URL.revokeObjectURL(a.href);
    });

    // ========== Help Center ==========
    const dlgHelp = document.getElementById('help');
    btnHelp.addEventListener('click', ()=> { dlgHelp.showModal(); focusTrap(dlgHelp); });

    document.querySelectorAll('#help .help-tabs [role="tab"]').forEach(tab=>{
      tab.addEventListener('click', ()=>{
        document.querySelectorAll('#help .help-tabs [role="tab"]').forEach(t=>t.setAttribute('aria-current','false'));
        tab.setAttribute('aria-current','true');
        const id = tab.dataset.tab;
        document.querySelectorAll('#help [data-tabpanel]').forEach(p => p.hidden = (p.getAttribute('data-tabpanel') !== id));
      });
    });

    // Tabela de atalhos (mesmo conteúdo que você tinha, mas gerado dinamicamente para filtrar)
    const SHORTCUTS = [
      ['Nova Nota','⌘/Ctrl + N'],
      ['Abrir Notas','⌘/Ctrl + O'],
      ['Ajustes','⌘/Ctrl + ,'],
      ['Buscar','⌘/Ctrl + F'],
      ['Substituir','⌘/Ctrl + H'],
      ['Ir para Linha','⌘/Ctrl + G'],
      ['Imprimir','⌘/Ctrl + P'],
      ['Duplicar Linha/Seleção','⌘/Ctrl + D'],
      ['Mover Linha/Seleção','Alt + ↑/↓'],
      ['Quebra de Linha','Alt + Z'],
      ['Alternar Marcador','F3 ou ⌘/Ctrl + B'],
      ['Renomear Nota','F2'],
      ['Aumentar Fonte','⌘/Ctrl + +'],
      ['Diminuir Fonte','⌘/Ctrl + -'],
      ['Resetar Fonte','⌘/Ctrl + 0']
    ];
    const shortcutList = document.getElementById('shortcutList');
    function renderShortcuts(filter=''){
      const f = filter.toLowerCase().trim();
      shortcutList.innerHTML = '';
      (f ? SHORTCUTS.filter(([a,b]) => a.toLowerCase().includes(f) || b.toLowerCase().includes(f)) : SHORTCUTS)
        .forEach(([name, combo])=>{
          const row = document.createElement('div'); row.className='shortcut-row';
          const left = document.createElement('div'); left.textContent = name;
          const right = document.createElement('div'); right.innerHTML = `<kbd>${combo}</kbd>`;
          row.append(left, right); shortcutList.appendChild(row);
        });
    }
    renderShortcuts();
    document.getElementById('helpSearch')?.addEventListener('input', (e)=> renderShortcuts(e.target.value));
    document.getElementById('btnCopyShortcuts')?.addEventListener('click', async ()=>{
      const asMd = SHORTCUTS.map(([n,k])=>`- ${n}: \`${k}\``).join('\n');
      await navigator.clipboard.writeText(asMd);
      showToast('Atalhos copiados', 'success');
    });
    
    // Font size controls
    fontSize.addEventListener('input', ()=>{ 
      const size = parseInt(fontSize.value);
      setVar('--editor-font-size', size+'px'); 
      fontSizeDisplay.textContent = size;
      document.getElementById('fontSizeValueDisplay').textContent = size + 'px';
      updateHints(); 
      updateRangeProgress(fontSize, size, 8, 24);
      persistSettings(); 
      renderGutter(true); 
      updateMinimap(true); 
    });
    
    lineHeight.addEventListener('input', ()=>{ 
      const lh = parseFloat(lineHeight.value);
      setVar('--line-height', lh); 
      document.getElementById('lineHeightValueDisplay').textContent = lh.toFixed(2);
      updateHints(); 
      updateRangeProgress(lineHeight, lh, 1.3, 1.9);
      persistSettings(); 
      renderGutter(true); 
      updateMinimap(true); 
    });
    
    padX.addEventListener('input', ()=>{ 
      const pad = parseInt(padX.value);
      setVar('--editor-padding', pad+'px'); 
      document.getElementById('padXValueDisplay').textContent = pad + 'px'; 
      updateHints(); 
      updateRangeProgress(padX, pad, 8, 40);
      persistSettings(); 
    });

    // Toolbar font controls
    btnFontUp.addEventListener('click', increaseFontSize);
    btnFontDown.addEventListener('click', decreaseFontSize);

    function toggleSwitch(sw){ const on = !(sw.getAttribute('aria-checked')==='true'); sw.setAttribute('aria-checked', String(on)); return on; }
    switchWrap.addEventListener('click', ()=> setWrap(toggleSwitch(switchWrap)));
    switchLines.addEventListener('click', ()=> setLineNumbers(toggleSwitch(switchLines)));
    switchMini.addEventListener('click', ()=> setMinimap(toggleSwitch(switchMini)));
    ;['keydown'].forEach(ev=>{
      switchWrap.addEventListener(ev, e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); setWrap(toggleSwitch(switchWrap)); }});
      switchLines.addEventListener(ev, e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); setLineNumbers(toggleSwitch(switchLines)); }});
      switchMini.addEventListener(ev, e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); setMinimap(toggleSwitch(switchMini)); }});
    });

    // ===== Editor events =====
    function scheduleSave(){
      isDirty = true; 
      updateDocTitle(); 
      saveStatus.textContent = 'Salvando…';
      clearTimeout(debounceSave); 
      debounceSave = setTimeout(()=>{ doSave(); }, 1000); 
    }
    editor.addEventListener('input', () => {
      updateWordCount();
      scheduleSave();
      updateMinimap();
      
      // Renderização do gutter sincronizada com o modo wrap
      if (linesVisible) {
        if (wrapOn) {
          // No modo wrap, invalida métricas primeiro e agenda re-renderização
          invalidateWrapMetrics();
          clearTimeout(renderGutter._debounce);
          renderGutter._debounce = setTimeout(() => renderGutter(true), 50);
        } else {
          // No modo sem wrap, renderiza imediatamente
          renderGutter(true);
        }
      }
      
      // Atualiza hover/seleção desenhados no overlay ao escrever
      if (lineUX.hoverLine) showHoverBand(lineUX.hoverLine);
      const selStart = editor.selectionStart, selEnd = editor.selectionEnd;
      if (selStart !== selEnd) {
        const a = getPhysicalLineFromPosition(selStart);
        const b = getPhysicalLineFromPosition(selEnd);
        showSelectionBand(a, b);
      } else {
        clearSelectionBand();
      }
      
      updateLnCol(); // atualiza destaque da linha atual
    });
    editor.addEventListener('scroll', () => {
      updateProgress();
      // Sync highlights overlay scroll
      highlights.scrollTop = editor.scrollTop;
      highlights.scrollLeft = editor.scrollLeft;
      
      // Atualiza hover/seleção desenhados no overlay ao rolar
      if (lineUX.hoverLine) showHoverBand(lineUX.hoverLine);
      const selStart = editor.selectionStart, selEnd = editor.selectionEnd;
      if (selStart !== selEnd) {
        const a = getPhysicalLineFromPosition(selStart);
        const b = getPhysicalLineFromPosition(selEnd);
        showSelectionBand(a, b);
      } else {
        clearSelectionBand();
      }
      
      // SINCRONIZAÇÃO CRÍTICA DO GUTTER
      if (linesVisible) {
        // Debounce para performance, mas manter responsividade
        clearTimeout(renderGutter._scrollDebounce);
        renderGutter._scrollDebounce = setTimeout(() => {
          renderGutter(false);
        }, 8); // 8ms = ~120fps máximo
      }
      
      // Update highlights for new viewport
      if (!findBar.hidden && findMatches.length > 0) {
        highlightViewportHits();
      }
    }, {passive:true});
    editor.addEventListener('keyup', updateLnCol);
    editor.addEventListener('click', updateLnCol);

    // ===== Interatividade no GUTTER =====

    // Mapear clientY -> linha (considerando padding/scroll do editor)
    function clientYToLine(clientY) {
      const edRect = editor.getBoundingClientRect();
      const padTop = parseFloat(getComputedStyle(editor).paddingTop) || 0;
      const yContent = (clientY - edRect.top) - padTop + editor.scrollTop;
      return Math.max(1, Math.min(totalLines(), lineFromY(yContent)));
    }

    // Hover
    gutter.addEventListener('mousemove', (e) => {
      if (!linesVisible) return;
      const line = clientYToLine(e.clientY);
      if (lineUX.hoverLine !== line) {
        lineUX.hoverLine = line;
        showHoverBand(line);
      }
    });
    gutter.addEventListener('mouseleave', () => {
      lineUX.hoverLine = null;
      hideHoverBand();
    });

    // Click / Shift+Click / Alt+Click / duplo clique
    gutter.addEventListener('mousedown', (e) => {
      if (!linesVisible) return;
      e.preventDefault(); // mantém foco no editor
      const line = clientYToLine(e.clientY);

      // Alt => toggle bookmark
      if (e.altKey) {
        if (lineUX.bookmarks.has(line)) lineUX.bookmarks.delete(line);
        else lineUX.bookmarks.add(line);
        renderGutter(true); // reaplica classe .bookmark
        return;
      }

      if (e.shiftKey && lineUX.anchorLine) {
        selectLineRange(lineUX.anchorLine, line);
      } else {
        // define âncora e seleciona somente a linha
        lineUX.anchorLine = line;
        selectLineRange(line, line);
      }

      // Arraste para seleção por linhas
      lineUX.dragging = true;
    });

    window.addEventListener('mousemove', (e) => {
      if (!lineUX.dragging) return;
      const line = clientYToLine(e.clientY);
      if (line !== null) {
        selectLineRange(lineUX.anchorLine || line, line);
      }
    });
    window.addEventListener('mouseup', () => {
      lineUX.dragging = false;
    });

    // Duplo clique -> centraliza
    gutter.addEventListener('dblclick', (e) => {
      if (!linesVisible) return;
      e.preventDefault();
      const line = clientYToLine(e.clientY);
      scrollLineIntoView(line, 'center');
    });

    // Menu contextual simples
    gutter.addEventListener('contextmenu', (e) => {
      if (!linesVisible) return;
      e.preventDefault();
      const line = clientYToLine(e.clientY);
      // Se não estava selecionada, selecione-a
      const { selectionStart, selectionEnd } = editor;
      const selStartLine = getPhysicalLineFromPosition(selectionStart);
      const selEndLine = getPhysicalLineFromPosition(selectionEnd);
      if (!(line >= selStartLine && line <= selEndLine)) {
        selectLineRange(line, line);
      }
      // Ações rápidas (mínimas); você pode trocar por seu popover bonito
      const act = prompt('Ação: (c)opiar, (d)uplicar, (x)apagar, (m)over↑, (n)over↓, (b)ookmark');
      switch ((act || '').toLowerCase()) {
        case 'c': document.execCommand('copy'); break; // simples (funciona no textarea)
        case 'd': duplicateLineOrSelection(); break;
        case 'x': document.execCommand('insertText', false, ''); break;
        case 'm': moveLineOrSelection('up'); break;
        case 'n': moveLineOrSelection('down'); break;
        case 'b': 
          const base = selStartLine;
          for (let L = selStartLine; L <= selEndLine; L++) lineUX.bookmarks.add(L);
          renderGutter(true);
          break;
      }
    });

    // ===== Navegação por teclado no gutter =====
    gutter.addEventListener('keydown', (e) => {
      if (!linesVisible) return;
      
      const currentLine = getPhysicalLineFromPosition(editor.selectionStart);
      let targetLine = currentLine;
      
      switch(e.key) {
        case 'ArrowUp':
          e.preventDefault();
          targetLine = Math.max(1, currentLine - 1);
          break;
        case 'ArrowDown':
          e.preventDefault();
          targetLine = Math.min(totalLines(), currentLine + 1);
          break;
        case 'PageUp':
          e.preventDefault();
          const pageUp = Math.floor(editor.clientHeight / parseFloat(getComputedStyle(editor).lineHeight));
          targetLine = Math.max(1, currentLine - pageUp);
          break;
        case 'PageDown':
          e.preventDefault();
          const pageDown = Math.floor(editor.clientHeight / parseFloat(getComputedStyle(editor).lineHeight));
          targetLine = Math.min(totalLines(), currentLine + pageDown);
          break;
        case 'Home':
          e.preventDefault();
          targetLine = 1;
          break;
        case 'End':
          e.preventDefault();
          targetLine = totalLines();
          break;
        case 'Enter':
          e.preventDefault();
          selectLineRange(currentLine, currentLine);
          return;
        case ' ':
          e.preventDefault();
          // Toggle bookmark na linha atual
          if (lineUX.bookmarks.has(currentLine)) {
            lineUX.bookmarks.delete(currentLine);
          } else {
            lineUX.bookmarks.add(currentLine);
          }
          renderGutter(true);
          doSave(true);
          return;
        default:
          return;
      }
      
      // Ir para a linha alvo
      scrollLineIntoView(targetLine, 'center');
      selectLineRange(targetLine, targetLine);
    });

    // Gutter scroll management - comportamento condicional baseado no modo wrap
    gutter.addEventListener('wheel', (e) => {
      if (!wrapOn && linesVisible) {
        // Só permite scroll do gutter no modo sem wrap
        e.preventDefault();
        editor.scrollTop += e.deltaY;
        updateProgress();
      }
      // No modo wrap, o evento passa através (comportamento padrão)
    }, {passive: false});

    // Tab insere 	
    editor.addEventListener('keydown', (e)=>{
      // Line editing shortcuts
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'd') {
        e.preventDefault();
        duplicateLineOrSelection();
      }
      if (e.altKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
        e.preventDefault();
        moveLineOrSelection(e.key === 'ArrowUp' ? 'up' : 'down');
      }
      
      // Bookmark toggle (F3 ou Cmd/Ctrl+B)
      if (e.key === 'F3' || ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'b')) {
        e.preventDefault();
        const currentLine = getPhysicalLineFromPosition(editor.selectionStart);
        if (lineUX.bookmarks.has(currentLine)) {
          lineUX.bookmarks.delete(currentLine);
        } else {
          lineUX.bookmarks.add(currentLine);
        }
        renderGutter(true);
        doSave(true); // força salvamento dos bookmarks
      }

      if(e.key==='Tab'){
        e.preventDefault(); const start = editor.selectionStart; const end = editor.selectionEnd; const v = editor.value; editor.value = v.slice(0,start) + '	' + v.slice(end); editor.selectionStart = editor.selectionEnd = start + 1; editor.dispatchEvent(new Event('input')); updateLnCol();
      }
      if(e.altKey && e.key.toLowerCase()==='z'){ e.preventDefault(); setWrap(!wrapOn); }
      if((e.metaKey||e.ctrlKey) && e.key==='o'){ e.preventDefault(); buildNotesList(); dlgNotes.showModal(); }

      if((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==='n'){ e.preventDefault(); const id = createNote(''); openNote(id); }
      if((e.metaKey||e.ctrlKey) && e.key===','){ e.preventDefault(); dlgSettings.open?dlgSettings.close():dlgSettings.showModal(); }
      if((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==='p'){ e.preventDefault(); window.print(); }
      
      // Font size controls
      if((e.metaKey||e.ctrlKey) && (e.key==='=' || e.key==='+')){ e.preventDefault(); increaseFontSize(); }
      if((e.metaKey||e.ctrlKey) && e.key==='-'){ e.preventDefault(); decreaseFontSize(); }
      if((e.metaKey||e.ctrlKey) && e.key==='0'){ e.preventDefault(); setFontSize(10); } // Reset to default
    });

    // ===== Cross-tab sync & Unload =====
    window.addEventListener('beforeunload', (e) => {
      if (isDirty) {
        doSave(); // Garante que o último estado seja salvo antes de sair
        e.preventDefault();
        e.returnValue = 'Você tem alterações não salvas. Deseja sair?';
      }
    });
    window.addEventListener('storage', (e)=>{
      if (e.key === INDEX_KEY || (e.key && e.key.startsWith('note:'))) {
        if (dlgNotes.open) buildNotesList();
        if (currentId && e.key === NOTE_KEY(currentId) && document.activeElement !== editor) {
          const item = loadNote(currentId);
          if (item && editor.value !== item.text) { editor.value = item.text || ''; updateAllMeta(); isDirty = false; updateDocTitle(); }
        }
      }
      if (e.key === SETTINGS_KEY) restoreSettings();
    });

    // ===== Init =====
    (function init(){
      restoreSettings();
      // Inicializar progresso visual dos ranges
      updateRangeProgress(fontSize, parseInt(fontSize.value), 8, 24);
      updateRangeProgress(lineHeight, parseFloat(lineHeight.value), 1.3, 1.9);
      updateRangeProgress(padX, parseInt(padX.value), 8, 40);
      
      // ResizeObserver para invalidar medições no modo wrap
      const ro = new ResizeObserver(() => {
        invalidateWrapMetrics();
        if (linesVisible) renderGutter(true);
        updateMinimap(true);
      });
      ro.observe(editor);
      
      // carregar nota atual ou criar
      const idx = loadIndex(); let id = getCurrentId(); if(!id){ id = idx[0]?.id; } if(!id){ id = createNote(''); }
      openNote(id);

      setInterval(updateLastSavedTime, 5000);
      
      // garantir sync do more-menu no init
      syncMenuChecks?.();
    })();

    // ===== Title Editing =====
    function startTitleEditOn(targetEl) {
      // targetEl: noteTitleEl (footer) OU noteTitleChip (appbar)
      if (!targetEl || targetEl.querySelector('input')) return;

      // título atual
      const idx = loadIndex();
      const meta = idx.find(n => n.id === currentId);
      if (!meta) return;

      const currentTitle = meta.title;
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentTitle;
      input.className = 'title-editor';
      input.setAttribute('aria-label','Título da nota');

      if (targetEl === noteTitleChip) {
        // limpar chip e embutir input
        targetEl.innerHTML = '';
        targetEl.appendChild(input);
      } else {
        // footer
        targetEl.innerHTML = '';
        targetEl.appendChild(input);
      }

      input.focus();
      input.select();

      const finish = (confirm) => {
        input.removeEventListener('blur', onBlur);
        input.removeEventListener('keydown', onKeydown);
        if (confirm && input.value.trim()) {
          finishTitleEdit(input.value.trim());
        } else {
          // restaura visual se cancelar
          if (noteTitleEl) noteTitleEl.textContent = meta.title;
          if (noteTitleChip && noteTitleChipText) {
            noteTitleChip.innerHTML = `
              <svg class="ticon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 20h4l10-10a2.828 2.828 0 0 0-4-4L4 16v4z"></path><path d="M13.5 6.5l4 4"/></svg>
              <span id="noteTitleChipText">${meta.title}</span>`;
          }
        }
      };

      const onBlur = () => finish(true);
      const onKeydown = (e) => {
        if (e.key === 'Enter') { e.preventDefault(); finish(true); }
        else if (e.key === 'Escape') { e.preventDefault(); finish(false); }
      };

      input.addEventListener('blur', onBlur);
      input.addEventListener('keydown', onKeydown);
    }

    function startTitleEdit() { startTitleEditOn(noteTitleEl); } // compat
    noteTitleEl.addEventListener('dblclick', startTitleEdit);
    noteTitleChip?.addEventListener('dblclick', () => startTitleEditOn(noteTitleChip));

    function finishTitleEdit(newTitle) {
      const idx = loadIndex();
      const meta = idx.find(n => n.id === currentId);
      if (!meta) {
        if (noteTitleEl) noteTitleEl.textContent = '—';
        if (noteTitleChipText) noteTitleChipText.textContent = '—';
        return;
      }

      if (newTitle) {
        meta.title = newTitle;
        meta.updatedAt = nowISO();

        // atualizar index (move pro topo)
        let index = loadIndex();
        let noteIndex = index.findIndex(n => n.id === currentId);
        if (noteIndex > -1) {
          index[noteIndex] = meta;
          index.splice(noteIndex, 1);
          index.unshift(meta);
          saveIndex(index);
        }

        if (noteTitleEl) noteTitleEl.textContent = meta.title;
        if (noteTitleChip) {
          noteTitleChip.innerHTML = `
            <svg class="ticon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 20h4l10-10a2.828 2.828 0 0 0-4-4L4 16v4z"></path><path d="M13.5 6.5l4 4"/></svg>
            <span id="noteTitleChipText">${meta.title}</span>`;
        }

        updateDocTitle();
        if (dlgNotes.open) buildNotesList();
        lastSaveTime = new Date();
        updateLastSavedTime();
      } else {
        // Restore original title on cancel
        if (noteTitleEl) noteTitleEl.textContent = meta.title;
        if (noteTitleChip) {
          noteTitleChip.innerHTML = `
            <svg class="ticon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 20h4l10-10a2.828 2.828 0 0 0-4-4L4 16v4z"></path><path d="M13.5 6.5l4 4"/></svg>
            <span id="noteTitleChipText">${meta.title}</span>`;
        }
      }
    }

    noteTitleEl.addEventListener('dblclick', startTitleEdit);
    window.addEventListener('keydown', e => {
        if (e.key === 'F2' && document.activeElement.tagName.toLowerCase() !== 'textarea') {
            e.preventDefault();
            startTitleEdit();
        }
    });

    // ===== Find & Replace Logic - Enhanced =====
    let findMatches = [];
    let findIdx = 0;
    let replaceMode = false;

    function openFindBar(withReplace = false) {
      findBar.hidden = false;
      
      // Set replace mode
      replaceMode = withReplace;
      replaceRow.hidden = !replaceMode;
      btnToggleReplace.setAttribute('aria-pressed', String(replaceMode));
      
      // Pre-fill with selection if any
      const selection = editor.value.substring(editor.selectionStart, editor.selectionEnd);
      if (selection && selection.indexOf('\n') === -1) { // Single line selection only
        findInput.value = selection;
      }
      
      findInput.focus();
      findInput.select();
      computeFind();
      
      // Update global search state
      const gs = document.getElementById('globalSearch');
      if (gs) {
        gs.setAttribute('aria-expanded','true');
        gs.value = findInput.value; // Sync values
      }
    }

    function closeFindBar() {
      findBar.hidden = true;
      replaceMode = false;
      const gs = document.getElementById('globalSearch');
      if (gs) {
        gs.setAttribute('aria-expanded','false');
        gs.value = ''; // Clear global search
      }
      editor.focus();
      clearFindDecorations();
    }

    function toggleReplaceMode() {
      replaceMode = !replaceMode;
      replaceRow.hidden = !replaceMode;
      btnToggleReplace.setAttribute('aria-pressed', String(replaceMode));
      
      if (replaceMode) {
        replaceInput.focus();
      } else {
        findInput.focus();
      }
    }

    // Option button handlers - updated for new structure
    function toggleOption(optionName, button) {
      findOptions[optionName] = !findOptions[optionName];
      button.setAttribute('aria-pressed', String(findOptions[optionName]));
      computeFind(); // Recompute with new options
    }

    function computeFind() {
      clearTimeout(computeFind._t);
      computeFind._t = setTimeout(() => {
        const q = findInput.value;
        if (!q) {
          findMatches = [];
          findCount.textContent = '0/0';
          clearFindDecorations();
          return;
        }
        
        try {
          const flags = findOptions.case ? 'g' : 'gi';
          const src = findOptions.regex ? q : q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const re = new RegExp(src, findOptions.multiline ? flags + 'm' : flags);
          const text = editor.value;
          findMatches = [];
          let m;
          
          // Limite para evitar travamento em textos muito grandes
          const maxMatches = 10000;
          while ((m = re.exec(text)) && findMatches.length < maxMatches) {
            findMatches.push({ start: m.index, end: m.index + m[0].length });
            if (m.index === re.lastIndex) re.lastIndex++; // avoid zero-length loops
          }
          
          if (findMatches.length >= maxMatches) {
            findCount.textContent = `${maxMatches}+ resultados`;
          } else {
            findIdx = Math.min(findIdx, findMatches.length - 1);
            updateFindCount();
          }
          
          highlightViewportHits();
          
          // Auto-scroll to first match if we have results
          if (findMatches.length > 0 && findIdx < 0) {
            findIdx = 0;
            goToHit(0);
          }
          
        } catch (e) {
          // Invalid regex - show error in count
          if (findOptions.regex) {
            findCount.textContent = 'Regex inválida';
            findMatches = [];
            clearFindDecorations();
          }
        }
      }, 150);
    }

    function updateFindCount() {
      if (findMatches.length === 0) {
        findCount.textContent = '0/0';
      } else {
        const current = Math.max(0, findIdx) + 1;
        findCount.textContent = `${current}/${findMatches.length}`;
      }
    }

    // Smart positioning for find bar to avoid covering current match
    function repositionFindBar() {
      if (findBar.hidden || findMatches.length === 0) return;
      
      const currentMatch = findMatches[findIdx];
      if (!currentMatch) return;
      
      // Calculate line position of current match
      const textBefore = editor.value.substring(0, currentMatch.start);
      const matchLine = textBefore.split('\n').length;
      const lineHeight = parseFloat(getComputedStyle(editor).lineHeight);
      const matchY = (matchLine - 1) * lineHeight - editor.scrollTop;
      
      // If match is in top area where findbar might cover it, move findbar down
      if (matchY < 120 && window.innerWidth > 640) {
        findBar.style.top = '120px';
      } else {
        findBar.style.top = '12px';
      }
    }

    // Integra o campo de busca global com a Find Bar - enhanced
    const globalSearch = document.getElementById('globalSearch');
    if (globalSearch) {
      globalSearch.addEventListener('focus', () => {
        openFindBar(false);
      });
      
      globalSearch.addEventListener('input', () => {
        if (findBar.hidden) openFindBar(false);
        findInput.value = globalSearch.value || '';
        computeFind();
      });
      
      // Clear global search when find bar closes
      globalSearch.addEventListener('blur', () => {
        if (findBar.hidden) {
          globalSearch.value = '';
        }
      });
    }

    function goToHit(i) {
      if (!findMatches.length) return;
      findIdx = (i + findMatches.length) % findMatches.length;
      const hit = findMatches[findIdx];
      editor.selectionStart = hit.start;
      editor.selectionEnd = hit.end;
      
      // Better scrolling - position match in center of viewport
      const textBefore = editor.value.substring(0, hit.start);
      const linesBefore = textBefore.split('\n').length;
      const lineHeight = parseFloat(getComputedStyle(editor).lineHeight);
      const editorHeight = editor.clientHeight;
      const targetScrollTop = Math.max(0, (linesBefore - Math.floor(editorHeight / lineHeight / 2)) * lineHeight);
      editor.scrollTop = targetScrollTop;
      
      updateFindCount();
      highlightViewportHits();
      repositionFindBar(); // Smart repositioning
    }

    // Replace functions - enhanced with better feedback
    function replaceOne() {
      if (!findMatches.length || findIdx < 0 || findIdx >= findMatches.length) {
        showToast('Nenhum resultado para substituir', 'info');
        return;
      }
      
      const hit = findMatches[findIdx];
      if (!hit) return;
      
      const repl = replaceInput.value;
      const v = editor.value;
      editor.value = v.slice(0, hit.start) + repl + v.slice(hit.end);
      editor.selectionStart = hit.start;
      editor.selectionEnd = hit.start + repl.length;
      editor.dispatchEvent(new Event('input'));
      scheduleSave();
      updateAllMeta();
      
      // Recompute and try to maintain position
      const oldIdx = findIdx;
      computeFind();
      
      // Advance to next match if available
      if (findMatches.length > 0) {
        findIdx = Math.min(oldIdx, findMatches.length - 1);
        if (findIdx >= 0) goToHit(findIdx);
      }
      
      showToast('Texto substituído', 'success');
    }

    function replaceAll() {
      if (!findMatches.length) {
        showToast('Nenhum resultado para substituir', 'info');
        return;
      }
      
      const repl = replaceInput.value;
      const q = findInput.value;
      const originalCount = findMatches.length;
      
      try {
        const flags = findOptions.case ? 'g' : 'gi';
        const src = findOptions.regex ? q : q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const re = new RegExp(src, findOptions.multiline ? flags + 'm' : flags);
        
        const oldValue = editor.value;
        editor.value = oldValue.replace(re, repl);
        
        if (editor.value !== oldValue) {
          editor.dispatchEvent(new Event('input'));
          scheduleSave();
          updateAllMeta();
          computeFind();
          showToast(`${originalCount} substituições realizadas`, 'success');
        } else {
          showToast('Nenhuma substituição realizada', 'info');
        }
      } catch (e) {
        console.error('Replace error:', e);
        showToast('Erro na substituição', 'error');
      }
    }

    // Clear replacement highlights (placeholder function)
    function clearReplacementHighlights() {
      // This function can be expanded later if needed
      // For now, it's just a placeholder to prevent errors
    }

    // Initialize find bar event listeners - updated for new structure
    function initializeFindBarEvents() {
        // Button click handlers
        btnFindNext.onclick = () => goToHit(findIdx + 1);
        btnFindPrev.onclick = () => goToHit(findIdx - 1);
        btnFindClose.onclick = closeFindBar;
        btnDoReplace.onclick = replaceOne;
        btnDoReplaceAll.onclick = replaceAll;
        btnToggleReplace.onclick = toggleReplaceMode;
        
        // Option button toggles - updated class names
        optRegex.onclick = () => toggleOption('regex', optRegex);
        optCase.onclick = () => toggleOption('case', optCase);
        optMultiline.onclick = () => toggleOption('multiline', optMultiline);
        
        // Input event listeners
        findInput.addEventListener('input', () => {
          computeFind();
          // Sync with global search
          const gs = document.getElementById('globalSearch');
          if (gs) gs.value = findInput.value;
        });
        
        replaceInput.addEventListener('input', () => {
            clearReplacementHighlights();
        });
        
        // Enhanced keyboard shortcuts for find bar
        findInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.shiftKey) {
                    goToHit(findIdx - 1);
                } else {
                    goToHit(findIdx + 1);
                }
            } else if (e.key === 'Escape') {
                closeFindBar();
            } else if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'h') {
                e.preventDefault();
                if (!replaceMode) toggleReplaceMode();
            }
        });
        
        replaceInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.ctrlKey || e.metaKey) {
                    replaceAll();
                } else {
                    replaceOne();
                }
            } else if (e.key === 'Escape') {
                closeFindBar();
            }
        });
    }
    
    // Call initialization
    initializeFindBarEvents();

    function highlightViewportHits() {
      if (!findMatches.length) { 
        highlights.innerHTML = ''; 
        return; 
      }

      const scrollTop = editor.scrollTop;
      const lineH = parseFloat(getComputedStyle(editor).lineHeight);
      const lines = editor.value.split('\n');

      // Calculate viewport range with optimized buffer
      const linesPerView = Math.ceil(editor.clientHeight / lineH);
      const bufferLines = Math.min(50, Math.max(10, Math.floor(linesPerView * 0.5))); // Adaptive buffer
      const currentTopLine = Math.max(0, Math.floor(scrollTop / lineH) - bufferLines);
      const endLine = Math.min(lines.length, currentTopLine + linesPerView + (bufferLines * 2));

      const startChar = lines.slice(0, currentTopLine).join('\n').length + (currentTopLine ? 1 : 0);
      const endChar = lines.slice(0, endLine).join('\n').length;

      // Filter matches that are actually visible
      const visibleMatches = findMatches.filter(m => 
        m.start < endChar && m.end > startChar
      );

      // Early exit if no visible matches
      if (visibleMatches.length === 0) {
        const padTopPx = currentTopLine * lineH;
        const padBottomPx = Math.max(0, (lines.length - endLine) * lineH);
        highlights.innerHTML = `<div style="height:${padTopPx}px"></div><div style="height:${padBottomPx}px"></div>`;
        return;
      }

      const visible = editor.value.slice(startChar, endChar);
      let html = '';
      let last = 0;
      
      // Process visible matches efficiently
      visibleMatches.forEach(m => {
        const s = Math.max(0, m.start - startChar);
        const e = Math.min(visible.length, m.end - startChar);
        if (s > last) html += escapeHtml(visible.slice(last, s));
        const isCurrent = (m === findMatches[findIdx]);
        html += `<mark class="${isCurrent ? 'find-hit current' : 'find-hit'}">${escapeHtml(visible.slice(s, e))}</mark>`;
        last = e;
      });
      html += escapeHtml(visible.slice(last));

      const padTopPx = currentTopLine * lineH;
      const padBottomPx = Math.max(0, (lines.length - endLine) * lineH);
      highlights.innerHTML = `<div style="height:${padTopPx}px"></div>${html}<div style="height:${padBottomPx}px"></div>`;
    }

    function clearFindDecorations() {
      highlights.innerHTML = '';
    }

    function escapeHtml(str) {
      return str.replace(/[&<>"']/g, (match) => {
        switch (match) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '"': return '&quot;';
          case "'": return '&#39;';
          default: return match;
        }
      });
    }

    // Enhanced keyboard handling
    findInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (e.shiftKey) {
          goToHit(findIdx - 1);
        } else {
          goToHit(findIdx + 1);
        }
      }
      if (e.key === 'Escape') {
        e.preventDefault();
        closeFindBar();
      }
    });

    replaceInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (e.ctrlKey || e.metaKey) {
          btnDoReplaceAll.click();
        } else {
          btnDoReplace.click();
        }
      }
      if (e.key === 'Escape') {
        e.preventDefault();
        closeFindBar();
      }
    });

    // Global keyboard shortcuts - enhanced for new findbar
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        openFindBar(false);
      }
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'h') {
        e.preventDefault();
        openFindBar(true); // Open directly in replace mode
      }
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'g') {
        e.preventDefault();
        openGoToLine();
      }
      if ((e.metaKey || e.ctrlKey) && e.key === '/') {
        e.preventDefault();
        dlgHelp.showModal(); focusTrap(dlgHelp);
      }
      if (e.key === 'Escape' && !findBar.hidden) {
        e.preventDefault();
        closeFindBar();
      }
      
      // Enhanced navigation when find bar is open
      if (!findBar.hidden && findMatches.length > 0) {
        if (e.key === 'F3' || (e.key === 'Enter' && document.activeElement !== findInput && document.activeElement !== replaceInput)) {
          e.preventDefault();
          if (e.shiftKey) {
            goToHit(findIdx - 1);
          } else {
            goToHit(findIdx + 1);
          }
        }
      }
    });

    // ===== Go To Line =====
    function openGoToLine() {
        goToLine.hidden = false;
        goToLineInput.focus();
        goToLineInput.select();
    }

    function closeGoToLine() {
        goToLine.hidden = true;
        goToLineInput.value = '';
        editor.focus();
    }
    function executeGoToLine() {
        const lineNum = parseInt(goToLineInput.value || '1', 10);
        const totalLinesCount = totalLines();
        
        if (isNaN(lineNum) || lineNum < 1 || lineNum > totalLinesCount) {
          // Animação de shake para número inválido
          goToLine.classList.add('shake');
          setTimeout(() => goToLine.classList.remove('shake'), 500);
          goToLineInput.select();
          return;
        }
        
        scrollLineIntoView(lineNum, 'center'); // Usar lineNum diretamente (1-based)
        selectLineRange(lineNum, lineNum); // Usar lineNum diretamente (1-based)
        goToLine.hidden = true;
        goToLineInput.value = '';
    }

    // Event listeners para os botões
    btnGoToLineExecute.addEventListener('click', executeGoToLine);
    btnGoToLineClose.addEventListener('click', closeGoToLine);
    
    goToLineInput.addEventListener('blur', closeGoToLine);

    // ===== Footer clicável + "Ir para linha" =====
    // Footer: clicar em Ln/Col abre "Ir para linha"
    lnCol.style.cursor = 'pointer';
    lnCol.title = 'Ir para linha (⌘/Ctrl + G)';
    lnCol.addEventListener('click', () => {
      goToLine.hidden = false;
      goToLineInput.value = '';
      goToLineInput.focus();
    });

    // Atalho global (Cmd/Ctrl+G) - já existe mas vou melhorar
    // Confirmar "Ir para..." - melhorar o goToLineInput
    goToLineInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault(); // Impede que o Enter se propague para o editor
        executeGoToLine();
      } else if (e.key === 'Escape') {
        e.preventDefault(); // Impede que o Escape se propague
        closeGoToLine();
      }
    });

    // ===== Selection Stats =====
    let selectionTimeout = null;
    function updateSelectionStats() {
        clearTimeout(selectionTimeout);
        selectionTimeout = setTimeout(() => {
            const selection = editor.value.substring(editor.selectionStart, editor.selectionEnd);
            if (selection) {
                const charCount = selection.length;
                const wordCount = selection.trim().split(/\s+/).filter(Boolean).length;
                selectionStats.textContent = `Sel: ${charCount} chars • ${wordCount} palavras`;
                selectionStats.hidden = false;
                selectionSep.hidden = false;
                
                // Mostrar banda de seleção se múltiplas linhas
                const selStart = editor.selectionStart, selEnd = editor.selectionEnd;
                if (selStart !== selEnd) {
                  const a = getPhysicalLineFromPosition(selStart);
                  const b = getPhysicalLineFromPosition(selEnd);
                  showSelectionBand(a, b);
                } else {
                  clearSelectionBand();
                }
            } else {
                selectionStats.hidden = true;
                selectionSep.hidden = true;
                clearSelectionBand();
            }
        }, 50);
    }


    document.addEventListener('selectionchange', updateSelectionStats);
    editor.addEventListener('keyup', updateSelectionStats);
    editor.addEventListener('mouseup', updateSelectionStats);


    // ===== Theme Switcher =====

    function applyTheme(theme) {
        if (theme === 'auto') {
            document.documentElement.dataset.theme = lightScheme.matches ? 'light' : 'dark';
        } else {
            document.documentElement.dataset.theme = theme;
        }
    }

    function setTheme(theme) {
        currentTheme = theme;
        
        // Update button styles - only if themeSwitcher is available
        const themeSwitcher = document.getElementById('themeSwitcher');
        if (themeSwitcher) {
            themeSwitcher.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('btn-active', btn.dataset.themeValue === theme);
                btn.setAttribute('aria-pressed', btn.dataset.themeValue === theme);
            });
        }
        
        applyTheme(theme);
        persistSettings();
    }

    // Initialize theme switcher event listener
    const themeSwitcher = document.getElementById('themeSwitcher');
    if (themeSwitcher) {
        themeSwitcher.addEventListener('click', e => {
            const target = e.target.closest('button');
            if (target && target.dataset.themeValue) {
                setTheme(target.dataset.themeValue);
            }
        });
    }

    lightScheme.addEventListener('change', () => {
        if (currentTheme === 'auto') {
            applyTheme('auto');
        }
    });

    // ===== Clean and Stable Drag & Drop System =====
    let isDraggingFiles = false;
    let dragLeaveTimeout = null;

    // Check if drag event contains files
    function hasFiles(e) {
        if (!e.dataTransfer) return false;
        
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) return true;
        if (e.dataTransfer.items) {
            for (let i = 0; i < e.dataTransfer.items.length; i++) {
                if (e.dataTransfer.items[i].kind === 'file') return true;
            }
        }
        
        if (e.dataTransfer.types) {
            return e.dataTransfer.types.includes('Files');
        }
        
        return false;
    }

    function showDropzone() {
        if (!isDraggingFiles) {
            isDraggingFiles = true;
            dropzone.removeAttribute('hidden');
            // Use a small delay to ensure smooth animation
            requestAnimationFrame(() => {
                dropzone.classList.add('show');
            });
        }
        clearTimeout(dragLeaveTimeout);
    }

    function hideDropzone() {
        clearTimeout(dragLeaveTimeout);
        dragLeaveTimeout = setTimeout(() => {
            if (isDraggingFiles) {
                isDraggingFiles = false;
                dropzone.classList.remove('show');
                // Hide after animation completes
                setTimeout(() => {
                    dropzone.setAttribute('hidden', '');
                }, 250);
            }
        }, 100);
    }

    // Simplified drag handlers
    document.addEventListener('dragenter', (e) => {
        if (hasFiles(e)) {
            e.preventDefault();
            showDropzone();
        }
    });

    document.addEventListener('dragleave', (e) => {
        // Only hide if we're leaving the window
        if (!e.relatedTarget || e.relatedTarget.nodeName === 'HTML') {
            hideDropzone();
        }
    });

    document.addEventListener('dragover', (e) => {
        if (isDraggingFiles) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }
    });

    document.addEventListener('drop', (e) => {
        e.preventDefault();
        
        // Immediately hide dropzone
        isDraggingFiles = false;
        clearTimeout(dragLeaveTimeout);
        dropzone.classList.remove('show');
        setTimeout(() => {
            dropzone.setAttribute('hidden', '');
        }, 250);

        // Process files
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            const file = e.dataTransfer.files[0];
            
            // Validate file type
            const validExtensions = ['.txt', '.md', '.markdown'];
            const validMimeTypes = ['text/plain', 'text/markdown', 'text/x-markdown'];
            
            const fileName = file.name.toLowerCase();
            const fileType = file.type.toLowerCase();
            
            const isValidExtension = validExtensions.some(ext => fileName.endsWith(ext));
            const isValidMimeType = validMimeTypes.includes(fileType);
            
            if (isValidExtension || isValidMimeType || fileType.startsWith('text/')) {
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    try {
                        const newNoteId = createNote(event.target.result);
                        openNote(newNoteId);
                        
                        // Update note title
                        let idx = loadIndex();
                        let meta = idx.find(n => n.id === newNoteId);
                        if (meta) {
                            const nameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
                            meta.title = nameWithoutExt || file.name;
                            meta.updatedAt = nowISO();
                            saveIndex(idx);
                            noteTitleEl.textContent = meta.title;
                            updateDocTitle();
                        }
                        
                        showToast(`Arquivo "${file.name}" carregado`, 'success');
                        
                    } catch (error) {
                        console.error('Error reading file:', error);
                        showToast('Erro ao ler o arquivo', 'error');
                    }
                };
                
                reader.onerror = () => {
                    showToast('Erro ao ler o arquivo', 'error');
                };
                
                reader.readAsText(file);
                
            } else {
                showToast('Tipo de arquivo não suportado', 'error');
            }
        }
    });

    // Prevent default behaviors and ensure clean state
    window.addEventListener('dragend', () => {
        hideDropzone();
    });

    window.addEventListener('focus', () => {
        if (isDraggingFiles) {
            hideDropzone();
        }
    });

    // Enhanced Toast notification system (Liquid Glass Kit) — corrigido
    function showToast(message, type = 'info', timeout = 4000){
      // remove toasts existentes
      document.querySelectorAll('.glass-toast').forEach(t => t.remove());
      const toast = document.createElement('div');
      toast.className = `glass-toast ${type}`;
      toast.setAttribute('role','status');
      toast.setAttribute('aria-live','polite');
      toast.textContent = message;
      document.body.appendChild(toast);
      // animação de entrada
      requestAnimationFrame(() => toast.classList.add('show'));
      // saída automática
      const hide = () => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 420);
      };
      const id = setTimeout(hide, timeout);
      // saída manual
      toast.addEventListener('click', () => {
        clearTimeout(id);
        hide();
      });
      return toast;
    }

    // Prevent default drag behaviors on the document
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.addEventListener(eventName, e => {
            // Only prevent default for non-editor elements to allow text drag/drop in editor
            if (e.target !== editor && !editor.contains(e.target)) {
                e.preventDefault();
                e.stopPropagation();
            }
        });
    });

    // Safety net: se o dropzone ficou aberto, fecha ao focar a janela
    window.addEventListener('focus', () => {
      if (isDraggingFiles) {
        isDraggingFiles = false;
        dropzone.classList.remove('show');
        dropzone.setAttribute('hidden', '');
      }
    });
      // ===== Correção: Fechar modais ao clicar no X ou fora =====
      function setupDialogClose(dialogId) {
        const dlg = document.getElementById(dialogId);
        if (!dlg) return;
        // Botão X
        dlg.querySelector('.sheet-close')?.addEventListener('click', () => {
          dlg.close();
        });
        // Clique fora do modal
        dlg.addEventListener('click', (e) => {
          if (e.target === dlg) {
            dlg.close();
          }
        });
        // Tecla ESC
        dlg.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            dlg.close();
          }
        });
      }

      setupDialogClose('settings');
      setupDialogClose('help');
      setupDialogClose('notes');
  </script>
</body>
</html>
