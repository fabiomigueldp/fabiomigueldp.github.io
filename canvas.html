<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Canvas de Texto — Editor v3</title>
  <!-- Importar DM Sans para UI -->
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,300;400;600;800&display=swap" rel="stylesheet">
  <style>
    /* ======= FASE 0: Fundamentos - Bridge Tokens ======= */
    :root{
      color-scheme: dark;
      --bg:#0b0b0d; --bg-2:#0f1013;
      --panel:rgba(255,255,255,.06); --panel-strong:rgba(255,255,255,.10);
      --stroke:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92); --text-dim:rgba(255,255,255,.70); --text-muted:rgba(255,255,255,.55);
      --accent:#0A84FF; --accent-2:#5E5CE6;
      --dur:.25s; --ease:cubic-bezier(.2,.7,.2,1);
      --code-font: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "DejaVu Sans Mono", "Courier New", monospace;
      --font-size:14px; --editor-font-size:10px; --line-height:1.55; --editor-padding: clamp(8px, 1.5vw, 16px); --tab-size:2;
      --gutter-w:48px; --mini-w:120px;
      
      /* Bridge tokens para o Kit Liquid Glass */
      --c-bg: var(--bg);
      --c-content: var(--text);
      --c-action: var(--accent);
      --c-glass: color-mix(in oklab, var(--bg), white 60%);
      --c-light: #fff;
      --c-dark: #000;
      --glass-reflex-dark: 1;
      --glass-reflex-light: 1;
      --saturation: 150%;
      --fz: 14px;
      
      /* LiquidGlass tuning original mantido para compatibilidade */
      --lg-blur:clamp(12px, 1.2vw, 22px); 
      --lg-sat:clamp(120%, 10%, 160%); 
      --lg-contrast:clamp(1, 0.02, 1.08); 
      --lg-highlight:rgba(255,255,255,.45);
      --lg-highlight-strong:rgba(255,255,255,.65);
      --lg-highlight-subtle:rgba(255,255,255,.25);
      --lg-edge:rgba(255,255,255,.20); 
      --lg-edge-dark:rgba(0,0,0,.35);
      --lg-reflex-light:1; --lg-reflex-dark:1;
      
      /* Font principal DM Sans para UI */
      font-family: "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    html[data-theme="light"] {
      color-scheme: light;
      --bg:#f3f3f8; --bg-2:#e9e9f0;
      --panel:rgba(0,0,0,.04); --panel-strong:rgba(0,0,0,.08);
      --stroke:rgba(0,0,0,.10);
      --text:rgba(0,0,0,.88); --text-dim:rgba(0,0,0,.65); --text-muted:rgba(0,0,0,.45);
      --accent:#007AFF; --accent-2:#5856D6;
      
      /* Bridge tokens para modo claro */
      --c-bg: var(--bg);
      --c-content: var(--text);
      --c-action: var(--accent);
      --c-glass: color-mix(in oklab, var(--bg), white 60%);
      --saturation: 100%;
      
      /* LiquidGlass tuning for light mode */
      --lg-blur:clamp(14px, 1.4vw, 22px); 
      --lg-sat:clamp(100%, 10%, 130%); 
      --lg-contrast:clamp(1, 0.02, 1.05); 
      --lg-highlight:rgba(255,255,255,.75);
      --lg-highlight-strong:rgba(255,255,255,.95);
      --lg-highlight-subtle:rgba(255,255,255,.45);
      --lg-edge:rgba(255,255,255,.65); 
      --lg-edge-dark:rgba(0,0,0,.15);
    }
    body {
        transition: background var(--dur) var(--ease), color var(--dur) var(--ease);
    }
    @media (prefers-reduced-motion: reduce){ :root{ --dur:0s } *{ animation:none!important; transition:none!important } }

    /* ======= Componentes Liquid Glass Kit ======= */
    /* Estilo base "LIQUID GLASS" */
    .glass-ui {
        position: relative; display: inline-flex; align-items: center; justify-content: center;
        border: none; cursor: pointer; isolation: isolate;
        transition: all 250ms cubic-bezier(0.5, 0, 0, 1);
        background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
        backdrop-filter: blur(12px) saturate(var(--saturation));
        -webkit-backdrop-filter: blur(12px) saturate(var(--saturation));
        box-shadow:
            inset 0 0 0 1.5px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent),
            inset 1.8px 3px 0 -2px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 90%), transparent),
            inset -2px -2px 0 -2px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 80%), transparent),
            inset -3px -8px 1px -6px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 60%), transparent),
            inset -0.3px -1px 4px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent),
            inset -1.5px 2.5px 0 -2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 20%), transparent),
            inset 0 3px 4px -2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 20%), transparent),
            inset 2px -6.5px 1px -4px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
            0 1px 5px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
            0 6px 16px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 8%), transparent);
    }
    .glass-ui:focus-visible { 
        outline: 2px solid var(--c-action);
        outline-offset: 4px;
    }

    /* ===== TOOLBAR: unified toolbar (HIG-aligned) ===== */
    .header-toolbar{
      position: sticky; top: 0; z-index: 1000;
      /* padding horizontal consistente com a grade do app */
      padding: max(0px, env(safe-area-inset-top)) clamp(16px, 4vw, 32px) 0;
      backdrop-filter: none; /* o cristal fica na .toolbar */
    }

    /* Base da toolbar */
    .toolbar{
      --tb-h: 48px;
      --tb-gap: 8px;
      --tb-pad-x: 8px;
      --tb-radius: 14px;
      position: relative;
      display: flex; align-items: center; gap: var(--tb-gap);
      padding: 6px var(--tb-pad-x);
      border-radius: var(--tb-radius);
      background-color: color-mix(in srgb, var(--c-glass) 10%, transparent);
      backdrop-filter: blur(10px) saturate(var(--saturation));
      -webkit-backdrop-filter: blur(10px) saturate(var(--saturation));
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 0 0 1px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 8%), transparent),
        inset 1.2px 2px 0 -1px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 70%), transparent),
        inset -1px -1px 0 -1px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 15%), transparent),
        0 6px 16px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 8%), transparent);
      transition: background-color 400ms cubic-bezier(1,0,0.4,1), box-shadow 400ms cubic-bezier(1,0,0.4,1), border-color 400ms cubic-bezier(1,0,0.4,1);
    }

    /* === MODO UNIFICADO (recomendado) === */
    .toolbar--attached{
      /* mantém cantos arredondados para integração visual suave */
      border-radius: var(--tb-radius) !important;
      border-top: 1px solid color-mix(in srgb, var(--c-light) 8%, transparent);
      /* hairline na base, sombras reduzidas mas com profundidade sutil */
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 8%, transparent),
        0 2px 8px color-mix(in srgb, var(--c-dark) 6%, transparent);
      background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
      margin: 8px 16px 0;
    }

    /* altura consistente e espaçamento vertical mínimo */
    .header-toolbar .toolbar{
      min-height: calc(var(--tb-h) + 8px);
      padding-top: 6px; padding-bottom: 6px;
    }

    /* Estado scrollado: deixa a base mais definida (feedback sutil) */
    .header-toolbar.is-scrolled .toolbar--attached{
      background-color: color-mix(in srgb, var(--c-glass) 85%, var(--c-bg-surface));
      backdrop-filter: blur(22px) saturate(1.4);
      border-radius: var(--tb-radius) !important;
      border-bottom-color: color-mix(in srgb, var(--c-light) 18%, transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 12%, transparent),
        0 2px 12px color-mix(in srgb, var(--c-dark) 8%, transparent),
        0 1px 3px color-mix(in srgb, var(--c-dark) 12%, transparent);
    }
    
    /* Backdrop mais intenso quando scrolled para melhor legibilidade */
    .header-toolbar.is-scrolled::after{
      background: linear-gradient(
        to bottom,
        var(--c-bg-surface) 0%,
        color-mix(in srgb, var(--c-bg-surface) 92%, transparent) 25%,
        transparent 65%
      );
      backdrop-filter: blur(16px) saturate(1.3);
      mask-image: linear-gradient(
        to bottom,
        black 0% 50%,
        transparent 80% 100%
      );
    }

    /* === MODO FLUTUANTE (opcional) === */
    .toolbar--floating{
      border-radius: var(--tb-radius) !important;
      margin-top: clamp(8px, 2vh, 14px);
      /* sombra mais pronunciada, já que é um "objeto" flutuando */
      box-shadow:
        0 8px 24px color-mix(in srgb, var(--c-dark) 20%, transparent),
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 50%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
    }

    /* Responsivo: em telas muito pequenas, reduz interno */
    @media (max-width: 480px){
      .header-toolbar .toolbar{ padding-left: 6px; padding-right: 6px; }
    }

    /* Grupos e espaçadores */
    .tgroup{ display:flex; align-items:center; gap:6px; }
    .tspacer{ flex:1; }

    /* Botão de toolbar */
    .tbtn{
      --hit: 36px;
      display:inline-flex; align-items:center; gap:8px; justify-content:center;
      height: var(--hit); padding: 0 12px; border-radius: 12px; cursor:pointer;
      color: var(--c-content); background: color-mix(in srgb, var(--c-glass) 14%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 45%), transparent),
        inset 0 -1px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
        0 1px 2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent);
      transition: transform 140ms ease, box-shadow 200ms ease, color 200ms ease, background-color 200ms ease, border-color 200ms ease;
      font: 600 12px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .tbtn:hover{ color: var(--c-action); transform: translateY(-1px); }
    .tbtn:active{ transform: translateY(0); }
    .tbtn:focus-visible{ outline: 2px solid color-mix(in srgb, var(--c-action) 60%, transparent); outline-offset: 2px; }
    .tbtn[disabled]{ opacity:.55; cursor:not-allowed; }
    .tbtn[aria-pressed="true"]{
      color: var(--c-light);
      background: linear-gradient(135deg, color-mix(in srgb, var(--c-action) 60%, transparent), color-mix(in srgb, var(--c-action) 25%, var(--c-dark)));
      border-color: color-mix(in srgb, var(--c-action) 40%, transparent);
    }

    /* Botão apenas ícone */
    .tbtn--icon{ width: var(--hit); padding:0; }
    
    /* ================= ICONES ================= */
    :root{
      /* mantém 20px como padrão global */
      --icon-size: 20px;
      --icon-stroke: 1.8; /* levemente >1.6 para legibilidade */
    }

    .ticon{
      width: var(--icon-size);
      height: var(--icon-size);
      display: block;
    }

    /* Para ícones desenhados em stroke */
    .ticon--stroke{
      stroke: currentColor;
      fill: none;
      stroke-width: var(--icon-stroke);
      stroke-linecap: round;
      stroke-linejoin: round;

      /* nitidez/espessura consistente em qualquer escala */
      vector-effect: non-scaling-stroke;
      shape-rendering: geometricPrecision;
    }

    /* Engrenagem: renderize na grade do viewBox p/ não "entortar" */
    #btnSettings .ticon{
      width: 20px;  /* mantém consistente com outros ícones */
      height: 20px;
      /* Para ícones fill-based da Radix UI */
      fill: currentColor;
      /* Melhora renderização em qualquer escala */
      shape-rendering: geometricPrecision;
    }

    /* Lápis do chip de título: garanta stroke correto e contraste */
    .title-chip .ticon{
      /* como o lápis vira stroke, fixe os atributos aqui */
      stroke: currentColor;
      fill: none;
      stroke-width: 1.6;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: .85; /* ligeiro boost sobre o .7 original */
    }

    /* Campo de busca */
    .tsearch{ position:relative; min-width: 240px; }
    .tsearch__input{
      height: var(--hit); width:100%;
      padding:0 12px 0 36px; border-radius:12px; border:1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      color: var(--c-content); background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 40%), transparent);
      outline:none;
      font-family: "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .tsearch__icon{ position:absolute; left:10px; top:50%; transform:translateY(-50%); width:18px; height:18px; opacity:.8; }

    /* Overflow popover */
    .popover{
      position:absolute; top: calc(100% + 8px); right: 8px; min-width: 220px; padding:8px;
      border-radius: 14px; z-index: 10;
      background: color-mix(in srgb, var(--c-glass) 22%, transparent);
      backdrop-filter: blur(10px) saturate(var(--saturation));
      -webkit-backdrop-filter: blur(10px) saturate(var(--saturation));
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 12%), transparent);
      box-shadow:
        0 10px 26px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 20%), transparent),
        inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 45%), transparent);
    }
    .popover[hidden]{ display:none; }
    .popover__item{ width:100%; }
    .popover__btn{ width:100%; justify-content:flex-start; }

    /* Toolbar acoplada deve ser STICKY (não fixed) para seguir o fluxo do header */
    .header-toolbar{
      position: sticky;
      top: 0;
      left: auto;
      right: auto;
      z-index: 1000;
      padding: max(0px, env(safe-area-inset-top)) clamp(8px, 2vw, 16px) 8px;
    }
    
    /* Backdrop elegante para "engolir" o conteúdo que passa por baixo */
    .header-toolbar::after{
      content: '';
      position: absolute;
      inset: 0;
      height: 200%;
      background: linear-gradient(
        to bottom,
        var(--c-bg-surface) 0%,
        color-mix(in srgb, var(--c-bg-surface) 85%, transparent) 30%,
        transparent 70%
      );
      backdrop-filter: blur(12px) saturate(1.2);
      mask-image: linear-gradient(
        to bottom,
        black 0% 45%,
        transparent 75% 100%
      );
      pointer-events: none;
      z-index: -1;
    }
    
    .toolbar--attached{
      /* mantém cantos arredondados para integração visual suave */
      border-radius: var(--tb-radius) !important;
      border-top: 1px solid color-mix(in srgb, var(--c-light) 8%, transparent);
      /* hairline na base, sombras reduzidas mas com profundidade sutil */
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 8%, transparent),
        0 2px 8px color-mix(in srgb, var(--c-dark) 6%, transparent);
      background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
      margin: 0;
      position: relative;
      z-index: 1;
    }

    /* ======= FASE 2: Ponte de compatibilidade para botões legados ======= */
    /* Mantém compatibilidade com .btn enquanto migra para .tbtn */
    .btn { 
      all: unset; 
      display:inline-flex; align-items:center; gap:6px;
      height:36px; padding:0 12px; border-radius:12px; cursor:pointer; 
      color: var(--c-content); background: color-mix(in srgb, var(--c-glass) 14%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 45%), transparent),
        inset 0 -1px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
        0 1px 2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent);
      transition: transform 140ms ease, box-shadow 200ms ease, color 200ms ease, background-color 200ms ease, border-color 200ms ease;
      font: 600 12px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .btn:hover{ color: var(--c-action); transform: translateY(-1px); }
    .btn[aria-pressed="true"]{
      color: var(--c-light);
      background: linear-gradient(135deg, color-mix(in srgb, var(--c-action) 60%, transparent), color-mix(in srgb, var(--c-action) 25%, var(--c-dark)));
      border-color: color-mix(in srgb, var(--c-action) 40%, transparent);
    }
    .btn-icon { width:36px; padding:0; }
    .btn svg { width:20px; height:20px; }

    /* Slider Kit com output flutuante */
    .glass-slider {
        -webkit-appearance: none; appearance: none;
        width: 100%; height: 24px; background: transparent;
        outline: none; cursor: pointer;
    }
    .glass-slider::-webkit-slider-runnable-track {
        width: 100%; height: 16px; border-radius: 99em; margin-top: 4px;
        background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
        box-shadow: inset 0 1px 2px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 15%), transparent),
                    inset 0 0 0 1.5px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 5%), transparent);
    }
    .glass-slider::-webkit-slider-thumb {
        -webkit-appearance: none; appearance: none;
        position: relative; width: 32px; height: 32px; border-radius: 50%;
        margin-top: -8px; z-index: 2;
        background-color: color-mix(in srgb, var(--c-glass) 36%, transparent);
        box-shadow:
            inset 0 0 0 1.5px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent),
            0 3px 6px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 15%), transparent);
        transition: transform 150ms ease;
    }
    .glass-slider:active::-webkit-slider-thumb { transform: scale(1.15); }
    .glass-slider:focus-visible { 
        outline: 2px solid var(--c-action);
        outline-offset: 4px;
    }

    .slider-with-output-container { position: relative; width: 80%; max-width: 300px; }
    .slider-output {
        position: absolute; bottom: 45px; min-width: 40px; padding: 6px 10px;
        border-radius: 8px; text-align: center;
        font-weight: 600; font-size: 0.9rem; transform: translateX(-50%);
        transition: opacity 200ms ease; opacity: 0; pointer-events: none;
        background-color: color-mix(in srgb, var(--c-glass) 12%, transparent);
        backdrop-filter: blur(12px) saturate(var(--saturation));
        -webkit-backdrop-filter: blur(12px) saturate(var(--saturation));
        color: var(--c-content);
    }
    .slider-with-output-container:hover .slider-output,
    .slider-with-output-container:has(:active) .slider-output { opacity: 1; }

    /* ======= Liquid Glass Kit Switches ======= */
    .glass-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.15);
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(8px) saturate(1.4);
    }

    .glass-switch:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.25);
    }

    .glass-switch input {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }

    .glass-switch .switch-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.8);
      transition: transform 0.2s ease, background 0.2s ease;
      backdrop-filter: blur(4px);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    .glass-switch input:checked + .switch-slider {
      transform: translateX(20px);
      background: var(--c-action);
    }

    .glass-switch input:focus + .switch-slider {
      outline: 2px solid var(--c-action);
      outline-offset: 2px;
    }

    .glass-switch input:disabled + .switch-slider {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .glass-switch:has(input:disabled) {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* ===== Sheets: unificação do material ===== */
    .dialog-sheet{
      --sheet-radius: 18px;
      --sheet-pad: 0;
      --sheet-blur: var(--lg-blur);
      --sheet-sat: var(--lg-sat);
      --sheet-ctr: var(--lg-contrast);

      padding: var(--sheet-pad);
      border-radius: var(--sheet-radius);
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      backdrop-filter: blur(var(--sheet-blur)) saturate(var(--sheet-sat)) contrast(var(--sheet-ctr));
      -webkit-backdrop-filter: blur(var(--sheet-blur)) saturate(var(--sheet-sat)) contrast(var(--sheet-ctr));
      border: 1px solid color-mix(in srgb, var(--c-light) 18%, transparent);
      box-shadow:
        inset 0 0 0 1px color-mix(in srgb, var(--c-light) 8%, transparent),
        0 20px 60px color-mix(in srgb, var(--c-dark) 35%, transparent),
        0 6px 20px color-mix(in srgb, var(--c-dark) 22%, transparent);
    }

    /* Backdrop consistente (sem "apagar" a UI) */
    dialog::backdrop{
      background: color-mix(in srgb, black 45%, transparent);
      -webkit-backdrop-filter: blur(2px);
      backdrop-filter: blur(2px);
    }

    /* Cabeçalho enxuto + hairline */
    .glass-panel-header{
      background: color-mix(in srgb, var(--c-glass) 10%, transparent);
      backdrop-filter: blur(10px) saturate(var(--saturation));
      -webkit-backdrop-filter: blur(10px) saturate(var(--saturation));
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      min-height: 44px;
      padding: 16px 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 600;
      font-size: 1.1em;
      color: var(--c-content);
    }

    /* Conteúdo com scroll-shadow (indica overflow) */
    .glass-panel-content{
      position: relative;
      mask-image: linear-gradient(to bottom, transparent 0, black 12px, black calc(100% - 12px), transparent 100%);
      padding: 20px;
      color: var(--c-content);
    }
    .glass-panel-content::before,
    .glass-panel-content::after{
      content:""; position: sticky; left:0; right:0; height:12px; pointer-events:none; z-index:2;
    }
    .glass-panel-content::before{ top:0;
      background: linear-gradient(to bottom, color-mix(in srgb, var(--c-dark) 18%, transparent), transparent);
    }
    .glass-panel-content::after{ bottom:0;
      background: linear-gradient(to top, color-mix(in srgb, var(--c-dark) 18%, transparent), transparent);
    }

    /* Rodapé: keyline superior e altura mínima */
    .glass-panel-footer{
      border-top: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      min-height: 44px;
      padding: 16px 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    /* Botões principais do sheet – alvos confortáveis */
    .glass-panel-footer .tbtn{ min-height: 32px; }

    /* Pequenas melhorias de foco */
    dialog .tbtn:focus-visible,
    dialog [role="tab"]:focus-visible,
    dialog input:focus-visible{
      outline: 2px solid color-mix(in srgb, var(--c-action) 60%, transparent);
      outline-offset: 2px;
      border-radius: 10px;
    }

    /* ======= Liquid Glass Kit Toasts ======= */
    .glass-toast {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      min-width: 280px;
      max-width: 400px;
      padding: 16px 20px;
      background: color-mix(in srgb, var(--c-glass) 15%, transparent);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      backdrop-filter: blur(20px) saturate(var(--saturation)) contrast(var(--contrast));
      -webkit-backdrop-filter: blur(20px) saturate(var(--saturation)) contrast(var(--contrast));
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.15),
        0 4px 16px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.25);
      color: var(--c-content);
      font-weight: 500;
      transform: translateX(120%);
      transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
    }

    .glass-toast.show {
      transform: translateX(0);
    }

    .glass-toast.success {
      border-color: rgba(52, 211, 153, 0.4);
      background: color-mix(in srgb, #34d399 8%, color-mix(in srgb, var(--c-glass) 15%, transparent));
    }

    .glass-toast.error {
      border-color: rgba(248, 113, 113, 0.4);
      background: color-mix(in srgb, #f87171 8%, color-mix(in srgb, var(--c-glass) 15%, transparent));
    }

    .glass-toast.info {
      border-color: rgba(96, 165, 250, 0.4);
      background: color-mix(in srgb, #60a5fa 8%, color-mix(in srgb, var(--c-glass) 15%, transparent));
    }

    /* ======= Liquid Glass Kit Accessibility ======= */
    @media (prefers-reduced-motion: reduce) {
      .glass-slider,
      .glass-switch,
      .glass-panel,
      .glass-toast,
      .tbtn {
        transition: none !important;
        animation: none !important;
      }
      
      .glass-toast {
        transform: translateX(0) !important;
      }
    }

    @media (prefers-contrast: high) {
      .glass-panel,
      .glass-toast {
        background: var(--c-bg);
        border-color: var(--c-content);
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }
      
      .glass-slider,
      .glass-switch {
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        border-width: 2px;
      }
    }

    /* Focus ring improvements for glass components */
    .glass-slider:focus-visible,
    .glass-switch input:focus-visible + .switch-slider,
    .tbtn:focus-visible {
      outline: 2px solid var(--c-action);
      outline-offset: 3px;
      border-radius: 8px;
    }

    /* ======= PATCHES: Find Bar, Footer, Toolbar fixes ======= */
    
    /* 1) Qualquer [hidden] deve sumir, mesmo com display declarado em CSS */
    [hidden] { display: none !important; }

    /* 2) Find Bar REDESIGNED: Posicionamento inteligente e UX melhorada */
    #findBar { 
      /* Posicionamento relativo ao editor, não absoluto global */
      position: absolute;
      top: 12px;
      right: 12px;
      left: auto;
      z-index: 1500; /* Maior que toolbar (900) e header (1000) */
      max-width: min(90vw, 520px);
      min-width: 320px;
      
      /* Remove conflitos de layout */
      transform: none;
      margin: 0;
    }

    /* Evita que findbar fique sob minimap ou em mobile */
    .editor-shell.minimap-on #findBar {
      right: calc(var(--mini-w) + 12px);
    }
    
    @media (max-width: 640px) {
      #findBar {
        position: fixed;
        top: calc(48px + 60px); /* header + toolbar height + margin */
        right: 8px; 
        left: 8px;
        min-width: auto;
        max-width: none;
        z-index: 1600; /* Ainda maior em mobile */
      }
      
      /* Em mobile, findbar sempre fica acima de tudo */
      .editor-shell.minimap-on #findBar {
        right: 8px; /* Reset minimap offset em mobile */
      }
    }

    /* 3) Footer colado ao fundo (dentro do layout de grid) */
    footer.status {
      grid-row: 4;
      position: static;
      height: 32px;
      z-index: 800;
    }

    /* 4) Unificar comportamento da header-toolbar: STICKY, não fixed */
    .header + .header-toolbar { /* já existe esta regra */
      position: sticky;
      top: 48px;
      z-index: 900;
      padding: 8px 32px 0;
    }
    /* (mantido acima) regra única já garante sticky sem !important */

    /* ======= Acessibilidade aprimorada (HIG) ======= */
    @media (prefers-reduced-motion: reduce){
      .toolbar, .tbtn, .btn { transition: none !important; }
      .glass-ui, .glass-panel, .glass-toast { transition: none !important; animation: none !important; }
      .note-row { transition: none !important; }
      .find-option-toggle { transition: none !important; }
    }

    /* Alto contraste para acessibilidade */
    @media (prefers-contrast: high) {
      .glass-panel, .glass-toast, .toolbar, #findBar {
        background: var(--c-bg) !important;
        border-color: var(--c-content) !important;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
      }
      
      .glass-slider, .glass-switch {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        border-width: 2px !important;
      }

      .note-row {
        background: var(--c-bg) !important;
        border-color: var(--c-content) !important;
      }

      .tbtn:focus-visible,
      dialog .tbtn:focus-visible,
      dialog [role="tab"]:focus-visible,
      dialog input:focus-visible{
        outline: 3px solid var(--c-action) !important;
        outline-offset: 3px !important;
      }
    }

    html,body{height:100%}
    body{margin:0;overflow:hidden;color:var(--text);font:400 var(--font-size)/var(--line-height) var(--code-font);background:var(--bg)}
    body::before{content:"";position:fixed;inset:0;z-index:-2;pointer-events:none;background:
      radial-gradient(120vh 80vh at 80% -10%, rgba(10,132,255,0.10), transparent 60%),
      radial-gradient(110vh 70vh at -10% -20%, rgba(94,92,230,0.08), transparent 55%),
      linear-gradient(180deg, var(--bg), var(--bg-2));background-size:100% 100%;background-repeat:no-repeat;background-attachment:fixed}
    body::after{content:"";position:fixed;inset:0;z-index:-1;pointer-events:none;background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAPElEQVR4nO3QMQEAAAgDIN8/9E0gY0oYj8q6CwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANw8g1gAAU6l8mEAAAAASUVORK5CYII=');opacity:.06;image-rendering:pixelated}

    /* ===== Layout ===== */
    .layout{
      display:grid;
      grid-template-rows: min-content 1fr 32px;
      height:100svh;
      min-height:0;
      width:100%;
      overflow:hidden;
    }
    .editor-shell,.editor-wrap,#editor,.gutter,.minimap{min-height:0}

    /* a barra única agora gruda no topo da viewport */
    .header-toolbar{
      grid-row: 1;
      position: sticky;
      top: 0;
      z-index: 1000;
      padding: max(0px, env(safe-area-inset-top)) clamp(16px, 4vw, 32px) 0;
    }
    .toolbar--attached{
      border-top-left-radius: 0;
      border-top-right-radius: 0;
      border-top: none;
    }

    .title-chip{
      display:inline-flex; align-items:center; gap:8px;
      height: 32px; padding: 0 10px; border-radius: 10px;
      cursor: text;
      color: var(--c-content);
      background: color-mix(in srgb, var(--c-glass) 14%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 40%), transparent);
      font: 600 12px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .title-chip:hover{ color: var(--c-action); transform: translateY(-1px); }
    .title-chip:focus-visible{ outline: 2px solid color-mix(in srgb, var(--c-action) 60%, transparent); outline-offset: 2px; }
    .title-chip .ticon{ width:16px; height:16px; opacity:.7 }

    .menu-section{
      font-size:10px; font-weight:700; letter-spacing:.06em;
      color: var(--text-muted); text-transform: uppercase;
      padding: 6px 8px 4px;
    }
    .menu-divider{
      height:1px; margin:6px 4px;
      background: color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
    }
    .popover__btn[role="menuitemcheckbox"][aria-checked="true"]{
      color: var(--c-light);
      background: linear-gradient(135deg, color-mix(in srgb, var(--c-action) 60%, transparent), color-mix(in srgb, var(--c-action) 25%, var(--c-dark)));
      border-color: color-mix(in srgb, var(--c-action) 40%, transparent);
    }

    /* LiquidGlass surface helper */
    .lg-surface{
      background:color-mix(in oklab, var(--bg), white 6%);
      backdrop-filter: blur(var(--lg-blur)) saturate(var(--lg-sat)) contrast(var(--lg-contrast));
      -webkit-backdrop-filter: blur(var(--lg-blur)) saturate(var(--lg-sat)) contrast(var(--lg-contrast));
      border:1px solid var(--stroke);
      box-shadow:
        inset 0 0 0 1px color-mix(in oklab, var(--lg-highlight), transparent 70%),
        0 1px 8px rgba(0,0,0,.18);
    }

    /* Footer override para evitar conflitos de layout */
    footer.lg-surface {
      grid-row: 3;
      background: color-mix(in oklab, var(--bg), white 5%);
      border: none;
      border-top: 1px solid var(--stroke);
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      box-shadow: none;
    }

    /* Toolbar acoplada - usa padrão do Kit */
    .header-toolbar{
      position: sticky; top: 0;
      left: auto; right: auto;
      z-index: 1000;
      padding: 8px 32px 0;
    }

    .brand{display:inline-flex;align-items:center;gap:8px;font-weight:600;font-size:14px;color:var(--c-content);font-family:"DM Sans",system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    .brand-dot{width:7px;height:7px;border-radius:999px;background:linear-gradient(180deg,var(--accent),var(--accent-2));box-shadow:0 0 0 2px color-mix(in oklab, var(--accent), transparent 70%)}
    .spacer{flex:1}

    /* Botões antigos removidos - usando ponte de compatibilidade agora */

    .btn-active {
      background: color-mix(in oklab, var(--accent), transparent 85%) !important;
      border-color: color-mix(in oklab, var(--accent), black 30%) !important;
      box-shadow: inset 0 1px 2px color-mix(in oklab, var(--accent), black 80%) !important;
      color: var(--text) !important;
    }

    .title-editor {
      background: var(--panel-strong);
      border: 1px solid var(--accent);
      color: var(--text);
      font-family: inherit;
      font-size: inherit;
      padding: 1px 4px;
      border-radius: 4px;
      outline: none;
      width: 300px;
      margin-left: -4px;
    }

    /* Font Controls */
    .font-controls {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      padding: 1px;
      background: color-mix(in oklab, var(--bg), white 4%);
      border: 1px solid var(--stroke);
      border-radius: 10px;
      
      /* Liquid Glass Effect */
      backdrop-filter: blur(8px) saturate(130%) brightness(1.08);
      -webkit-backdrop-filter: blur(8px) saturate(130%) brightness(1.08);
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.12),
        inset 1px 0 0 rgba(255,255,255,0.08),
        inset 0 -1px 0 rgba(0,0,0,0.08),
        0 1px 3px rgba(0,0,0,0.1);
    }
    
    .font-btn {
      width: 24px;
      height: 24px;
      padding: 0;
      border-radius: 6px;
      background: transparent;
      border: 1px solid transparent;
      transition: all 0.2s cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .font-btn:hover {
      background: color-mix(in oklab, var(--panel), white 8%);
      border-color: color-mix(in oklab, var(--stroke), white 20%);
      transform: translateY(-1px) scale(1.05);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    
    .font-btn:active {
      transform: translateY(0) scale(0.95);
      background: color-mix(in oklab, var(--panel), white 4%);
    }
    
    .font-btn svg {
      width: 12px;
      height: 12px;
      opacity: 0.85;
    }
    
    .font-size-display {
      min-width: 20px;
      padding: 0 4px;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-dim);
      text-align: center;
      line-height: 1.2;
      font-family: var(--code-font);
      user-select: none;
      transition: all 0.3s cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .font-size-display.changed {
      color: var(--accent);
      transform: scale(1.1);
    }

    .progress{position:fixed;top:0;left:0;height:3px;width:0%;z-index:9;background:linear-gradient(90deg,var(--accent),var(--accent-2));box-shadow:0 0 12px color-mix(in oklab, var(--accent), transparent 40%)}

    /* Editor shell */
    .editor-shell{
      display:grid;
      grid-template-columns:0px 1fr 0px;
      height:100%;
      position:relative;
      overflow:hidden;
      min-height:0;
    }
    .editor-shell.lines-on{grid-template-columns:var(--gutter-w) 1fr 0px}
    .editor-shell.minimap-on{grid-template-columns:0px 1fr var(--mini-w)}
    .editor-shell.lines-on.minimap-on{grid-template-columns:var(--gutter-w) 1fr var(--mini-w)}

    .gutter{position:relative;overflow:hidden;border-right:1px solid var(--stroke);background:color-mix(in oklab, var(--bg), white 3%);font:400 var(--editor-font-size)/var(--line-height) var(--code-font);text-align:right;padding:var(--editor-padding) 6px var(--editor-padding) 4px;user-select:none;scrollbar-width:none;-ms-overflow-style:none;width:0;min-width:0;box-sizing:border-box}
    .gutter::-webkit-scrollbar{display:none}
    .gutter .ln{opacity:.6;padding:0 3px;line-height:inherit;transition:opacity var(--dur) var(--ease),color var(--dur) var(--ease),background var(--dur) var(--ease);white-space:nowrap;border-radius:4px;box-sizing:border-box;cursor:pointer;position:relative}
    .gutter .ln:hover{opacity:.9;background:color-mix(in oklab, var(--accent), transparent 92%)}
    .gutter .ln.current{opacity:1;color:var(--accent);background:color-mix(in oklab, var(--accent), transparent 90%);font-weight:600}

    /* Marcador (bookmark) discreto no gutter */
    .gutter .ln.bookmark::before {
      content: "";
      position: absolute;
      left: 6px;
      top: 50%;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      transform: translateY(-50%);
      background: color-mix(in oklab, var(--accent-2), white 10%);
      box-shadow: 0 0 0 1px color-mix(in oklab, var(--accent-2), black 35%);
      opacity: .9;
    }

    /* Faixa de hover/seleção desenhada no overlay */
    .highlights-overlay .line-hover,
    .highlights-overlay .line-selection {
      position: absolute;
      left: 0; right: 0;
      border-radius: 4px;
      background: color-mix(in oklab, var(--accent), transparent 90%);
      pointer-events: none;
    }
    .highlights-overlay .line-selection {
      background: color-mix(in oklab, var(--accent-2), transparent 85%);
    }

    /* Pontinho sutil para sublinhas quando wrap ativo (opcional) */
    .gutter .ln.continuation::after {
      content: "·";
      opacity: .45;
      margin-left: 4px;
      font-weight: 700;
    }
    .editor-shell.lines-on .gutter{width:auto;min-width:var(--gutter-w)}
    
    /* Gutter pode rolar (barra invisível) – JS sincroniza com o editor */
    .editor-shell.lines-on .gutter {
      overflow-y: auto;
    }
    .editor-shell.lines-on .gutter::-webkit-scrollbar{ display:none }
    .editor-shell.lines-on .gutter{ scrollbar-width:none }

    .editor-wrap{
      position:relative;
      overflow:hidden;
      min-height:0;
      height:100%;
    }
    #editor{
      box-sizing:border-box;
      width:100%;
      height:100%;
      padding:var(--editor-padding);
      border:0;
      outline:none;
      resize:none;
      background:transparent;
      color:var(--text);
      font:400 var(--editor-font-size)/var(--line-height) var(--code-font);
      caret-color:var(--accent);
      tab-size:var(--tab-size);
      white-space:pre;
      overflow:auto;
      scrollbar-color:var(--panel-strong) transparent;
      scrollbar-width:thin;
      contain:content;
      min-height:100%;
    }

    .highlights-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      box-sizing: border-box;
      padding: var(--editor-padding);
      font: 400 var(--editor-font-size)/var(--line-height) var(--code-font);
      white-space: pre;
      overflow: hidden;
      pointer-events: none;
      tab-size: var(--tab-size);
      color: transparent; /* O texto é invisível, apenas os destaques aparecem */
    }
    .highlights-overlay mark,
    .highlights-overlay .find-hit {
      border-radius: 3px;
      background: color-mix(in oklab, var(--accent), transparent 75%);
      color: transparent;
    }
    .highlights-overlay mark.current,
    .highlights-overlay .find-hit.current {
      background: color-mix(in oklab, var(--accent-2), transparent 65%);
      box-shadow: 0 0 8px color-mix(in oklab, var(--accent-2), transparent 70%);
    }

    /* ======= Find Bar Redesigned - Interface Consistente ======= */
    #findBar {
      position: absolute;
      right: 12px;
      top: 12px;
      border-radius: 16px;
      z-index: 1500;
      min-width: 360px;
      max-width: min(90vw, 580px);
      
      /* Layout vertical organizado */
      display: flex; 
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      
      /* Usa exatamente o mesmo estilo da toolbar para consistência */
      background-color: color-mix(in srgb, var(--c-glass) 10%, transparent);
      backdrop-filter: blur(10px) saturate(var(--saturation));
      -webkit-backdrop-filter: blur(10px) saturate(var(--saturation));
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 0 0 1px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 8%), transparent),
        inset 1.2px 2px 0 -1px color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 70%), transparent),
        inset -1px -1px 0 -1px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 15%), transparent),
        0 8px 24px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent);
      transition: background-color 400ms cubic-bezier(1,0,0.4,1), box-shadow 400ms cubic-bezier(1,0,0.4,1), border-color 400ms cubic-bezier(1,0,0.4,1);
    }
    
    /* Evita que findbar fique sob minimap ou em mobile */
    .editor-shell.minimap-on #findBar {
      right: calc(var(--mini-w) + 12px);
    }
    
    @media (max-width: 640px) {
      #findBar {
        position: fixed;
        top: calc(48px + 60px); /* header + toolbar height + margin */
        right: 8px; 
        left: 8px;
        min-width: auto;
        max-width: none;
        z-index: 1600; /* Ainda maior em mobile */
      }
      
      /* Em mobile, findbar sempre fica acima de tudo */
      .editor-shell.minimap-on #findBar {
        right: 8px; /* Reset minimap offset em mobile */
      }
    }
    
    /* Primeira linha: busca + navegação + fechar */
    .find-primary-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    /* Segunda linha: substituir (quando ativa) */
    .find-replace-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    /* Terceira linha: opções */
    .find-options-row {
      display: flex;
      gap: 6px;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
    }
    
    /* Input fields consistentes */
    .find-input {
      height: 36px;
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      border-radius: 12px;
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      color: var(--c-content);
      padding: 0 12px;
      font-size: 13px;
      outline: none;
      flex: 1;
      min-width: 0;
      font-family: "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 40%), transparent);
      transition: border-color 200ms ease, box-shadow 200ms ease;
    }
    
    .find-input:focus {
      border-color: var(--c-action);
      box-shadow: 0 0 0 2px color-mix(in srgb, var(--c-action) 60%, transparent);
    }
    
    .find-input::placeholder {
      color: color-mix(in srgb, var(--c-content) 60%, transparent);
    }
    
    /* Inputs específicos */
    #findInput {
      min-width: 200px;
    }
    
    #replaceInput {
      min-width: 180px;
    }
    
    /* Contador de matches melhorado */
    .find-count-display {
      color: var(--c-content);
      font-size: 12px;
      font-weight: 600;
      padding: 6px 10px;
      background: color-mix(in srgb, var(--c-glass) 16%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      border-radius: 8px;
      min-width: 50px;
      text-align: center;
      white-space: nowrap;
      font-family: "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-variant-numeric: tabular-nums;
    }
    
    /* Botões da findbar - usando .tbtn consistente */
    #findBar .tbtn {
      height: 36px;
      flex-shrink: 0;
    }
    
    #findBar .tbtn--icon {
      width: 36px;
      padding: 0;
    }
    
    /* Option toggles redesigned */
    .find-option-toggle {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 32px;
      padding: 0;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
      transition: all 200ms ease;
      
      /* Mesmo padrão visual dos botões da toolbar */
      color: var(--c-content); 
      background: color-mix(in srgb, var(--c-glass) 14%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 10%), transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) calc(var(--glass-reflex-light) * 45%), transparent),
        inset 0 -1px 0 color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 10%), transparent),
        0 1px 2px color-mix(in srgb, var(--c-dark) calc(var(--glass-reflex-dark) * 12%), transparent);
    }
    
    .find-option-toggle:hover {
      color: var(--c-action); 
      transform: translateY(-1px);
    }
    
    .find-option-toggle:active {
      transform: translateY(0);
    }
    
    .find-option-toggle[aria-pressed="true"] {
      color: var(--c-light);
      background: linear-gradient(135deg, color-mix(in srgb, var(--c-action) 60%, transparent), color-mix(in srgb, var(--c-action) 25%, var(--c-dark)));
      border-color: color-mix(in srgb, var(--c-action) 40%, transparent);
    }
    
    /* Responsive behavior aprimorado */
    @media (max-width: 640px) {
      #findBar {
        position: fixed;
        top: 70px; /* Espaço para header + toolbar */
        right: 8px;
        left: 8px;
        min-width: auto;
        max-width: none;
        z-index: 1600;
      }
      
      .find-primary-row,
      .find-replace-row {
        flex-wrap: wrap;
        gap: 6px;
      }
      
      .find-input {
        min-width: 0;
        flex: 1 1 120px;
      }
      
      .find-options-row {
        justify-content: center;
        gap: 4px;
      }
      
      .find-option-toggle {
        width: 32px;
        height: 28px;
        font-size: 10px;
      }
    }
    
    /* Estados especiais para highlights */
    .find-hit {
      border-radius: 3px;
      background: color-mix(in oklab, var(--accent), transparent 75%);
      color: transparent;
    }
    
    .find-hit.current {
      background: color-mix(in oklab, var(--accent-2), transparent 65%);
      box-shadow: 0 0 8px color-mix(in oklab, var(--accent-2), transparent 70%);
    }

    .overlay-dialog {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 1100; /* Maior que o header-toolbar (z-index: 1000) */
      padding: 6px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,.25);
    }

    /* Go To Line Bar - usando mesmo estilo da findBar */
    #goToLine { 
      position: absolute;
      top: 12px;
      right: 12px;
      left: auto;
      z-index: 1500; /* Mesmo z-index da findBar */
      max-width: min(90vw, 360px);
      min-width: 280px;
      
      /* Remove conflitos de layout */
      transform: none;
      margin: 0;
    }

    /* Remove as setinhas padrão do input number */
    #goToLineInput::-webkit-outer-spin-button,
    #goToLineInput::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    #goToLineInput[type=number] {
      appearance: textfield; /* Padrão */
      -moz-appearance: textfield; /* Firefox */
    }

    /* Evita que goToLine fique sob minimap */
    .editor-shell.minimap-on #goToLine {
      right: calc(var(--mini-w) + 12px);
    }
    
    @media (max-width: 640px) {
      #goToLine {
        position: fixed;
        top: calc(48px + 60px); /* header + toolbar height + margin */
        right: 8px; 
        left: 8px;
        min-width: auto;
        max-width: none;
        z-index: 1600;
      }
      
      .editor-shell.minimap-on #goToLine {
        right: 8px;
        left: 8px;
      }
    }
    .overlay-dialog.shake {
        animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
    }
    @keyframes shake {
      10%, 90% { transform: translate3d(-1px, 0, 0); }
      20%, 80% { transform: translate3d(2px, 0, 0); }
      30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
      40%, 60% { transform: translate3d(4px, 0, 0); }
    }

    /* ===== Minimal Dropzone with Clean Liquid Glass ===== */
    .dropzone-overlay {
      position: fixed;
      inset: 0;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.25s ease-out, visibility 0.25s ease-out;
      
      /* Clean Liquid Glass Background */
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(20px) saturate(120%);
      -webkit-backdrop-filter: blur(20px) saturate(120%);
    }
    
    .dropzone-overlay.show {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
    
    .dropzone-content {
      position: relative;
      padding: 40px 48px;
      border-radius: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      pointer-events: none;
      
      /* Minimal Liquid Glass */
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(24px) saturate(130%);
      -webkit-backdrop-filter: blur(24px) saturate(130%);
      
      box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 8px 32px rgba(0, 0, 0, 0.3);
      
      transform: scale(0.95);
      transition: transform 0.3s cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .dropzone-overlay.show .dropzone-content {
      transform: scale(1);
    }
    
    .dropzone-icon {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 16px;
      
      /* Simple glass container */
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      
      transition: all 0.2s ease-out;
    }
    
    .dropzone-content svg {
      width: 28px;
      height: 28px;
      stroke: var(--text);
      stroke-width: 1.8;
      opacity: 0.9;
    }
    
    .dropzone-title {
      font-size: 1.1rem;
      font-weight: 500;
      color: var(--text);
      text-align: center;
      margin: 0;
      letter-spacing: -0.01em;
    }
    
    .dropzone-subtitle {
      font-size: 0.875rem;
      color: var(--text-dim);
      text-align: center;
      margin: 0;
      opacity: 0.8;
    }
    
    /* Responsive Design */
    @media (max-width: 640px) {
      .dropzone-content {
        padding: 32px 36px;
        border-radius: 16px;
        gap: 16px;
      }
      
      .dropzone-icon {
        width: 52px;
        height: 52px;
        border-radius: 14px;
      }
      
      .dropzone-content svg {
        width: 24px;
        height: 24px;
      }
      
      .dropzone-title {
        font-size: 1rem;
      }
      
      .dropzone-subtitle {
        font-size: 0.8rem;
      }
    }

    /* ===== Minimal Toast Notifications ===== */
    .toast {
      position: fixed;
      top: 24px;
      right: 24px;
      z-index: 1000;
      padding: 12px 20px;
      border-radius: 12px;
      color: var(--text);
      font-size: 13px;
      font-weight: 500;
      max-width: 320px;
      text-align: center;
      
      /* Clean Liquid Glass */
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(20px) saturate(120%);
      -webkit-backdrop-filter: blur(20px) saturate(120%);
      
      box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 4px 16px rgba(0, 0, 0, 0.2);
      
      /* Animation */
      transform: translateX(120%) scale(0.95);
      transition: all 0.3s cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .toast.show {
      transform: translateX(0) scale(1);
    }
    
    .toast-success {
      color: #10b981;
      border-color: rgba(16, 185, 129, 0.3);
    }
    
    .toast-error {
      color: #ef4444;
      border-color: rgba(239, 68, 68, 0.3);
    }
    
    .toast-info {
      color: var(--accent);
      border-color: color-mix(in oklab, var(--accent), transparent 70%);
    }
    
    @media (max-width: 640px) {
      .toast {
        left: 16px;
        right: 16px;
        top: 16px;
        max-width: none;
        transform: translateY(-120%) scale(0.95);
      }
      
      .toast.show {
        transform: translateY(0) scale(1);
      }
    }

    .minimap{position:relative;border-left:1px solid var(--stroke);background:color-mix(in oklab, var(--bg), white 3%);overflow:hidden;user-select:none}
    .minimap pre{margin:0;padding:var(--editor-padding) 4px;font:400 2px/2px var(--code-font);opacity:.6;white-space:pre;pointer-events:none}

    /* LiquidGlass Lens for minimap viewport */
    .mini-viewport{
      position:absolute;
      left:4px;
      right:4px;
      border-radius:12px;
      pointer-events:auto;
      cursor:grab;
      
      /* Ultra-transparent glass background */
      background: 
        radial-gradient(ellipse 80% 60% at 25% 20%, rgba(255,255,255,0.15), transparent 70%),
        radial-gradient(ellipse 60% 80% at 75% 80%, rgba(255,255,255,0.08), transparent 60%),
        rgba(255,255,255,0.03);
      
      /* Minimal glass border */
      border: 1px solid rgba(255,255,255,0.12);
      
      /* Glass lens effect with refraction */
      box-shadow: 
        /* Sharp inner highlight edge */
        inset 0 1px 0 0 rgba(255,255,255,0.25),
        inset 1px 0 0 0 rgba(255,255,255,0.15),
        
        /* Curved glass reflection */
        inset 2px 2px 4px -2px rgba(255,255,255,0.2),
        inset -1px -1px 3px -1px rgba(255,255,255,0.1),
        
        /* Bottom lens refraction */
        inset 0 -1px 0 0 rgba(0,0,0,0.1),
        inset -1px 0 0 0 rgba(0,0,0,0.05),
        
        /* Subtle depth shadow */
        inset 0 -2px 8px -3px rgba(0,0,0,0.08),
        
        /* External lens shadow */
        0 1px 3px -1px rgba(0,0,0,0.15),
        0 2px 8px -2px rgba(0,0,0,0.1);
      
      /* Crystal clear backdrop filter */
      backdrop-filter: blur(2px) saturate(120%) brightness(1.1);
      -webkit-backdrop-filter: blur(2px) saturate(120%) brightness(1.1);
      
      /* Smooth lens transitions */
      transition: 
        background 200ms cubic-bezier(0.2, 0.7, 0.2, 1),
        box-shadow 200ms cubic-bezier(0.2, 0.7, 0.2, 1),
        border-color 200ms cubic-bezier(0.2, 0.7, 0.2, 1),
        transform 120ms cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .mini-viewport:hover{
      /* Enhanced lens clarity on hover */
      background: 
        radial-gradient(ellipse 80% 60% at 25% 20%, rgba(255,255,255,0.2), transparent 70%),
        radial-gradient(ellipse 60% 80% at 75% 80%, rgba(255,255,255,0.12), transparent 60%),
        rgba(255,255,255,0.05);
      
      border-color: rgba(255,255,255,0.18);
      
      box-shadow: 
        /* Brighter edge highlights */
        inset 0 1px 0 0 rgba(255,255,255,0.35),
        inset 1px 0 0 0 rgba(255,255,255,0.22),
        
        /* Enhanced glass curvature */
        inset 2px 2px 4px -2px rgba(255,255,255,0.28),
        inset -1px -1px 3px -1px rgba(255,255,255,0.15),
        
        /* Defined lens edges */
        inset 0 -1px 0 0 rgba(0,0,0,0.12),
        inset -1px 0 0 0 rgba(0,0,0,0.08),
        
        /* Slight floating effect */
        0 2px 6px -1px rgba(0,0,0,0.18),
        0 4px 12px -2px rgba(0,0,0,0.12);
      
      /* Enhanced lens optics */
      backdrop-filter: blur(3px) saturate(130%) brightness(1.15);
      -webkit-backdrop-filter: blur(3px) saturate(130%) brightness(1.15);
      
      transform: translateY(-1px);
    }
    
    .mini-viewport:active{
      cursor:grabbing;
      transform: translateY(0px) scale(0.99);
      
      /* Pressed lens effect */
      background: 
        radial-gradient(ellipse 80% 60% at 25% 20%, rgba(255,255,255,0.12), transparent 70%),
        radial-gradient(ellipse 60% 80% at 75% 80%, rgba(255,255,255,0.06), transparent 60%),
        rgba(255,255,255,0.02);
      
      border-color: rgba(255,255,255,0.1);
      
      box-shadow: 
        /* Reduced highlights when pressed */
        inset 0 1px 0 0 rgba(255,255,255,0.18),
        inset 1px 0 0 0 rgba(255,255,255,0.1),
        
        /* Compressed glass effect */
        inset 1px 1px 3px -1px rgba(255,255,255,0.15),
        inset 0 -1px 2px -1px rgba(0,0,0,0.08),
        
        /* Minimal shadow when pressed */
        0 1px 2px -1px rgba(0,0,0,0.12);
      
      /* Focused lens clarity */
      backdrop-filter: blur(1px) saturate(110%) brightness(1.05);
      -webkit-backdrop-filter: blur(1px) saturate(110%) brightness(1.05);
    }
    @supports not (backdrop-filter: blur(2px)){
      .mini-viewport{
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.15);
      }
      .mini-viewport:hover{
        background: rgba(255,255,255,0.12);
      }
    }
    @media (prefers-contrast: more){
      .mini-viewport{box-shadow:none;border-color: color-mix(in oklab, var(--accent), black 55%)}
    }

    /* Minimap disabled state */
    .minimap.mini-disabled {
      opacity: 0.6;
    }
    .minimap.mini-disabled .mini-viewport {
      cursor: default !important;
      pointer-events: none !important;
      opacity: 0.5;
    }

    /* Touch improvements */
    .minimap, .mini-viewport { 
      touch-action: none; 
    }

    footer.status{
      display:flex;
      align-items:center;
      gap:8px;
      padding:0 8px;
      border-top:1px solid var(--stroke);
      background:color-mix(in oklab, var(--bg), white 5%);
      font-size:11px;
      color:var(--text-muted);
      height:32px;
      min-height:32px;
      max-height:32px;
      flex-shrink:0;
      box-sizing:border-box;
      overflow:hidden;
      white-space:nowrap;
      grid-row: 3;
      position: static;
      z-index: 800;
    }
    
    footer.status > * {
      flex-shrink:0;
    }
    
    footer.status .spacer {
      flex:1;
      min-width:0;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:3px 6px;
      border:1px solid var(--stroke);
      background:var(--panel);
      border-radius:999px;
      font-size:10px;
      white-space:nowrap;
      flex-shrink:0;
    }
    .sep{
      width:1px;
      height:12px;
      background:var(--stroke);
      flex-shrink:0;
    }
    .spacer{
      flex:1;
      min-width:0;
    }

    dialog{background:color-mix(in oklab, var(--bg), white 6%);color:var(--text);border:1px solid var(--stroke);border-radius:16px;backdrop-filter:saturate(140%) blur(16px);-webkit-backdrop-filter:saturate(140%) blur(16px)}
    dialog::backdrop{background:rgba(0,0,0,.45)}
    
    /* CORREÇÃO: Garantir que dialogs fechados fiquem ocultos */
    dialog:not(:modal) { display: none !important; }

    dialog#settings{width:min(96vw, 680px);padding:14px 14px 10px}
    .settings-grid{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center}
    .settings-grid h3{grid-column:1/-1;margin:0 0 6px;font-weight:700}
    .settings-grid label{color:var(--text-dim)}
    .settings-grid input[type=range]{width:260px}


    /* ========= Liquid Glass Range Controls (Ultra Discretos) ========= */
    .range-control {
      position: relative;
      width: 240px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 4px;
      gap: 12px;
    }
    
    .range-control input[type="range"] {
      flex: 1;
      height: 20px;
      background: transparent;
      outline: none;
      border: none;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
      position: relative;
      z-index: 2;
    }
    
    /* Display de valor discreto */
    .range-value {
      font-size: 12px;
      font-weight: 500;
      color: color-mix(in oklab, var(--text), transparent 30%);
      background: color-mix(in oklab, var(--panel), var(--stroke) 15%);
      padding: 2px 6px;
      border-radius: 6px;
      border: 0.5px solid color-mix(in oklab, var(--stroke), transparent 70%);
      min-width: 32px;
      text-align: center;
      font-variant-numeric: tabular-nums;
      
      /* Sombra interna sutil */
      box-shadow: inset 0 0.5px 1px rgba(0,0,0,0.04);
      
      transition: all 0.2s ease;
    }
    
    /* Track discreto mas SEMPRE visível */
    .range-control input[type="range"]::-webkit-slider-track {
      width: 100%;
      height: 4px;
      border-radius: 6px;
      
      /* Trilho mais visível em tons neutros */
      background: color-mix(in oklab, var(--panel), var(--stroke) 45%);
      border: 1px solid color-mix(in oklab, var(--stroke), transparent 40%);
      
      /* Sombra interna para definição clara */
      box-shadow: 
        inset 0 1px 2px rgba(0,0,0,0.1),
        inset 0 -0.5px 0 rgba(255,255,255,0.08);
      
      transition: all 0.2s ease;
    }
    
    .range-control input[type="range"]::-moz-range-track {
      width: 100%;
      height: 4px;
      border-radius: 6px;
      background: color-mix(in oklab, var(--panel), var(--stroke) 45%);
      border: 1px solid color-mix(in oklab, var(--stroke), transparent 40%);
      box-shadow: 
        inset 0 1px 2px rgba(0,0,0,0.1),
        inset 0 -0.5px 0 rgba(255,255,255,0.08);
    }
    
    /* Thumb ultra discreto em tons neutros */
    .range-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      cursor: grab;
      
      /* Fundo neutro discreto */
      background: 
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.15), transparent 70%),
        color-mix(in oklab, var(--panel), var(--stroke) 60%);
      
      /* Borda sutil neutra */
      border: 1px solid color-mix(in oklab, var(--stroke), white 15%);
      
      /* Sombra mínima */
      box-shadow: 
        inset 0 0.5px 0 rgba(255,255,255,0.15),
        0 0.5px 2px rgba(0,0,0,0.08),
        0 0 0 0.5px color-mix(in oklab, var(--stroke), transparent 85%);
      
      transition: 
        transform 0.15s ease,
        box-shadow 0.15s ease,
        border-color 0.15s ease;
    }
    
    .range-control input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      cursor: grab;
      border: 1px solid color-mix(in oklab, var(--stroke), white 15%);
      background: 
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.15), transparent 70%),
        color-mix(in oklab, var(--panel), var(--stroke) 60%);
      box-shadow: 
        inset 0 0.5px 0 rgba(255,255,255,0.15),
        0 0.5px 2px rgba(0,0,0,0.08),
        0 0 0 0.5px color-mix(in oklab, var(--stroke), transparent 85%);
    }
    
    /* Hover mais visível */
    .range-control input[type="range"]:hover::-webkit-slider-track {
      background: color-mix(in oklab, var(--panel), var(--stroke) 55%);
      border-color: color-mix(in oklab, var(--stroke), transparent 30%);
      box-shadow: 
        inset 0 1px 2px rgba(0,0,0,0.12),
        inset 0 -0.5px 0 rgba(255,255,255,0.1);
    }
    
    .range-control input[type="range"]:hover::-webkit-slider-thumb {
      transform: scale(1.05);
      background: 
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2), transparent 70%),
        color-mix(in oklab, var(--panel), var(--stroke) 70%);
      border-color: color-mix(in oklab, var(--stroke), white 25%);
      box-shadow: 
        inset 0 0.5px 0 rgba(255,255,255,0.2),
        0 1px 3px rgba(0,0,0,0.12),
        0 0 0 1px color-mix(in oklab, var(--stroke), transparent 75%);
    }
    
    .range-control input[type="range"]:hover + .range-value {
      background: color-mix(in oklab, var(--panel), var(--stroke) 20%);
      border-color: color-mix(in oklab, var(--stroke), transparent 60%);
      color: color-mix(in oklab, var(--text), transparent 20%);
    }
    
    /* Estado ativo */
    .range-control input[type="range"]:active::-webkit-slider-thumb {
      cursor: grabbing;
      transform: scale(0.95);
      box-shadow: 
        inset 0 0.5px 0 rgba(255,255,255,0.1),
        0 0.5px 1px rgba(0,0,0,0.15),
        0 0 0 1px color-mix(in oklab, var(--stroke), transparent 70%);
    }
    
    /* Foco acessível */
    .range-control input[type="range"]:focus-visible {
      outline: none;
    }
    
    .range-control input[type="range"]:focus-visible::-webkit-slider-thumb {
      box-shadow: 
        inset 0 0.5px 0 rgba(255,255,255,0.15),
        0 0.5px 2px rgba(0,0,0,0.08),
        0 0 0 2px color-mix(in oklab, var(--stroke), transparent 50%);
    }

    /* ========= Switches Ultra Discretos ========= */
    .switch {
      position: relative;
      width: 44px;
      height: 24px;
      border-radius: 999px;
      cursor: pointer;
      
      /* Fundo neutro discreto */
      background: color-mix(in oklab, var(--panel), var(--stroke) 20%);
      border: 1px solid color-mix(in oklab, var(--stroke), transparent 40%);
      
      /* Sombra interna suave */
      box-shadow: 
        inset 0 1px 2px rgba(0,0,0,0.06),
        inset 0 -0.5px 0 rgba(255,255,255,0.04);
      
      transition: all 0.2s cubic-bezier(0.2, 0.7, 0.2, 1);
    }
    
    .switch[aria-checked="true"] {
      /* Estado ativo em tom neutro discreto */
      background: color-mix(in oklab, var(--panel), var(--stroke) 45%);
      border-color: color-mix(in oklab, var(--stroke), white 10%);
      box-shadow: 
        inset 0 1px 2px rgba(0,0,0,0.08),
        inset 0 -0.5px 0 rgba(255,255,255,0.06);
    }
    
    .switch .knob {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      
      /* Knob neutro e limpo */
      background: 
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.3), transparent 70%),
        color-mix(in oklab, var(--panel), white 90%);
      
      /* Borda neutra */
      border: 0.5px solid color-mix(in oklab, var(--stroke), transparent 70%);
      
      /* Sombra discreta */
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.4),
        0 1px 2px rgba(0,0,0,0.1),
        0 0 0 0.5px rgba(0,0,0,0.03);
      
      transition: 
        transform 0.2s cubic-bezier(0.2, 0.7, 0.2, 1),
        box-shadow 0.15s ease;
    }
    
    .switch[aria-checked="true"] .knob {
      transform: translateX(20px);
      background: 
        radial-gradient(circle at 30% 30%, rgba(255,255,255,0.35), transparent 70%),
        color-mix(in oklab, var(--panel), white 85%);
      border-color: color-mix(in oklab, var(--stroke), transparent 60%);
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.3),
        0 1px 3px rgba(0,0,0,0.12),
        0 0 0 0.5px rgba(0,0,0,0.04);
    }
    
    /* Hover discreto nos switches */
    .switch:hover .knob {
      box-shadow: 
        inset 0 1px 0 rgba(255,255,255,0.5),
        0 1px 4px rgba(0,0,0,0.15),
        0 0 0 1px rgba(0,0,0,0.05);
    }

    /* ========= Scroll Perfeitamente Integrado ========= */
    .sheet-content {
      padding: 16px 18px 14px;
      overflow: auto;
      
      /* Scroll customizado */
      scrollbar-width: thin;
      scrollbar-color: color-mix(in oklab, var(--stroke), transparent 70%) transparent;
    }
    
    .sheet-content::-webkit-scrollbar {
      width: 6px;
    }
    
    .sheet-content::-webkit-scrollbar-track {
      background: transparent;
      border-radius: 8px;
      margin: 4px 0;
    }
    
    .sheet-content::-webkit-scrollbar-thumb {
      background: color-mix(in oklab, var(--stroke), transparent 80%);
      border-radius: 8px;
      border: 1px solid transparent;
      background-clip: content-box;
      
      /* Sombra interna discreta */
      box-shadow: inset 0 0 2px rgba(0,0,0,0.1);
      
      transition: all 0.2s ease;
    }

    /* ============ Markdown Viewer (MDV) — Liquid Glass ============ */

    #mdv.dialog-sheet{
      width: min(1000px, 94vw);
      height: 88vh; max-height: 88vh;
      position: fixed; inset: 50% auto auto 50%;
      transform: translate(-50%, -50%);
      border: 1px solid color-mix(in oklab, var(--c-light), transparent 88%);
      border-radius: 24px; padding: 0; margin: 0;
      background: color-mix(in srgb, var(--c-glass) 8%, transparent);
      -webkit-backdrop-filter: blur(24px) saturate(var(--saturation));
      backdrop-filter: blur(24px) saturate(var(--saturation));
      box-shadow: 
        0 32px 80px color-mix(in oklab, var(--c-dark), transparent 60%),
        0 12px 32px color-mix(in oklab, var(--c-dark), transparent 75%),
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 20%, transparent);
      color: var(--c-content);
      overflow: hidden;
    }
    #mdv::backdrop{
      background: color-mix(in srgb, black 50%, transparent);
      backdrop-filter: blur(4px);
    }

    /* Cabeçalho minimalista */
    #mdv .mdv-head{
      position: sticky; top: 0; z-index: 10;
      display: flex; align-items: center; justify-content: space-between;
      padding: 16px 24px; min-height: 64px;
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      -webkit-backdrop-filter: blur(16px) saturate(var(--saturation));
      backdrop-filter: blur(16px) saturate(var(--saturation));
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 8%, transparent);
    }
    #mdv .mdv-title h3{ 
      margin: 0; font-weight: 800; font-size: 18px;
      color: var(--c-content);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    #mdv .mdv-close{
      width: 36px; height: 36px; border-radius: 50%;
      border: 1px solid color-mix(in srgb, var(--c-light) 15%, transparent);
      background: color-mix(in srgb, var(--c-glass) 20%, transparent);
      color: var(--c-content);
      cursor: pointer; display: grid; place-items: center;
      font-size: 16px; font-weight: 600;
      transition: all 0.2s ease;
    }
    #mdv .mdv-close:hover{
      background: color-mix(in srgb, var(--c-light) 15%, transparent);
      border-color: color-mix(in srgb, var(--c-light) 25%, transparent);
      transform: scale(1.05);
    }

    /* Corpo principal */
    #mdv .mdv-body{ 
      height: calc(100% - 64px);
      display: grid; grid-template-columns: 1fr; 
      overflow: hidden;
    }
    #mdv .mdv-content{
      padding: 32px 40px 48px;
      overflow: auto; 
      scrollbar-width: thin; 
      scrollbar-color: color-mix(in oklab, var(--stroke), transparent 75%) transparent;
      
      /* Máscara elegante para indicar scroll */
      mask-image: linear-gradient(
        to bottom, 
        transparent 0, 
        black 16px, 
        black calc(100% - 16px), 
        transparent 100%
      );
    }
    #mdv .mdv-content::-webkit-scrollbar{ width: 8px; }
    #mdv .mdv-content::-webkit-scrollbar-track{ 
      background: transparent; 
      margin: 8px 0; 
      border-radius: 4px; 
    }
    #mdv .mdv-content::-webkit-scrollbar-thumb{
      background: color-mix(in oklab, var(--stroke), transparent 80%);
      border-radius: 4px; 
      border: 2px solid transparent; 
      background-clip: content-box;
    }
    #mdv .mdv-content::-webkit-scrollbar-thumb:hover{
      background: color-mix(in oklab, var(--stroke), transparent 65%);
    }

    #mdv .prose{
      font-size: 16px;
      line-height: 1.7;
      max-width: 75ch;
      margin: 0 auto;
      color: var(--c-content);
    }

    /* Tipografia Markdown otimizada */
    #mdv .prose h1, #mdv .prose h2, #mdv .prose h3, #mdv .prose h4, #mdv .prose h5, #mdv .prose h6{
      font-weight: 800; line-height: 1.25; margin: 2em 0 0.8em;
      color: var(--c-content);
    }
    #mdv .prose h1:first-child, #mdv .prose h2:first-child, #mdv .prose h3:first-child{
      margin-top: 0;
    }
    #mdv .prose h1{ font-size: 32px; margin-bottom: 1.2em; }
    #mdv .prose h2{ font-size: 24px; }
    #mdv .prose h3{ font-size: 20px; }
    #mdv .prose h4{ font-size: 18px; }
    
    #mdv .prose p, #mdv .prose ul, #mdv .prose ol, #mdv .prose blockquote, #mdv .prose table{
      margin: 1.2em 0;
    }
    #mdv .prose li{ margin: 0.3em 0; }
    
    #mdv .prose a{ 
      color: var(--c-action); 
      text-decoration: none; 
      border-bottom: 1px solid color-mix(in srgb, var(--c-action) 40%, transparent);
      transition: all 0.2s ease;
    }
    #mdv .prose a:hover{ 
      border-bottom-color: var(--c-action);
      color: var(--c-action);
    }
    
    #mdv .prose blockquote{
      padding: 1.2em 1.5em; 
      border-left: 4px solid color-mix(in srgb, var(--c-action) 60%, transparent);
      background: color-mix(in srgb, var(--c-glass) 15%, transparent);
      border-radius: 12px;
      margin: 1.5em 0;
      font-style: italic;
    }
    
    #mdv .prose img{ 
      max-width: 100%; height: auto; 
      border-radius: 16px; 
      display: block; margin: 2em auto;
      box-shadow: 0 8px 32px color-mix(in oklab, var(--c-dark), transparent 85%);
    }
    
    #mdv .prose hr{ 
      border: 0; height: 1px; 
      background: color-mix(in srgb, var(--c-light) 25%, transparent); 
      margin: 3em 0; 
    }
    
    #mdv .prose code{ 
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; 
      font-weight: 600;
      font-size: 0.9em;
      padding: 0.2em 0.4em;
      background: color-mix(in srgb, var(--c-glass) 20%, transparent);
      border-radius: 6px;
      border: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
    }
    
    #mdv .prose pre{
      background: color-mix(in srgb, var(--c-glass) 18%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 16%, transparent);
      border-radius: 16px; 
      padding: 20px; 
      overflow: auto;
      margin: 1.5em 0;
      box-shadow: 
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 25%, transparent),
        0 4px 16px color-mix(in oklab, var(--c-dark), transparent 90%);
    }
    #mdv .prose pre code{
      background: none; border: none; padding: 0;
    }
    
    #mdv .prose table{
      width: 100%; border-collapse: collapse; overflow: hidden;
      background: color-mix(in srgb, var(--c-glass) 16%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 14%, transparent);
      border-radius: 16px;
      margin: 2em 0;
      box-shadow: 0 4px 16px color-mix(in oklab, var(--c-dark), transparent 90%);
    }
    #mdv .prose th{ 
      background: color-mix(in srgb, var(--c-glass) 25%, transparent);
      font-weight: 700;
    }
    #mdv .prose th, #mdv .prose td{ 
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent); 
      padding: 0.8em 1em; text-align: left; 
    }     
    #mdv .prose tr:last-child td{ border-bottom: 0; }

    /* Âncoras de cabeçalho */
    #mdv .prose .h-anchor{
      opacity: 0; margin-left: 0.5em; text-decoration: none; 
      font-weight: 600; color: var(--c-action);
      transition: opacity 0.2s ease;
    }
    #mdv .prose h1:hover .h-anchor,
    #mdv .prose h2:hover .h-anchor,
    #mdv .prose h3:hover .h-anchor,
    #mdv .prose h4:hover .h-anchor{ 
      opacity: 0.6; 
    }

    /* Impressão: imprime só o artigo */
    @media print{
      #mdv{ position: static; transform: none; width: auto; height: auto; box-shadow: none; border: 0; }
      #mdv .mdv-head{ display: none !important; }
      #mdv .mdv-content{ overflow: visible; mask-image: none; padding: 0; }
      #mdv .prose{ max-width: none; }
    }

    /* Responsivo */
    @media (max-width: 768px){
      #mdv.dialog-sheet{ width: 96vw; height: 92vh; border-radius: 16px; }
      #mdv .mdv-head{ padding: 12px 16px; min-height: 56px; }
      #mdv .mdv-content{ padding: 24px 20px 32px; }
      #mdv .prose{ max-width: none; }
    }
    
    .sheet-content::-webkit-scrollbar-thumb:hover {
      background: color-mix(in oklab, var(--stroke), transparent 60%);
      box-shadow: inset 0 0 3px rgba(0,0,0,0.15);
    }
    
    .sheet-content::-webkit-scrollbar-thumb:active {
      background: color-mix(in oklab, var(--stroke), transparent 50%);
    }

    /* ============ SETTINGS v2 — Liquid Glass ============ */

    /* Centro absoluto + 80% da viewport + grid fixo */
    #settings.dialog-sheet {
      /* geometria */
      width: min(920px, 96vw);
      height: 80vh;
      max-height: 80vh;
      padding: 0;
      margin: 0;
      position: fixed;
      inset: 50% auto auto 50%;
      transform: translate(-50%, -50%);
      display: grid;
      grid-template-rows: auto 1fr auto;
      overflow: hidden;

      /* material vítreo 100% (usa tokens existentes) */
      border-radius: 20px;
      background: color-mix(in oklab, var(--bg), white 6%);
      backdrop-filter: blur(var(--lg-blur)) saturate(var(--lg-sat)) contrast(var(--lg-contrast));
      -webkit-backdrop-filter: blur(var(--lg-blur)) saturate(var(--lg-sat)) contrast(var(--lg-contrast));
      border: 1px solid color-mix(in oklab, var(--lg-highlight), transparent 70%);
      box-shadow:
        inset 0 0 0 1px color-mix(in oklab, var(--lg-highlight), transparent 72%),
        0 24px 64px color-mix(in oklab, var(--c-dark), transparent 65%),
        0 8px 24px color-mix(in oklab, var(--c-dark), transparent 78%);
    }
    #settings::backdrop{
      background: color-mix(in srgb, black 45%, transparent);
      backdrop-filter: blur(2px);
    }

    /* Cabeçalho minimal vítreo (sem sólido, com cantos superiores arredondados) */
    #settings .settings-head{
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      padding: 12px 16px;
      background: color-mix(in srgb, var(--c-glass) 10%, transparent);
      backdrop-filter: blur(12px) saturate(var(--saturation));
      -webkit-backdrop-filter: blur(12px) saturate(var(--saturation));
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
    }
    #settings .settings-title{
      display:flex; align-items:center; gap:10px; font-weight:700; font-size:15px;
    }
    #settings .settings-actions{ display:flex; align-items:center; gap:8px; }

    /* Campo de busca consistente (reutiliza gramática da toolbar) */
    #settings #settingsSearch{
      height: 36px; min-width: 220px; max-width: 420px;
      padding: 0 12px; border-radius: 12px; outline: none;
      border: 1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      color: var(--c-content); font: 600 12px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--c-light) 40%, transparent);
    }
    #settings #settingsSearch:focus{
      border-color: var(--c-action);
      box-shadow: 0 0 0 2px color-mix(in srgb, var(--c-action) 60%, transparent);
    }

    /* Corpo: sidebar + conteúdo (fixo, sem accordions) */
    #settings .settings-shell{
      display: grid;
      grid-template-columns: 220px 1fr;
      min-height: 0; /* permite rolagem do painel direito */
    }

    /* Sidebar — navegação vertical sticky */
    #settings .settings-nav{
      padding: 10px;
      border-right: 1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
      background: color-mix(in srgb, var(--c-glass) 8%, transparent);
      backdrop-filter: blur(10px) saturate(var(--saturation));
      -webkit-backdrop-filter: blur(10px) saturate(var(--saturation));
      position: sticky; top: 0;
      display: flex; flex-direction: column; gap: 6px;
    }
    #settings .settings-nav button{
      text-align: left; padding: 8px 10px; border-radius: 10px; cursor: pointer;
      background: color-mix(in srgb, var(--c-glass) 14%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
      color: var(--c-content); font: 700 12px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      transition: transform .14s ease, color .2s ease, background-color .2s ease, border-color .2s ease;
    }
    #settings .settings-nav button:hover{ transform: translateY(-1px); color: var(--c-action); }
    #settings .settings-nav button[aria-current="true"]{
      color: var(--c-light);
      background: linear-gradient(135deg, color-mix(in srgb, var(--c-action) 60%, transparent), color-mix(in srgb, var(--c-action) 25%, var(--c-dark)));
      border-color: color-mix(in srgb, var(--c-action) 40%, transparent);
    }

    /* Conteúdo rolável: seções verticais */
    #settings .settings-content{
      padding: 14px 16px;
      overflow: auto;
      mask-image: linear-gradient(to bottom, transparent 0, black 12px, black calc(100% - 12px), transparent 100%);
    }

    /* Scrollbar vítrea integrada (apenas dentro de #settings) */
    #settings .settings-content{
      scrollbar-width: thin;
      scrollbar-color: color-mix(in oklab, var(--stroke), transparent 70%) transparent;
    }
    #settings .settings-content::-webkit-scrollbar{ width: 8px; }
    #settings .settings-content::-webkit-scrollbar-track{
      background: transparent; margin: 4px 0; border-radius: 8px;
    }
    #settings .settings-content::-webkit-scrollbar-thumb{
      background: color-mix(in oklab, var(--stroke), transparent 78%);
      border-radius: 8px; border: 2px solid transparent; background-clip: content-box;
      box-shadow: inset 0 0 2px rgba(0,0,0,0.12);
    }
    #settings .settings-content::-webkit-scrollbar-thumb:hover{
      background: color-mix(in oklab, var(--stroke), transparent 60%);
    }

    /* Scrollbar vítrea integrada para modal de ajuda */
    #help .help-sidebar,
    #help .help-body{
      scrollbar-width: thin;
      scrollbar-color: color-mix(in oklab, var(--stroke), transparent 70%) transparent;
    }
    #help .help-sidebar::-webkit-scrollbar,
    #help .help-body::-webkit-scrollbar{ 
      width: 8px; 
    }
    #help .help-sidebar::-webkit-scrollbar-track,
    #help .help-body::-webkit-scrollbar-track{
      background: transparent; 
      margin: 4px 0; 
      border-radius: 8px;
    }
    #help .help-sidebar::-webkit-scrollbar-thumb,
    #help .help-body::-webkit-scrollbar-thumb{
      background: color-mix(in oklab, var(--stroke), transparent 78%);
      border-radius: 8px; 
      border: 2px solid transparent; 
      background-clip: content-box;
      box-shadow: inset 0 0 2px rgba(0,0,0,0.12);
    }
    #help .help-sidebar::-webkit-scrollbar-thumb:hover,
    #help .help-body::-webkit-scrollbar-thumb:hover{
      background: color-mix(in oklab, var(--stroke), transparent 60%);
    }

    /* Cards/Groups limpos (sem sólidos opacos) */
    #settings .settings-section{
      margin: 10px 0 14px;
      border: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--c-light) 35%, transparent);
      border-radius: 14px;
    }
    #settings .settings-section .section-head{
      padding: 10px 12px; font-weight: 700; display: flex; align-items: center; gap: 8px;
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
    }
    #settings .settings-section .section-body{
      padding: 12px;
      display: grid; gap: 12px;
    }

    /* Sub-seções em coluna (vertical), nunca lado a lado */
    #settings .subsection{
      background: color-mix(in srgb, var(--c-glass) 10%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
      border-radius: 12px;
      padding: 12px;
      display: grid; gap: 10px;
    }
    #settings .subsection h4{ margin: 0 0 4px; font-size: 13px; }

    /* Linha de controle (label à esquerda; controle à direita) */
    #settings .row{
      display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center;
    }
    #settings .hint{ color: var(--text-muted); font-size: 11px; }

    /* Switch vítreo padronizado (substitui ON/OFF textual) */
    .switch-lg {
      position: relative; width: 44px; height: 24px; border-radius: 999px; cursor: pointer;
      background: color-mix(in oklab, var(--panel), var(--stroke) 20%);
      border: 1px solid color-mix(in oklab, var(--stroke), transparent 40%);
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.06), inset 0 -0.5px 0 rgba(255,255,255,0.04);
      transition: all .2s cubic-bezier(.2,.7,.2,1);
    }
    .switch-lg input{ position: absolute; inset: 0; opacity: 0; }
    .switch-lg .knob{
      position: absolute; top: 2px; left: 2px; width: 20px; height: 20px; border-radius: 50%;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.3), transparent 70%),
        color-mix(in oklab, var(--panel), white 90%);
      border: .5px solid color-mix(in oklab, var(--stroke), transparent 70%);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.4), 0 1px 2px rgba(0,0,0,.1), 0 0 0 .5px rgba(0,0,0,.03);
      transition: transform .2s cubic-bezier(.2,.7,.2,1), box-shadow .15s ease, background .15s ease, border-color .15s ease;
    }
    .switch-lg:hover .knob{
      box-shadow: inset 0 1px 0 rgba(255,255,255,.5), 0 1px 4px rgba(0,0,0,.15), 0 0 0 1px rgba(0,0,0,.05);
    }
    .switch-lg input:checked + .knob{
      transform: translateX(20px);
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.35), transparent 70%),
        color-mix(in oklab, var(--panel), white 85%);
      border-color: color-mix(in oklab, var(--stroke), transparent 60%);
    }

    /* Sliders já ok — apenas reforço do focus-ring */
    .slider-with-output-container .glass-slider:focus-visible::-webkit-slider-thumb{
      box-shadow: inset 0 0.5px 0 rgba(255,255,255,.15), 0 0.5px 2px rgba(0,0,0,.08), 0 0 0 2px color-mix(in oklab, var(--accent), transparent 70%);
    }

    /* Destaque da busca */
    #settings mark.settings-hit{
      background: color-mix(in oklab, var(--accent-2), transparent 75%);
      border-radius: 4px; padding: 0 .2em;
    }

    /* Rodapé do modal (botões discretos à direita) */
    #settings .settings-footer{
      border-top: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      min-height: 44px;
      padding: 12px 16px;
      display: flex; justify-content: flex-end; gap: 8px;
      background: color-mix(in srgb, var(--c-glass) 10%, transparent);
      backdrop-filter: blur(10px) saturate(var(--saturation));
    }

    /* Responsivo: sidebar vira topo em telas estreitas */
    @media (max-width: 720px){
      #settings .settings-shell{ grid-template-columns: 1fr; }
      #settings .settings-nav{ position: static; flex-direction: row; flex-wrap: wrap; }
    }

    /* Lista como listbox acessível */
    #notesList{
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    /* Cartão de nota */
    .note-row{
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      box-shadow:
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 35%, transparent);
      cursor: pointer;
      transition: all 200ms ease;
    }

    .note-row[aria-selected="true"]{
      background: linear-gradient(180deg,
        color-mix(in srgb, var(--c-action) 14%, transparent),
        color-mix(in srgb, var(--c-glass) 10%, transparent));
      border-color: color-mix(in srgb, var(--c-action) 30%, transparent);
    }

    .note-row:hover{
      background: color-mix(in srgb, var(--c-glass) 18%, transparent);
      border-color: color-mix(in srgb, var(--c-light) 18%, transparent);
    }

    .note-title{
      font-weight: 600;
      margin: 0;
      color: var(--c-content);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .note-meta{
      font-size: 11px; color: var(--text-muted);
      margin-top: 4px;
    }

    /* Ações alinhadas e discretas */
    .note-actions{
      display: flex; gap: 6px;
    }
    .note-actions .tbtn{ height: 28px; }

    .shortcuts-grid {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 8px 16px;
      align-items: center;
    }
    .shortcuts-grid code {
      background: var(--panel-strong);
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid var(--stroke);
      font-size: 12px;
    }

    @media print {
      @page {
        margin: 1in;
      }
      body {
        background: #fff !important;
        color: #000 !important;
        font-size: 12pt;
        line-height: 1.4;
        font-family: 'Times New Roman', serif;
      }
      .layout, .editor-shell, .editor-wrap, #editor {
        display: block !important;
        height: auto !important;
        overflow: visible !important;
      }
      header, footer, .gutter, .minimap, .progress, #findBar, #dropzone, dialog {
        display: none !important;
      }
      #editor {
        color: #000 !important;
        background: transparent !important;
        padding: 0 !important;
        white-space: pre-wrap !important; /* Ensure content wraps for printing */
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }
    }

    @media (max-width: 760px){ .notes-list{grid-template-columns: 1fr auto} .note-meta{display:none} }
    @media (max-width: 640px){ .btn .label{display:none} .font-controls{display:none} }
    @media (max-width: 520px){ .brand{display:none} }
    @media (max-width: 480px){ header.toolbar{gap:4px;padding:0 6px} .btn{height:26px;padding:0 6px} .btn-icon{padding:0 4px} }

    /* ========= Liquid Glass tokens extras ========= */
    :root{
      --lg-glass-bg: color-mix(in oklab, var(--bg), white 6%);
      --lg-card-bg: color-mix(in oklab, var(--bg), white 8%);
      --lg-border: var(--stroke);
      --lg-radius: 16px;
      --lg-radius-lg: 20px;
      --focus-ring: 0 0 0 2px color-mix(in oklab, var(--accent), transparent 70%);
    }

    /* Alto contraste opcional (Acessibilidade) */
    html.contrast-plus {
      --panel: rgba(255,255,255,.14);
      --panel-strong: rgba(255,255,255,.20);
      --stroke: rgba(255,255,255,.28);
      --text: #fff;
      --text-dim: #f3f3f3;
      --text-muted: #e6e6e6;
    }

    /* ===== Ajustes: gramática limpa do Liquid Glass no modal ===== */

    /* Variantes de botão para hierarquia visual */
    .tbtn--primary{
      color: var(--c-light);
      background: linear-gradient(135deg,
        color-mix(in srgb, var(--c-action) 60%, transparent),
        color-mix(in srgb, var(--c-action) 25%, var(--c-dark)));
      border-color: color-mix(in srgb, var(--c-action) 40%, transparent);
    }
    .tbtn--ghost{
      background: transparent;
      border-color: color-mix(in srgb, var(--c-light) 8%, transparent);
      box-shadow: none;
    }
    .tbtn--danger{
      color:#ff6b6b;
      border-color: color-mix(in srgb, #ff6b6b 35%, transparent);
    }

    /* Field: label + control + hint coesos */
    .field{ display:grid; gap:6px; }
    .field__row{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; }
    .field__label{
      font-weight:600; color: var(--c-content);
    }
    .field__hint{
      color: var(--text-muted); font-size:11px;
    }

    /* Cards de grupo mais limpos (menos sombra) */
    .group{
      padding:12px;
      border:1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
      border-radius:14px;
      background: color-mix(in srgb, var(--c-glass) 10%, transparent);
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--c-light) 30%, transparent);
    }

    /* Header/Chipbar reduzem ruído visual */
    .settings-head{
      background: color-mix(in srgb, var(--c-glass) 8%, transparent);
      border-bottom:1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
    }
    .settings-chipbar{
      background: color-mix(in srgb, var(--c-glass) 6%, transparent);
      border-bottom:1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
    }

    /* Section = accordions com hierarquia clara */
    .settings-section{
      margin: 12px 16px;
      border-radius:14px;
      border:1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
      background: color-mix(in srgb, var(--c-glass) 10%, transparent);
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--c-light) 28%, transparent);
    }
    .settings-section > summary{
      font-weight:700;
      padding: 12px 14px;
    }
    .settings-section .section-body{
      padding: 12px;
    }

    /* Busca em Ajustes: destaque + estado "sem resultado" */
    mark.settings-hit{
      background: color-mix(in oklab, var(--accent-2), transparent 80%);
      border-radius:4px; padding:0 .2em;
    }
    .settings-empty{
      margin: 12px 16px; padding:12px;
      border-radius:12px; text-align:center;
      color: var(--text-muted);
      border:1px dashed color-mix(in srgb, var(--c-light) 12%, transparent);
      background: color-mix(in srgb, var(--c-glass) 8%, transparent);
    }

    /* Sliders: mesma base, foco visível já coberto; diminui polegar */
    .slider-with-output-container output{ font-weight:600 }
    .glass-slider::-webkit-slider-thumb{ width: 24px; height: 24px; margin-top: -5px; }

    /* ========= Modal base (sheet) ========= */
    .dialog-sheet {
      width: min(96vw, 880px);
      padding: 0;
      border: 1px solid var(--lg-border);
      border-radius: var(--lg-radius-lg);
      background: var(--lg-glass-bg);
      backdrop-filter: blur(var(--lg-blur)) saturate(var(--lg-sat)) contrast(var(--lg-contrast));
      -webkit-backdrop-filter: blur(var(--lg-blur)) saturate(var(--lg-sat)) contrast(var(--lg-contrast));
      box-shadow:
        inset 0 0 0 1px color-mix(in oklab, var(--lg-highlight), transparent 70%),
        0 24px 60px rgba(0,0,0,.35);
    }
    dialog::backdrop{ background: rgba(0,0,0,.45) }

    /* Header do modal */
    .sheet-header{
      display:flex;align-items:center;gap:10px;
      padding:14px 16px;border-bottom:1px solid var(--stroke);
      background: color-mix(in oklab, var(--bg), white 6%);
      backdrop-filter: blur(16px) saturate(140%);
    }
    .sheet-header h3{ margin:0; font-weight:700; font-size:15px }
    .sheet-close{ margin-left:auto }

    /* Layout de conteúdo: sidebar + area */
    .sheet-body{ display:grid; grid-template-columns: 220px 1fr; min-height: 420px }
    .sheet-sidebar{
      border-right:1px solid var(--stroke);
      padding:10px; background: color-mix(in oklab, var(--bg), white 4%);
    }
    .sheet-sidebar .nav{
      display:flex; flex-direction:column; gap:4px;
    }
    .sheet-sidebar .nav button{
      text-align:left; padding:8px 10px; border-radius:10px;
      border:1px solid transparent; background:transparent; color:var(--text);
      cursor:pointer; font-size:12px;
    }
    .sheet-sidebar .nav button:hover{ background: var(--panel) }
    .sheet-sidebar .nav button[aria-current="true"]{
      background: color-mix(in oklab, var(--accent), transparent 88%);
      border-color: color-mix(in oklab, var(--accent), black 35%);
    }

    .sheet-content{ padding:16px 18px 14px; overflow:auto }
    .section{ display:grid; gap:12px; margin-bottom:18px }
    .section h4{ margin:4px 0 2px; font-size:13px }

    /* Cartões de grupo */
    .group{
      padding:12px; border:1px solid var(--stroke); border-radius:14px;
      background: var(--lg-card-bg);
    }

    /* Linha de controle (label à esquerda, controle à direita) */
    .row{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center }
    .hint{ color: var(--text-muted); font-size:11px }
    label .hint{ margin-left:8px; opacity:.8 }

    /* Segmented control (Liquid Glass), em cima do switcher que você enviou */
    .segmented{
      display:inline-flex; padding:4px; gap:4px; border-radius:999px;
      background: color-mix(in oklab, var(--c-glass) 14%, transparent);
      backdrop-filter: blur(10px) saturate(var(--lg-sat));
      border:1px solid var(--stroke);
    }
    .segmented input{ position:absolute; opacity:0; width:0; height:0 }
    .segmented label{
      position:relative; padding:6px 10px; border-radius:999px; font-size:12px;
      cursor:pointer; user-select:none; border:1px solid transparent;
    }
    .segmented label:hover{ background: var(--panel-strong) }
    .segmented input:checked + label{
      background: color-mix(in oklab, var(--accent), transparent 85%);
      border-color: var(--accent);
      color: var(--c-text-strong);
    }

    /* Controle segmentado alternativo para configurações específicas */
    .segmented-control{
      display:inline-flex; padding:3px; gap:2px; border-radius:12px;
      background: color-mix(in oklab, var(--c-glass) 10%, transparent);
      backdrop-filter: blur(8px) saturate(var(--lg-sat));
      border:1px solid var(--stroke);
    }
    .segmented-control input{ position:absolute; opacity:0; width:0; height:0 }
    .segmented-control label{
      position:relative; padding:8px 12px; border-radius:10px; font-size:13px;
      cursor:pointer; user-select:none; border:1px solid transparent;
      transition: all 0.15s ease;
    }
    .segmented-control label:hover{ 
      background: color-mix(in oklab, var(--panel-strong), transparent 50%);
    }
    .segmented-control input:checked + label{
      background: color-mix(in oklab, var(--accent), transparent 80%);
      border-color: color-mix(in oklab, var(--accent), transparent 60%);
      color: var(--c-text-strong);
      box-shadow: 0 2px 4px color-mix(in oklab, var(--accent), transparent 90%);
    }

    /* Sliders já estão lindos; só foco visível */
    .range-control input[type="range"]:focus-visible{
      outline: none; box-shadow: var(--focus-ring);
    }

    /* Switch foco */
    .switch:focus-visible{ outline: none; box-shadow: var(--focus-ring) }

    /* ========= Help Center v2 — Liquid Glass ========= */
    #help {
      --dialog-max-width: 720px;
      --dialog-height: 75vh;
    }
    
    .help-content {
      padding: 0;
      display: flex;
      height: 60vh;
      min-height: 480px;
      max-height: 75vh;
    }
    
    /* Help Sidebar */
    .help-sidebar {
      width: 200px;
      background: color-mix(in srgb, var(--c-glass) 8%, transparent);
      border-right: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      padding: 16px 0;
      overflow-y: auto;
    }
    
    .help-nav-section {
      margin-bottom: 20px;
    }
    
    .help-nav-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: color-mix(in srgb, var(--c-content) 60%, transparent);
      padding: 0 16px 8px;
      margin: 0;
    }
    
    .help-nav-item {
      display: flex;
      align-items: center;
      padding: 8px 16px;
      color: color-mix(in srgb, var(--c-content) 80%, transparent);
      font-size: 13px;
      cursor: pointer;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
      transition: all 0.2s ease;
      border-radius: 0 6px 6px 0;
      margin-right: 6px;
    }
    
    .help-nav-item:hover {
      background: color-mix(in srgb, var(--c-action) 10%, transparent);
      color: var(--c-action);
    }
    
    .help-nav-item.active {
      background: color-mix(in srgb, var(--c-action) 15%, transparent);
      color: var(--c-action);
      font-weight: 500;
    }
    
    .help-nav-item .ticon {
      width: 14px;
      height: 14px;
      margin-right: 8px;
      opacity: 0.7;
    }
    
    /* Help Main Content */
    .help-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    /* Help Header with Search */
    .help-header {
      padding: 20px 24px 16px;
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      background: color-mix(in srgb, var(--c-glass) 6%, transparent);
    }
    
    .help-title {
      font-size: 20px;
      font-weight: 600;
      color: var(--c-content);
      margin: 0 0 12px;
    }
    
    .help-search-container {
      position: relative;
    }
    
    .help-search {
      width: 100%;
      padding: 10px 12px 10px 36px;
      border: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      border-radius: 8px;
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      color: var(--c-content);
      font-size: 14px;
      outline: none;
      transition: all 0.2s ease;
    }
    
    .help-search:focus {
      border-color: var(--c-action);
      background: color-mix(in srgb, var(--c-glass) 18%, transparent);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--c-action) 15%, transparent);
    }
    
    .help-search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      color: color-mix(in srgb, var(--c-content) 50%, transparent);
      pointer-events: none;
    }
    
    /* Help Content Area */
    .help-body {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
    }
    
    .help-section {
      display: none;
    }
    
    .help-section.active {
      display: block;
      animation: helpFadeIn 0.3s ease;
    }
    
    @keyframes helpFadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .help-section h2 {
      font-size: 18px;
      font-weight: 600;
      color: var(--c-content);
      margin: 0 0 16px;
    }
    
    .help-section h3 {
      font-size: 15px;
      font-weight: 500;
      color: var(--c-content);
      margin: 20px 0 12px;
    }
    
    .help-section p {
      font-size: 14px;
      line-height: 1.5;
      color: color-mix(in srgb, var(--c-content) 80%, transparent);
      margin: 0 0 12px;
    }
    
    /* Keyboard Shortcuts - Coluna Única Vertical com Largura Fixa */
    .shortcuts-grid {
      display: flex;
      flex-direction: column;
      gap: 0;
      margin: 16px 0;
      width: 100%;
      max-width: 100%;
    }
    
    .shortcuts-category {
      margin: 24px 0 12px 0;
      width: 100%;
    }
    
    .shortcuts-category:first-child {
      margin-top: 0;
    }
    
    .shortcuts-category-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--c-action);
      margin-bottom: 12px;
      padding-bottom: 6px;
      border-bottom: 1px solid color-mix(in srgb, var(--c-action) 20%, transparent);
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
    }
    
    .shortcuts-category-icon {
      width: 16px;
      height: 16px;
      opacity: 0.8;
      flex-shrink: 0;
    }
    
    .shortcuts-list {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 0;
    }
    
    .shortcut-item {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      padding: 14px 16px;
      background: color-mix(in srgb, var(--c-glass) 6%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 8%, transparent);
      margin-bottom: 1px;
      transition: all 0.2s ease;
      position: relative;
      width: 100%;
      box-sizing: border-box;
      min-height: 60px; /* Altura mínima consistente */
      gap: 16px; /* Espaçamento fixo entre conteúdo e teclas */
    }
    
    .shortcut-item:first-child {
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
    }
    
    .shortcut-item:last-child {
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      margin-bottom: 0;
    }
    
    .shortcut-item:hover {
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      border-color: color-mix(in srgb, var(--c-action) 25%, transparent);
      transform: translateX(2px);
    }
    
    .shortcut-info {
      flex: 1;
      min-width: 0;
      max-width: calc(100% - 180px); /* Garante espaço para as teclas */
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 4px;
    }
    
    .shortcut-desc {
      font-size: 14px;
      font-weight: 500;
      color: var(--c-content);
      margin: 0;
      line-height: 1.3;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .shortcut-detail {
      font-size: 13px;
      color: color-mix(in srgb, var(--c-content) 65%, transparent);
      line-height: 1.4;
      margin: 0;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    .shortcut-keys {
      display: flex;
      gap: 4px;
      align-items: center;
      flex-shrink: 0;
      flex-wrap: wrap;
      justify-content: flex-end;
      min-width: 140px; /* Largura mínima para as teclas */
      max-width: 160px; /* Largura máxima para as teclas */
    }
    
    .key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 28px;
      height: 28px;
      padding: 0 8px;
      font-size: 12px;
      font-weight: 600;
      color: color-mix(in srgb, var(--c-content) 85%, transparent);
      background: color-mix(in srgb, var(--c-glass) 15%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 25%, transparent);
      border-radius: 6px;
      box-shadow: 
        0 1px 2px color-mix(in srgb, var(--c-dark) 8%, transparent),
        inset 0 1px 0 color-mix(in srgb, var(--c-light) 20%, transparent);
      font-family: var(--code-font);
      white-space: nowrap;
      flex-shrink: 0;
    }
    
    .key-plus {
      color: color-mix(in srgb, var(--c-content) 40%, transparent);
      margin: 0 2px;
      font-size: 11px;
      font-weight: 500;
      flex-shrink: 0;
    }
    
    /* Responsive adjustments */
    @media (max-width: 640px) {
      .shortcut-item {
        flex-direction: column;
        gap: 12px;
        align-items: stretch;
        min-height: 80px; /* Altura mínima maior em mobile */
        padding: 16px;
      }
      
      .shortcut-info {
        max-width: 100%;
      }
      
      .shortcut-keys {
        justify-content: flex-start;
        min-width: auto;
        max-width: 100%;
        margin-top: 4px;
      }
      
      .key {
        min-width: 24px;
        height: 24px;
        font-size: 11px;
        padding: 0 6px;
      }
    }
    
    @media (max-width: 480px) {
      .shortcut-item {
        padding: 12px 14px;
        min-height: 70px;
      }
      
      .shortcut-desc {
        font-size: 13px;
      }
      
      .shortcut-detail {
        font-size: 12px;
      }
      
      .shortcuts-category-title {
        font-size: 15px;
      }
    }
    
    /* Special styling for different categories */
    .shortcuts-category[data-category="Arquivos"] .shortcuts-category-title {
      color: #3b82f6;
    }
    
    .shortcuts-category[data-category="Edição"] .shortcuts-category-title {
      color: #10b981;
    }
    
    .shortcuts-category[data-category="Busca e Navegação"] .shortcuts-category-title {
      color: #f59e0b;
    }
    
    .shortcuts-category[data-category="Visualização"] .shortcuts-category-title {
      color: #8b5cf6;
    }
    
    .shortcuts-category[data-category="Sistema"] .shortcuts-category-title {
      color: #ef4444;
    }
    
    .shortcuts-category[data-category="Especiais"] .shortcuts-category-title {
      color: #6b7280;
    }
    
    /* Search Results */
    .help-search-results {
      margin-top: 16px;
    }
    
    .search-result-item {
      padding: 12px 16px;
      margin-bottom: 8px;
      background: color-mix(in srgb, var(--c-glass) 6%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .search-result-item:hover {
      background: color-mix(in srgb, var(--c-action) 8%, transparent);
      border-color: color-mix(in srgb, var(--c-action) 25%, transparent);
    }
    
    .search-result-title {
      font-size: 14px;
      font-weight: 500;
      color: var(--c-content);
      margin-bottom: 4px;
    }
    
    .search-result-snippet {
      font-size: 13px;
      color: color-mix(in srgb, var(--c-content) 70%, transparent);
      line-height: 1.4;
    }
    
    .search-highlight {
      background: color-mix(in srgb, var(--c-action) 25%, transparent);
      color: var(--c-action);
      padding: 1px 2px;
      border-radius: 2px;
    }
    
    /* Feature Cards */
    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin: 16px 0;
    }
    
    .feature-card {
      padding: 16px;
      background: color-mix(in srgb, var(--c-glass) 6%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      border-radius: 10px;
      transition: all 0.2s ease;
    }
    
    .feature-card:hover {
      background: color-mix(in srgb, var(--c-glass) 10%, transparent);
      border-color: color-mix(in srgb, var(--c-action) 25%, transparent);
      transform: translateY(-1px);
    }
    
    .feature-icon {
      width: 20px;
      height: 20px;
      color: var(--c-action);
      margin-bottom: 8px;
    }
    
    .feature-title {
      font-size: 15px;
      font-weight: 500;
      color: var(--c-content);
      margin-bottom: 6px;
    }
    
    .feature-desc {
      font-size: 13px;
      color: color-mix(in srgb, var(--c-content) 70%, transparent);
      line-height: 1.4;
    }

    /* Professional Feature Sections */
    .feature-section {
      margin: 24px 0;
      padding: 20px;
      background: color-mix(in srgb, var(--c-glass) 4%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 8%, transparent);
      border-radius: 12px;
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--c-light) 20%, transparent);
    }

    .feature-section h3 {
      font-size: 16px;
      font-weight: 600;
      color: var(--c-content);
      margin: 0 0 16px 0;
      padding-bottom: 8px;
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
    }

    .feature-list {
      margin: 0;
      padding: 0;
      list-style: none;
    }

    .feature-list li {
      margin: 12px 0;
      padding-left: 16px;
      position: relative;
      font-size: 14px;
      line-height: 1.5;
      color: color-mix(in srgb, var(--c-content) 85%, transparent);
    }

    .feature-list li::before {
      content: '';
      position: absolute;
      left: 0;
      top: 8px;
      width: 4px;
      height: 4px;
      background: var(--c-action);
      border-radius: 50%;
    }

    .feature-list li strong {
      color: var(--c-content);
      font-weight: 500;
    }

    /* Platform Detection for Shortcuts */
    @media (max-width: 640px) {
      .help-content {
        flex-direction: column;
        height: auto;
        max-height: 80vh;
      }
      
      .help-sidebar {
        width: auto;
        max-height: 120px;
        border-right: none;
        border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
        padding: 12px 16px;
        overflow-x: auto;
        overflow-y: hidden;
        white-space: nowrap;
      }
      
      .help-nav-section {
        display: inline-block;
        margin-right: 20px;
        margin-bottom: 0;
      }
      
      .help-nav-item {
        display: inline-flex;
        margin-right: 8px;
        border-radius: 6px;
        white-space: nowrap;
      }
    }

    /* Legacy compatibility */
    .cards{ display:grid; gap:12px; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); }
    .card{
      padding:12px; border:1px solid var(--stroke); border-radius:14px; background: var(--lg-card-bg);
    }
    .shortcut-row{ display:grid; grid-template-columns: 1fr auto; gap:6px; align-items:center; padding:6px 8px; border-bottom:1px dashed color-mix(in oklab, var(--stroke), white 20%) }
    .shortcut-row:last-child{ border-bottom:0 }
    kbd{ font-family: var(--code-font); font-size:11px; padding:.15em .45em; border:1px solid var(--stroke); border-radius:6px; background:var(--panel) }

    @media (max-width: 720px){
      .sheet-body{ grid-template-columns: 1fr } /* sidebar vira topo */
      .sheet-sidebar{ border-right:0; border-bottom:1px solid var(--stroke) }
    }

    /* === AJUSTES UNO – mesmo paradigma da toolbar/findbar === */

    /* Cabeçalho do sheet com busca e chipbar */
    .settings-head {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      padding: 12px 16px;
      background: color-mix(in srgb, var(--c-glass) 10%, transparent);
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
    }
    .settings-title {
      display: flex; align-items: center; gap: 10px;
      font-weight: 700; font-size: 15px;
    }
    .settings-actions { display: flex; gap: 8px; align-items: center; }

    /* Busca em ajustes: mesma gramática da .find-input */
    #settingsSearch {
      height: 36px; min-width: 220px; max-width: 420px;
      padding: 0 12px; border-radius: 12px;
      border: 1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      color: var(--c-content); outline: none; font: 600 12px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--c-light) 40%, transparent);
    }
    #settingsSearch:focus {
      border-color: var(--c-action);
      box-shadow: 0 0 0 2px color-mix(in srgb, var(--c-action) 60%, transparent);
    }

    /* Chipbar de seções – sticky dentro do conteúdo */
    .settings-chipbar {
      position: sticky; top: 0; z-index: 2;
      display: flex; gap: 6px; padding: 10px 16px;
      border-bottom: 1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
      background: color-mix(in srgb, var(--c-glass) 8%, transparent);
      backdrop-filter: blur(10px) saturate(var(--saturation));
      -webkit-backdrop-filter: blur(10px) saturate(var(--saturation));
    }
    .settings-chipbar .chip {
      height: 28px; padding: 0 10px; border-radius: 999px;
      color: var(--c-content);
      background: color-mix(in srgb, var(--c-glass) 14%, transparent);
      border: 1px solid color-mix(in srgb, var(--c-light) 10%, transparent);
      font: 700 11px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      cursor: pointer; transition: transform .14s ease, color .2s ease;
    }
    .settings-chipbar .chip:hover { transform: translateY(-1px); color: var(--c-action); }
    .settings-chipbar .chip[aria-current="true"] {
      color: var(--c-light);
      background: linear-gradient(135deg, color-mix(in srgb, var(--c-action) 60%, transparent), color-mix(in srgb, var(--c-action) 25%, var(--c-dark)));
      border-color: color-mix(in srgb, var(--c-action) 40%, transparent);
    }

    /* Acordions de seção */
    .settings-section {
      margin: 12px 16px; border-radius: 14px;
      border: 1px solid color-mix(in srgb, var(--c-light) 12%, transparent);
      background: color-mix(in srgb, var(--c-glass) 12%, transparent);
      box-shadow: inset 0 1px 0 color-mix(in srgb, var(--c-light) 35%, transparent);
      overflow: clip;
    }
    .settings-section > summary {
      list-style: none; cursor: pointer; user-select: none;
      padding: 12px 14px; font-weight: 700; display: flex; align-items: center; gap: 8px;
    }
    .settings-section > summary::-webkit-details-marker { display: none; }
    .settings-section > summary .chev {
      width: 12px; height: 12px; transform: rotate(-90deg); transition: transform 180ms var(--ease);
      opacity: .85;
    }
    .settings-section[open] > summary .chev { transform: rotate(0deg); }
    .settings-section .section-body { padding: 12px 12px 14px; }

    /* Grid das linhas (reusa sua .row) + variações responsivas */
    .settings-grid {
      display: grid; gap: 12px;
    }
    @media (min-width: 760px){
      .settings-grid.two-col { grid-template-columns: 1fr 1fr; }
    }

    /* Quick toggles no topo do conteúdo */
    .quick-toggles {
      display: flex; flex-wrap: wrap; gap: 8px; padding: 12px 16px 0;
    }

    /* Marcação de busca */
    mark.settings-hit {
      background: color-mix(in oklab, var(--accent-2), transparent 75%);
      border-radius: 4px; padding: 0 .2em;
    }

    /* Respeito ao reduce-motion */
    @media (prefers-reduced-motion: no-preference) {
      .settings-section[open] .section-body {
        animation: sec-reveal 180ms var(--ease);
      }
    }
    @keyframes sec-reveal {
      from { opacity: 0; transform: translateY(-2px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
  <!-- SVG filter noise for liquid-y feel (degrades gracefully) -->
  <svg width="0" height="0" style="position:absolute">
    <filter id="lg-wobble" x="-20%" y="-20%" width="140%" height="140%">
      <feTurbulence type="fractalNoise" baseFrequency=".75" numOctaves="2" seed="2" result="noise"/>
      <feDisplacementMap in="SourceGraphic" in2="noise" scale="1.2" xChannelSelector="R" yChannelSelector="G"/>
    </filter>
  </svg>
</head>
<body>
  <div class="layout">
    <div class="progress" id="progress"></div>
    
    <!-- Toolbar integrada como AppBar única -->
    <div class="header-toolbar">
      <div class="toolbar toolbar--attached" role="toolbar" aria-label="Ferramentas do editor">
        <!-- ESQUERDA: marca + título da nota -->
        <div class="tgroup" role="group" aria-label="Contexto">
          <span class="brand-dot" aria-hidden="true"></span>
          <button id="noteTitleChip" class="title-chip" title="Renomear (F2)" aria-label="Título da nota (duplo clique para renomear)">
            <svg class="ticon ticon--stroke" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M4 20h4l10-10a2.828 2.828 0 0 0-4-4L4 16v4z"></path>
              <path d="M13.5 6.5l4 4"></path>
            </svg>
            <span id="noteTitleChipText">—</span>
          </button>
        </div>

        <!-- Grupo: Notas/Arquivo (sem Abrir/Salvar/Imprimir) -->
        <div class="tgroup" role="group" aria-label="Notas">
          <button class="tbtn" id="btnNotes" title="Notas (⌘O)">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M3 7h18"/><path d="M3 12h18"/><path d="M3 17h12"/></svg>
            <span>Notas</span>
          </button>
          <button class="tbtn" id="btnNew" title="Nova nota (⌘N)">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M5 12h14"/></svg>
            <span>Nova</span>
          </button>
        </div>

        <!-- Formatação -->
        <div class="tgroup" role="group" aria-label="Formatação">
          <button class="tbtn" id="btnToggleWrap" data-toggle aria-pressed="false" title="Quebra automática (Alt+Z)">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M3 7h10"/><path d="M21 7h-6"/><path d="M3 12h14"/><path d="M3 17h10"/><path d="m21 17-3 3-3-3"/></svg>
            <span>Quebra</span>
          </button>

          <button class="tbtn tbtn--icon" id="btnFontDown" title="Diminuir letra (Ctrl+-)" aria-label="Diminuir tamanho da letra">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M4 7V4h16v3M9 20h6M12 4v16"/>
              <path d="m8 14 2-2 2 2"/>
            </svg>
          </button>
          <span id="fontSizeDisplay" style="min-width:20px;padding:0 4px;font-size:10px;font-weight:600;color:var(--c-content);text-align:center;line-height:1.2;font-family:var(--code-font);user-select:none">10</span>
          <button class="tbtn tbtn--icon" id="btnFontUp" title="Aumentar letra (Ctrl++)" aria-label="Aumentar tamanho da letra">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M4 7V4h16v3M9 20h6M12 4v16"/>
              <path d="m8 10 2 2 2-2"/>
            </svg>
          </button>

          <button class="tbtn" id="btnToggleLines" data-toggle aria-pressed="false" title="Números de linha">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h13"/><path d="M8 12h13"/><path d="M8 18h13"/><path d="M3 6h2"/><path d="M3 12h2"/><path d="M3 18h2"/></svg>
            <span>Linhas</span>
          </button>
          <button class="tbtn" id="btnToggleMini" data-toggle aria-pressed="false" title="Minimap">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="5" width="10" height="14" rx="2"/><rect x="16" y="5" width="5" height="14" rx="2"/></svg>
            <span>Minimap</span>
          </button>
        </div>

        <div class="tspacer" aria-hidden="true"></div>

        <!-- Busca -->
        <div class="tgroup" role="group" aria-label="Busca">
          <label class="tsearch">
            <input class="tsearch__input" id="globalSearch" type="search" placeholder="Buscar…" title="Buscar no documento (⌘F)" aria-controls="findBar" aria-expanded="false"/>
            <svg class="tsearch__icon" viewBox="0 0 24 24" aria-hidden="true">
              <circle cx="11" cy="11" r="6" stroke="currentColor" stroke-width="2" fill="none"/>
              <path d="m17 17 4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </label>
        </div>

        <!-- Mais -->
        <div class="tgroup" role="group" aria-label="Mais">
          <button class="tbtn tbtn--icon" id="btnSettings" title="Ajustes (⌘,)" aria-haspopup="dialog" aria-controls="settings">
            <!-- License: MIT. Made by radix-ui: https://github.com/radix-ui/icons -->
            <svg class="ticon" viewBox="0 0 15 15" aria-hidden="true">
              <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M7.07095 0.650238C6.67391 0.650238 6.32977 0.925096 6.24198 1.31231L6.0039 2.36247C5.6249 2.47269 5.26335 2.62363 4.92436 2.81013L4.01335 2.23585C3.67748 2.02413 3.23978 2.07312 2.95903 2.35386L2.35294 2.95996C2.0722 3.2407 2.0232 3.6784 2.23493 4.01427L2.80942 4.92561C2.62307 5.2645 2.47227 5.62594 2.36216 6.00481L1.31209 6.24287C0.924883 6.33065 0.650024 6.6748 0.650024 7.07183V7.92897C0.650024 8.32601 0.924883 8.67015 1.31209 8.75794L2.36228 8.99603C2.47246 9.375 2.62335 9.73652 2.80979 10.0755L2.2354 10.9867C2.02367 11.3225 2.07267 11.7602 2.35341 12.041L2.95951 12.6471C3.24025 12.9278 3.67795 12.9768 4.01382 12.7651L4.92506 12.1907C5.26384 12.377 5.62516 12.5278 6.0039 12.6379L6.24198 13.6881C6.32977 14.0753 6.67391 14.3502 7.07095 14.3502H7.92809C8.32512 14.3502 8.66927 14.0753 8.75705 13.6881L8.99505 12.6383C9.37411 12.5282 9.73573 12.3773 10.0748 12.1909L10.986 12.7653C11.3218 12.977 11.7595 12.928 12.0403 12.6473L12.6464 12.0412C12.9271 11.7604 12.9761 11.3227 12.7644 10.9869L12.1902 10.076C12.3768 9.73688 12.5278 9.37515 12.638 8.99596L13.6879 8.75794C14.0751 8.67015 14.35 8.32601 14.35 7.92897V7.07183C14.35 6.6748 14.0751 6.33065 13.6879 6.24287L12.6381 6.00488C12.528 5.62578 12.3771 5.26414 12.1906 4.92507L12.7648 4.01407C12.9766 3.6782 12.9276 3.2405 12.6468 2.95975L12.0407 2.35366C11.76 2.07292 11.3223 2.02392 10.9864 2.23565L10.0755 2.80989C9.73622 2.62328 9.37437 2.47229 8.99505 2.36209L8.75705 1.31231C8.66927 0.925096 8.32512 0.650238 7.92809 0.650238H7.07095ZM4.92053 3.81251C5.44724 3.44339 6.05665 3.18424 6.71543 3.06839L7.07095 1.50024H7.92809L8.28355 3.06816C8.94267 3.18387 9.5524 3.44302 10.0794 3.81224L11.4397 2.9547L12.0458 3.56079L11.1882 4.92117C11.5573 5.44798 11.8164 6.0575 11.9321 6.71638L13.5 7.07183V7.92897L11.932 8.28444C11.8162 8.94342 11.557 9.55301 11.1878 10.0798L12.0453 11.4402L11.4392 12.0462L10.0787 11.1886C9.55192 11.5576 8.94241 11.8166 8.28355 11.9323L7.92809 13.5002H7.07095L6.71543 11.932C6.0569 11.8162 5.44772 11.5572 4.92116 11.1883L3.56055 12.046L2.95445 11.4399L3.81213 10.0794C3.4431 9.55266 3.18403 8.94326 3.06825 8.2845L1.50002 7.92897V7.07183L3.06818 6.71632C3.18388 6.05765 3.44283 5.44833 3.81171 4.92165L2.95398 3.561L3.56008 2.95491L4.92053 3.81251ZM9.02496 7.50008C9.02496 8.34226 8.34223 9.02499 7.50005 9.02499C6.65786 9.02499 5.97513 8.34226 5.97513 7.50008C5.97513 6.65789 6.65786 5.97516 7.50005 5.97516C8.34223 5.97516 9.02496 6.65789 9.02496 7.50008ZM9.92496 7.50008C9.92496 8.83932 8.83929 9.92499 7.50005 9.92499C6.1608 9.92499 5.07513 8.83932 5.07513 7.50008C5.07513 6.16084 6.1608 5.07516 7.50005 5.07516C8.83929 5.07516 9.92496 6.16084 9.92496 7.50008Z"
                fill="currentColor"
              />
            </svg>
          </button>
          <button class="tbtn tbtn--icon" id="btnHelp" title="Ajuda (⌘/)" aria-haspopup="dialog" aria-controls="help">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>
          </button>
          <button class="tbtn tbtn--icon" id="btnMarkdownPreview" title="Visualizar Markdown (⌘⇧P)" aria-haspopup="dialog" aria-controls="mdv">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
              <polyline points="14,2 14,8 20,8"/>
              <line x1="16" y1="13" x2="8" y2="13"/>
              <line x1="16" y1="17" x2="8" y2="17"/>
              <polyline points="10,9 9,9 8,9"/>
            </svg>
          </button>
          <button class="tbtn tbtn--icon" aria-label="Mais" aria-haspopup="menu" aria-expanded="false" data-popover="#more-menu">
            <svg class="ticon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="5" cy="12" r="1.5" fill="currentColor"/><circle cx="12" cy="12" r="1.5" fill="currentColor"/><circle cx="19" cy="12" r="1.5" fill="currentColor"/></svg>
          </button>

          <!-- MORE MENU expandido -->
          <div id="more-menu" class="popover" role="menu" hidden>
            <div class="menu-section" aria-label="Arquivo">Arquivo</div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmOpen">Abrir…</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmSave">Salvar como .md</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="btnImportFromPopover">Importar…</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="btnExportFromPopover">Exportar…</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmPrint">Imprimir (⌘P)</button></div>

            <div class="menu-divider" role="separator"></div>

            <div class="menu-section" aria-label="Notas">Notas</div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmRename">Renomear</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmDuplicate">Duplicar</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmExportAll">Exportar Tudo</button></div>

            <div class="menu-divider" role="separator"></div>

            <div class="menu-section" aria-label="Exibir">Exibir</div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmMarkdownPreview">Visualizar Markdown</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitemcheckbox" aria-checked="false" id="mmToggleWrap">Quebra automática</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitemcheckbox" aria-checked="false" id="mmToggleLines">Números de linha</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitemcheckbox" aria-checked="false" id="mmToggleMini">Minimap</button></div>

            <div class="menu-divider" role="separator"></div>

            <div class="menu-section" aria-label="Ajuda">Ajuda</div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmSettings">Ajustes</button></div>
            <div class="popover__item"><button class="tbtn popover__btn" role="menuitem" id="mmShortcuts">Atalhos</button></div>
          </div>
        </div>
      </div>
    </div>

    <main class="editor-shell" id="shell" style="grid-row: 2; overflow: hidden; min-height: 0;">
      <aside class="gutter" id="gutter" aria-hidden="true"></aside>
      <section class="editor-wrap">
        <div id="highlights" class="highlights-overlay" aria-hidden="true"></div>
        <textarea id="editor" wrap="off" autocapitalize="off" autocomplete="off" autocorrect="off" aria-label="Área de edição"></textarea>
        
        <div id="findBar" class="toolbar" role="toolbar" aria-label="Buscar e Substituir" hidden>
          <!-- Linha principal: busca + navegação + contador + fechar -->
          <div class="find-primary-row">
            <input class="find-input" id="findInput" placeholder="Buscar…" autocomplete="off" spellcheck="false"/>
            
            <button class="tbtn tbtn--icon" id="btnFindPrev" title="Anterior (Shift+Enter)" aria-label="Resultado anterior">
              <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
            </button>
            
            <button class="tbtn tbtn--icon" id="btnFindNext" title="Próximo (Enter)" aria-label="Próximo resultado">
              <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
            </button>
            
            <span class="find-count-display" id="findCount" aria-live="polite">0/0</span>
            
            <button class="tbtn tbtn--icon" id="btnFindClose" title="Fechar (Esc)" aria-label="Fechar busca">
              <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
            </button>
          </div>
          
          <!-- Linha de substituir (inicialmente oculta) -->
          <div class="find-replace-row" id="replaceRow" hidden>
            <input class="find-input" id="replaceInput" placeholder="Substituir por…" autocomplete="off" spellcheck="false"/>
            
            <button class="tbtn" id="btnDoReplace" title="Substituir atual (Enter)">
              <span>Substituir</span>
            </button>
            
            <button class="tbtn" id="btnDoReplaceAll" title="Substituir todos (Ctrl+Enter)">
              <span>Todos</span>
            </button>
          </div>
          
          <!-- Linha de opções -->
          <div class="find-options-row">
            <button id="optCase" class="find-option-toggle" type="button" title="Diferenciar maiúsculas e minúsculas" aria-pressed="false">
              <span>Aa</span>
            </button>
            
            <button id="optRegex" class="find-option-toggle" type="button" title="Expressão Regular (RegEx)" aria-pressed="false">
              <span>.*</span>
            </button>
            
            <button id="optMultiline" class="find-option-toggle" type="button" title="Busca Multilinha" aria-pressed="false">
              <span>^$</span>
            </button>
            
            <button class="tbtn" id="btnToggleReplace" title="Alternar modo substituir" aria-pressed="false">
              <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12h18m-9-9l9 9-9 9"/></svg>
              <span>Substituir</span>
            </button>
          </div>
        </div>
        
        <div id="goToLine" class="toolbar" role="toolbar" aria-label="Ir para Linha" hidden>
            <div class="find-primary-row">
                <input class="find-input" id="goToLineInput" type="number" placeholder="Ir para linha..." min="1" autocomplete="off"/>
                
                <button class="tbtn tbtn--icon" id="btnGoToLineExecute" title="Ir (Enter)" aria-label="Ir para linha">
                    <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
                </button>
                
                <button class="tbtn tbtn--icon" id="btnGoToLineClose" title="Fechar (Esc)" aria-label="Fechar ir para linha">
                    <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                </button>
            </div>
        </div>

      </section>
      <aside class="minimap" id="minimap" aria-hidden="true" hidden tabindex="0" title="Navegação do Minimap: Setas, PageUp/Down, Home/End. Enter para voltar ao editor.">
        <pre id="miniText"></pre>
        <div class="mini-viewport" id="miniViewport" style="top:0;height:40px"></div>
      </aside>
    </main>

    <div id="dropzone" class="dropzone-overlay" hidden>
      <div class="dropzone-content glass-panel">
        <div class="dropzone-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" x2="12" y1="3" y2="15"/>
          </svg>
        </div>
        <h2 class="dropzone-title">Solte o arquivo aqui</h2>
        <p class="dropzone-subtitle">Suporte para arquivos .txt e .md</p>
      </div>
    </div>

    <footer class="status lg-surface">
      <span class="pill"><strong id="lncol">Ln 1, Col 1</strong></span>
      <span class="sep"></span>
      <span id="wordCount">0 palavras</span>
      <span class="sep" id="selectionSep" hidden></span>
      <span id="selectionStats" hidden></span>
      <span class="sep"></span>
      <span id="wrapState">Sem quebra</span>
      <span class="sep"></span>
      <span id="noteTitle">—</span>
      <div class="spacer"></div>
      <span id="saveStatus" aria-live="polite"></span>
    </footer>
  </div>

  <input type="file" id="file" accept=".txt,.md,.markdown,.rtf,.html,.htm" hidden />

  <!-- ========== Ajustes (novo) ========== -->
  <dialog id="settings" class="dialog-sheet" aria-modal="true" aria-labelledby="settingsTitle">
    <!-- Cabeçalho -->
    <div class="settings-head">
      <div class="settings-title">
        <h3 id="settingsTitle" style="margin:0;">Ajustes</h3>
        <input id="settingsSearch" type="search" placeholder="Buscar ajustes…" aria-label="Buscar ajustes">
      </div>
      <div class="settings-actions">
        <button class="tbtn" id="btnExportSettings">Exportar</button>
        <button class="tbtn" id="btnImportFromSettings">Importar</button>
        <button class="tbtn" id="btnResetSettings" title="Restaurar padrões">Reset</button>
        <button class="tbtn sheet-close" value="cancel" title="Fechar" aria-label="Fechar">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
    </div>

    <!-- Corpo (sidebar + conteúdo) -->
    <div class="settings-shell">
      <nav class="settings-nav" role="tablist" aria-label="Seções de ajustes">
        <button data-jump="#sec-appearance" aria-current="true">Aparência</button>
        <button data-jump="#sec-editor">Editor</button>
        <button data-jump="#sec-interface">Interface</button>
        <button data-jump="#sec-accessibility">Acessibilidade</button>
        <button data-jump="#sec-files">Notas & Arquivos</button>
        <button data-jump="#sec-advanced">Avançado</button>
        <button data-jump="#sec-about">Sobre</button>
      </nav>

      <div class="settings-content" id="settingsBody">
        <!-- Aparência -->
        <section class="settings-section" id="sec-appearance">
          <div class="section-head">Aparência</div>
          <div class="section-body">
            <div class="subsection">
              <h4>Tema</h4>
              <div class="row">
                <div class="hint">Aparência do sistema</div>
                <div class="segmented" role="radiogroup" aria-label="Tema">
                  <input id="theme-auto" type="radio" name="theme" value="auto" checked><label for="theme-auto">Auto</label>
                  <input id="theme-light" type="radio" name="theme" value="light"><label for="theme-light">Claro</label>
                  <input id="theme-dark" type="radio" name="theme" value="dark"><label for="theme-dark">Escuro</label>
                </div>
              </div>
            </div>

            <div class="subsection">
              <h4>Liquid Glass</h4>
              <div class="row">
                <label for="glassBlur">Desfoque</label>
                <div class="slider-with-output-container" id="glassBlurWrap">
                  <output class="glass-ui slider-output" for="glassBlur" id="glassBlurValue">18px</output>
                  <input id="glassBlur" class="glass-slider" type="range" min="8" max="28" step="1">
                </div>
              </div>
              <div class="row">
                <label for="glassSat">Saturação</label>
                <div class="slider-with-output-container" id="glassSatWrap">
                  <output class="glass-ui slider-output" for="glassSat" id="glassSatValue">135%</output>
                  <input id="glassSat" class="glass-slider" type="range" min="100" max="170" step="5">
                </div>
              </div>
              <div class="row">
                <label for="glassContrast">Contraste</label>
                <div class="slider-with-output-container" id="glassContrastWrap">
                  <output class="glass-ui slider-output" for="glassContrast" id="glassContrastValue">1.05</output>
                  <input id="glassContrast" class="glass-slider" type="range" min="1.00" max="1.10" step="0.01">
                </div>
              </div>
              <div class="hint">Limites seguros de legibilidade.</div>
            </div>
          </div>
        </section>

        <!-- Editor -->
        <section class="settings-section" id="sec-editor">
          <div class="section-head">Editor</div>
          <div class="section-body">
            <div class="subsection">
              <h4>Tipografia</h4>
              <div class="row">
                <label for="fontSize">Tamanho da letra <span id="fontSizeHint" class="hint" aria-live="polite"></span></label>
                <div class="slider-with-output-container" id="fontSizeWrap">
                  <output class="glass-ui slider-output" for="fontSize" id="fontSizeValueDisplay">16px</output>
                  <input id="fontSize" class="glass-slider" type="range" min="8" max="24" step="1" />
                </div>
              </div>
              <div class="row">
                <label for="lineHeight">Altura da linha <span id="lineHeightHint" class="hint" aria-live="polite"></span></label>
                <div class="slider-with-output-container" id="lineHeightWrap">
                  <output class="glass-ui slider-output" for="lineHeight" id="lineHeightValueDisplay">1.60</output>
                  <input id="lineHeight" class="glass-slider" type="range" min="1.30" max="1.90" step="0.05" />
                </div>
              </div>
              <div class="row">
                <label for="padX">Espaçamento interno <span id="padXHint" class="hint" aria-live="polite"></span></label>
                <div class="slider-with-output-container" id="padXWrap">
                  <output class="glass-ui slider-output" for="padX" id="padXValueDisplay">24px</output>
                  <input id="padX" class="glass-slider" type="range" min="8" max="40" step="1" />
                </div>
              </div>
              <div class="hint">Dica: 10–12px com 1.5–1.6 de linha é o ponto doce.</div>
            </div>

            <div class="subsection">
              <h4>Visual do editor</h4>
              <div class="row"><label>Quebra automática</label>
                <label class="switch-lg"><input id="switchWrap" type="checkbox" /><span class="knob"></span></label>
              </div>
              <div class="row"><label>Números de linha</label>
                <label class="switch-lg"><input id="switchLines" type="checkbox" /><span class="knob"></span></label>
              </div>
              <div class="row"><label>Minimap</label>
                <label class="switch-lg"><input id="switchMini" type="checkbox" /><span class="knob"></span></label>
              </div>
              <div class="hint">Sem textos ON/OFF — o estado é o switch.</div>
            </div>

            <div class="subsection">
              <h4>Comportamento</h4>
              <div class="row"><label>Salvamento automático</label>
                <label class="switch-lg"><input id="switchAutoSave" type="checkbox" checked /><span class="knob"></span></label>
              </div>
              <div class="row">
                <label for="tabSize">Tamanho da tabulação <span id="tabSizeHint" class="hint" aria-live="polite"></span></label>
                <div class="segmented-control" id="tabSizeWrap">
                  <input id="tab2" name="tabSize" type="radio" value="2" checked />
                  <label for="tab2">2</label>
                  <input id="tab4" name="tabSize" type="radio" value="4" />
                  <label for="tab4">4</label>
                  <input id="tab8" name="tabSize" type="radio" value="8" />
                  <label for="tab8">8</label>
                </div>
              </div>
              <div class="hint">Salvamento automático preserva mudanças e tabulação controla indentação do código.</div>
            </div>
          </div>
        </section>

        <!-- Interface -->
        <section class="settings-section" id="sec-interface">
          <div class="section-head">Interface</div>
          <div class="section-body">
            <div class="subsection">
              <h4>Elementos da interface</h4>
              <div class="row"><label>Barra de ferramentas</label>
                <label class="switch-lg"><input id="switchToolbar" type="checkbox" checked /><span class="knob"></span></label>
              </div>
              <div class="row"><label>Barra de status</label>
                <label class="switch-lg"><input id="switchStatusBar" type="checkbox" checked /><span class="knob"></span></label>
              </div>
              <div class="row"><label>Painel de notas</label>
                <label class="switch-lg"><input id="switchNotesPanel" type="checkbox" checked /><span class="knob"></span></label>
              </div>
              <div class="hint">Controla visibilidade dos elementos da interface.</div>
            </div>

            <div class="subsection">
              <h4>Animações & Densidade</h4>
              <div class="row"><label>Reduzir animações</label>
                <label class="switch-lg"><input id="switchMotion" type="checkbox" /><span class="knob"></span></label>
              </div>
              <div class="row">
                <label>Densidade</label>
                <div class="segmented" role="radiogroup" aria-label="Densidade" id="densitySeg">
                  <input id="dense-comf" type="radio" name="density" value="comfortable" checked><label for="dense-comf">Confortável</label>
                  <input id="dense-comp" type="radio" name="density" value="compact"><label for="dense-comp">Compacta</label>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Acessibilidade -->
        <section class="settings-section" id="sec-accessibility">
          <div class="section-head">Acessibilidade</div>
          <div class="section-body">
            <div class="subsection">
              <h4>Contraste & Foco</h4>
              <div class="row"><label>Aumentar contraste</label>
                <label class="switch-lg"><input id="switchContrast" type="checkbox" /><span class="knob"></span></label>
              </div>
              <div class="hint">Segue boas práticas de contraste.</div>
            </div>
          </div>
        </section>

        <!-- Notas & Arquivos -->
        <section class="settings-section" id="sec-files">
          <div class="section-head">Notas & Arquivos</div>
          <div class="section-body">
            <div class="subsection">
              <h4>Backup</h4>
              <div class="row">
                <div class="hint">Exportar todas as notas ou importar backup.</div>
                <div style="display:flex; gap:8px">
                  <button class="tbtn" id="btnExportFromSettings">Exportar Tudo</button>
                  <button class="tbtn" id="btnImportFromSettings">Importar</button>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Avançado -->
        <section class="settings-section" id="sec-advanced">
          <div class="section-head">Avançado</div>
          <div class="section-body">
            <div class="subsection" style="display:flex; gap:8px; justify-content:flex-end">
              <button class="tbtn" id="btnExportSettings2">Exportar Config</button>
              <button class="tbtn" id="btnResetSettings2">Restaurar Padrões</button>
            </div>
          </div>
        </section>

        <!-- Sobre -->
        <section class="settings-section" id="sec-about">
          <div class="section-head">Sobre</div>
          <div class="section-body">
            <div class="subsection">
              <div class="hint">Canvas de Texto — Editor v3. Material translúcido (Vibrancy).</div>
            </div>
          </div>
        </section>
      </div>
    </div>

    <!-- Rodapé -->
    <div class="settings-footer">
      <button class="tbtn sheet-close" value="cancel">Fechar</button>
    </div>
  </dialog>

  <!-- ========== Centro de Ajuda v2 — Liquid Glass ========== -->
  <dialog id="help" class="dialog-sheet glass-panel large" aria-modal="true" aria-labelledby="helpTitle">
    <div class="help-content">
      <!-- Sidebar de Navegação -->
      <div class="help-sidebar">
        <div class="help-nav-section">
          <h4 class="help-nav-title">Centro de Ajuda</h4>
          <button class="help-nav-item active" data-section="overview">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
              <polyline points="9,22 9,12 15,12 15,22"/>
            </svg>
            Visão Geral
          </button>
          <button class="help-nav-item" data-section="shortcuts">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
              <line x1="8" y1="21" x2="16" y2="21"/>
              <line x1="12" y1="17" x2="12" y2="21"/>
            </svg>
            Atalhos
          </button>
        </div>
        
        <div class="help-nav-section">
          <h4 class="help-nav-title">Recursos</h4>
          <button class="help-nav-item" data-section="features">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
            </svg>
            Funcionalidades
          </button>
          <button class="help-nav-item" data-section="tips">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/>
              <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
              <line x1="12" y1="17" x2="12.01" y2="17"/>
            </svg>
            Dicas
          </button>
        </div>
        
        <div class="help-nav-section">
          <h4 class="help-nav-title">Informações</h4>
          <button class="help-nav-item" data-section="about">
            <svg class="ticon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/>
              <line x1="12" y1="16" x2="12" y2="12"/>
              <line x1="12" y1="8" x2="12.01" y2="8"/>
            </svg>
            Sobre
          </button>
        </div>
      </div>
      
      <!-- Conteúdo Principal -->
      <div class="help-main">
        <!-- Cabeçalho com Busca -->
        <div class="help-header">
          <h2 class="help-title" id="helpTitle">Centro de Ajuda</h2>
          <div class="help-search-container">
            <svg class="help-search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"/>
              <path d="M21 21l-4.35-4.35"/>
            </svg>
            <input type="text" class="help-search" id="helpSearch" placeholder="Buscar na ajuda..." aria-label="Buscar na ajuda">
          </div>
        </div>
        
        <!-- Corpo do Conteúdo -->
        <div class="help-body" id="helpBody">
          <!-- Visão Geral -->
          <div class="help-section active" id="section-overview">
            <h2>Bem-vindo ao Canvas</h2>
            <p>Um editor de texto moderno e minimalista com foco na produtividade e experiência do usuário.</p>
            
            <div class="feature-grid">
              <div class="feature-card">
                <svg class="feature-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                  <polyline points="14,2 14,8 20,8"/>
                  <line x1="16" y1="13" x2="8" y2="13"/>
                  <line x1="16" y1="17" x2="8" y2="17"/>
                  <polyline points="10,9 9,9 8,9"/>
                </svg>
                <div class="feature-title">Editor Inteligente</div>
                <div class="feature-desc">Interface limpa com numeração de linhas, minimap e busca avançada.</div>
              </div>
              
              <div class="feature-card">
                <svg class="feature-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                </svg>
                <div class="feature-title">Gerenciamento de Notas</div>
                <div class="feature-desc">Organize, filtre e acesse suas notas de forma rápida e eficiente.</div>
              </div>
              
              <div class="feature-card">
                <svg class="feature-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="3"/>
                  <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                </svg>
                <div class="feature-title">Personalização</div>
                <div class="feature-desc">Themes, fontes, layout e preferências totalmente customizáveis.</div>
              </div>
              
              <div class="feature-card">
                <svg class="feature-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="22,12 18,12 15,21 9,3 6,12 2,12"/>
                </svg>
                <div class="feature-title">Performance</div>
                <div class="feature-desc">Resposta instantânea mesmo com documentos extensos.</div>
              </div>
            </div>
          </div>
          
          <!-- Atalhos de Teclado -->
          <div class="help-section" id="section-shortcuts">
            <h2>Atalhos de Teclado</h2>
            <p>Acelere seu fluxo de trabalho com atalhos poderosos:</p>
            
            <div class="shortcuts-grid" id="shortcutsList">
              <!-- Preenchido dinamicamente pelo JavaScript -->
            </div>
          </div>
          
          <!-- Funcionalidades -->
          <div class="help-section" id="section-features">
            <h2>Funcionalidades Principais</h2>
            
            <div class="feature-section">
              <h3>Editor de Texto Avançado</h3>
              <ul class="feature-list">
                <li><strong>Sintaxe de Markdown:</strong> Suporte completo para formatação Markdown com renderização em tempo real</li>
                <li><strong>Numeração de Linhas:</strong> Sistema de numeração dinâmico com navegação direta por clique</li>
                <li><strong>Quebra de Linha Inteligente:</strong> Controle automático e manual de quebra de linha para melhor legibilidade</li>
                <li><strong>Estatísticas em Tempo Real:</strong> Contagem automática de caracteres, palavras e linhas</li>
                <li><strong>Codificação UTF-8:</strong> Suporte completo para caracteres especiais e múltiplos idiomas</li>
              </ul>
            </div>

            <div class="feature-section">
              <h3>Sistema de Busca e Substituição</h3>
              <ul class="feature-list">
                <li><strong>Busca por Expressões Regulares:</strong> Suporte completo para RegEx com validação em tempo real</li>
                <li><strong>Busca Global:</strong> Localização instantânea com navegação sequencial entre resultados</li>
                <li><strong>Substituição em Lote:</strong> Capacidade de substituir todas as ocorrências ou seletivamente</li>
                <li><strong>Destaque Visual:</strong> Realce automático de todas as correspondências encontradas</li>
                <li><strong>Histórico de Busca:</strong> Manutenção automática do histórico de termos pesquisados</li>
              </ul>
            </div>

            <div class="feature-section">
              <h3>Navegação e Visualização</h3>
              <ul class="feature-list">
                <li><strong>Minimap Interativo:</strong> Visão panorâmica do documento com navegação por clique e arrastar</li>
                <li><strong>Ir para Linha:</strong> Navegação direta para qualquer linha do documento</li>
                <li><strong>Barra de Status:</strong> Informações de posição do cursor e estatísticas do documento</li>
                <li><strong>Viewport Responsivo:</strong> Adaptação automática a diferentes tamanhos de tela</li>
                <li><strong>Zoom de Fonte:</strong> Controle granular do tamanho da fonte com atalhos de teclado</li>
              </ul>
            </div>

            <div class="feature-section">
              <h3>Gerenciamento de Documentos</h3>
              <ul class="feature-list">
                <li><strong>Sistema de Notas:</strong> Criação, organização e gerenciamento de múltiplas notas</li>
                <li><strong>Auto-salvamento:</strong> Persistência automática de alterações em tempo real</li>
                <li><strong>Importação/Exportação:</strong> Suporte para arquivos TXT, MD e formato JSON</li>
                <li><strong>Drag & Drop:</strong> Carregamento de arquivos por arrastar e soltar</li>
                <li><strong>Sincronização Cross-Tab:</strong> Sincronização automática entre múltiplas abas do navegador</li>
              </ul>
            </div>

            <div class="feature-section">
              <h3>Recursos de Produtividade</h3>
              <ul class="feature-list">
                <li><strong>Movimentação de Linhas:</strong> Reordenação rápida de conteúdo com atalhos Alt+↑/↓</li>
                <li><strong>Duplicação de Linhas:</strong> Clonagem instantânea de linhas com Ctrl+D</li>
                <li><strong>Manipulação de Texto:</strong> Inserção de tabs, controle de indentação e formatação</li>
                <li><strong>Seleção Inteligente:</strong> Seleção por palavra duplo-clique e seleção total com Ctrl+A</li>
                <li><strong>Atalhos de Teclado:</strong> Conjunto abrangente de atalhos para todas as funcionalidades</li>
              </ul>
            </div>

            <div class="feature-section">
              <h3>Interface e Personalização</h3>
              <ul class="feature-list">
                <li><strong>Design Liquid Glass:</strong> Interface moderna com efeitos de vidro e transparência</li>
                <li><strong>Temas Adaptativos:</strong> Suporte automático para modo claro e escuro</li>
                <li><strong>Configurações Avançadas:</strong> Personalização completa de comportamento e aparência</li>
                <li><strong>Acessibilidade:</strong> Conformidade com padrões WCAG e suporte para leitores de tela</li>
                <li><strong>Responsividade:</strong> Otimização para desktop, tablet e dispositivos móveis</li>
              </ul>
            </div>

            <div class="feature-section">
              <h3>Tecnologias e Performance</h3>
              <ul class="feature-list">
                <li><strong>Web Standards:</strong> Implementação usando HTML5, CSS3 e JavaScript moderno</li>
                <li><strong>Local Storage:</strong> Armazenamento local seguro com fallback para sessionStorage</li>
                <li><strong>Performance Otimizada:</strong> Renderização eficiente com virtual scrolling e debouncing</li>
                <li><strong>Cross-Browser:</strong> Compatibilidade com Chrome, Firefox, Safari e Edge</li>
                <li><strong>PWA Ready:</strong> Preparado para funcionar como Progressive Web App</li>
              </ul>
            </div>
          </div>
          
          <!-- Dicas -->
          <div class="help-section" id="section-tips">
            <h2>Guia de Uso Avançado</h2>
            
            <div class="feature-section">
              <h3>Técnicas de Busca Avançada</h3>
              <ul class="feature-list">
                <li><strong>Expressões Regulares:</strong> Utilize <kbd>.*</kbd> para corresponder a qualquer caractere, <kbd>\d+</kbd> para números, e <kbd>\w+</kbd> para palavras</li>
                <li><strong>Busca Multi-linha:</strong> Use <kbd>^</kbd> para início de linha e <kbd>$</kbd> para final de linha em padrões RegEx</li>
                <li><strong>Caracteres Especiais:</strong> Escape caracteres especiais com <kbd>\</kbd> quando necessário em padrões de busca</li>
                <li><strong>Navegação de Resultados:</strong> Use <kbd>F3</kbd> para próximo resultado e <kbd>Shift+F3</kbd> para resultado anterior</li>
              </ul>
            </div>

            <div class="feature-section">
              <h3>Manipulação Eficiente de Texto</h3>
              <ul class="feature-list">
                <li><strong>Movimentação de Linhas:</strong> <kbd>Alt+↑</kbd> e <kbd>Alt+↓</kbd> para mover linhas ou blocos selecionados verticalmente</li>
                <li><strong>Duplicação Rápida:</strong> <kbd>Ctrl+D</kbd> (ou <kbd>⌘+D</kbd> no Mac) para duplicar a linha atual ou seleção</li>
                <li><strong>Seleção de Palavras:</strong> Duplo-clique para selecionar palavra completa, incluindo caracteres especiais adjacentes</li>
                <li><strong>Indentação com Tab:</strong> Use <kbd>Tab</kbd> para inserir indentação mesmo com texto selecionado</li>
              </ul>
            </div>

            <div class="feature-section">
              <h3>Navegação e Produtividade</h3>
              <ul class="feature-list">
                <li><strong>Ir para Linha:</strong> <kbd>Ctrl+G</kbd> abre o diálogo de navegação direta para qualquer linha do documento</li>
                <li><strong>Navegação por Clique:</strong> Clique nos indicadores de linha/coluna na barra de status para navegação rápida</li>
                <li><strong>Zoom de Fonte:</strong> <kbd>Ctrl++</kbd> e <kbd>Ctrl+-</kbd> para ajustar tamanho da fonte; <kbd>Ctrl+0</kbd> para resetar</li>
                <li><strong>Minimap Interativo:</strong> Arraste a área destacada no minimap para navegação rápida em documentos longos</li>
              </ul>
            </div>

            <div class="feature-section">
              <h3>Gerenciamento de Arquivos</h3>
              <ul class="feature-list">
                <li><strong>Importação por Drag & Drop:</strong> Arraste arquivos .txt, .md ou .json diretamente para o editor</li>
                <li><strong>Auto-salvamento:</strong> Todas as alterações são persistidas automaticamente no localStorage do navegador</li>
                <li><strong>Exportação Flexível:</strong> Salve documentos como .txt ou .md através do menu de arquivo</li>
                <li><strong>Sincronização Cross-Tab:</strong> Alterações são sincronizadas automaticamente entre abas do mesmo navegador</li>
              </ul>
            </div>

            <div class="feature-section">
              <h3>Configuração e Personalização</h3>
              <ul class="feature-list">
                <li><strong>Temas Adaptativos:</strong> O editor detecta automaticamente preferências do sistema (claro/escuro)</li>
                <li><strong>Configurações Persistentes:</strong> Todas as preferências são salvas localmente e restauradas entre sessões</li>
                <li><strong>Acessibilidade:</strong> Suporte completo para navegação por teclado e leitores de tela</li>
                <li><strong>Performance:</strong> Renderização otimizada para documentos grandes com lazy loading</li>
              </ul>
            </div>
          </div>
          
          <!-- Sobre -->
          <div class="help-section" id="section-about">
            <h2>Sobre o Canvas</h2>
            <p>Canvas é um editor de texto moderno construído com tecnologias web nativas, focado na simplicidade, performance e experiência do usuário.</p>
            
            <h3>Características</h3>
            <ul style="line-height: 1.6; color: color-mix(in srgb, var(--c-content) 80%, transparent);">
              <li>Interface Liquid Glass com blur e transparências</li>
              <li>Arquitetura totalmente client-side</li>
              <li>Suporte completo a acessibilidade</li>
              <li>Design responsivo e adaptativo</li>
              <li>Armazenamento local seguro</li>
            </ul>
            
            <p style="margin-top: 20px; padding: 12px; background: color-mix(in srgb, var(--c-glass) 8%, transparent); border-radius: 8px; font-size: 13px;">
              💡 <strong>Dica:</strong> Feche esta ajuda com <kbd>Esc</kbd> ou <kbd class="key">⌘</kbd><kbd>/</kbd> a qualquer momento.
            </p>
          </div>
          
          <!-- Resultados de Busca -->
          <div class="help-section" id="section-search-results" style="display: none;">
            <h2>Resultados da Busca</h2>
            <div class="help-search-results" id="searchResults">
              <!-- Preenchido dinamicamente -->
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Botão Fechar -->
    <button class="tbtn sheet-close" value="cancel" title="Fechar (Esc)" style="position: absolute; top: 16px; right: 16px; z-index: 10;">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    </button>
  </dialog>

  <!-- ========== Gerenciador de notas ========== -->
  <dialog id="notes" class="dialog-sheet glass-panel large" aria-modal="true" aria-labelledby="notesTitle">
    <div class="glass-panel-header">
      <h3 id="notesTitle">Notas</h3>
      <input type="text" id="noteFilter" placeholder="Filtrar notas…" style="margin-left: 16px; font-size: 12px; height: 28px; flex: 1; max-width: 200px; border: 1px solid var(--stroke); border-radius: 8px; background: var(--panel); color: var(--text); padding: 0 10px; outline: none;">
      <div style="display: flex; gap: 8px;">
        <button class="tbtn" id="btnImport" title="Importar backup (.json)">Importar</button>
        <button class="tbtn" id="btnExport" title="Exportar tudo (.json)">Exportar Tudo</button>
        <button class="tbtn" id="btnDup" title="Duplicar como nova">Duplicar</button>
        <button class="tbtn" id="btnDelAll" title="Apagar todas">Apagar todas</button>
      </div>
      <button class="tbtn sheet-close" value="cancel" title="Fechar">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>

    <div class="glass-panel-content">
      <div class="notes-list" id="notesList" role="list"></div>
    </div>
    
    <div class="glass-panel-footer">
      <button class="tbtn" id="btnNewInside">Nova nota</button>
    </div>
  </dialog>

  <input type="file" id="importFile" accept=".json" hidden />

  <script>
    // ===== Toolbar scrolled state =====
    (function(){
      const hdr = document.querySelector('.header-toolbar');
      const main = document.querySelector('main');
      if (!hdr || !main) return;
      const onScroll = () => {
        const y = main.scrollTop || document.documentElement.scrollTop || window.scrollY;
        hdr.classList.toggle('is-scrolled', y > 2);
      };
      main?.addEventListener('scroll', onScroll, {passive:true});
      window.addEventListener('scroll', onScroll, {passive:true});
      onScroll();
    })();

    // ====== Elements ======
    const shell = document.getElementById('shell');
    const editor = document.getElementById('editor');
    const gutter = document.getElementById('gutter');
    const minimap = document.getElementById('minimap');
    const miniText = document.getElementById('miniText');
    const miniViewport = document.getElementById('miniViewport');
    const highlights = document.getElementById('highlights');

    const progress = document.getElementById('progress');
    const lnCol = document.getElementById('lncol');
    const wordCountEl = document.getElementById('wordCount');
    const selectionSep = document.getElementById('selectionSep');
    const selectionStats = document.getElementById('selectionStats');
    const wrapStateEl = document.getElementById('wrapState');
    const noteTitleEl = document.getElementById('noteTitle');
    const saveStatus = document.getElementById('saveStatus');

    const btnNotes = document.getElementById('btnNotes');
    const btnNew = document.getElementById('btnNew');
    const btnOpen = document.getElementById('btnOpen');
    const btnSaveFile = document.getElementById('btnSaveFile');
    const btnPrint = document.getElementById('btnPrint');
    const btnToggleWrap = document.getElementById('btnToggleWrap');
    const btnToggleLines = document.getElementById('btnToggleLines');
    const btnToggleMini = document.getElementById('btnToggleMini');

    // Elementos do chip de título
    const noteTitleChip = document.getElementById('noteTitleChip');
    const noteTitleChipText = document.getElementById('noteTitleChipText');

    // ---------- Popover Controller (btn "Mais" e afins) ----------
    const popoverButtons = document.querySelectorAll('[data-popover]');
    let openPopover = null;

    function positionPopover(pop, anchorBtn) {
      // usa posição fixa ancorada ao botão, evitando overflow
      pop.style.position = 'fixed';
      const r = anchorBtn.getBoundingClientRect();
      const margin = 8;
      // mede rapidamente (mostra para medir, depois recoloca)
      pop.removeAttribute('hidden');
      const w = pop.offsetWidth;
      const h = pop.offsetHeight;
      const left = Math.min(window.innerWidth - w - margin, Math.max(margin, r.right - w));
      const top  = Math.min(window.innerHeight - h - margin, r.bottom + margin);
      pop.style.left = `${left}px`;
      pop.style.top  = `${top}px`;
    }

    function closeOpenPopover(returnFocus = false) {
      if (!openPopover) return;
      openPopover.setAttribute('hidden','');
      openPopover.opener?.setAttribute('aria-expanded','false');
      if (returnFocus) openPopover.opener?.focus();
      openPopover = null;
    }

    function togglePopover(btn) {
      const sel = btn.getAttribute('data-popover');
      const pop = document.querySelector(sel);
      if (!pop) return;

      const willOpen = pop.hasAttribute('hidden');
      // fecha outro aberto
      if (openPopover && openPopover !== pop) closeOpenPopover(false);

      if (willOpen) {
        btn.setAttribute('aria-expanded','true');
        pop.opener = btn;
        positionPopover(pop, btn);
        openPopover = pop;
        // foco no primeiro item
        const first = pop.querySelector('[role="menuitem"], button, a, [tabindex]');
        first?.focus();
      } else {
        closeOpenPopover(true);
      }
    }

    popoverButtons.forEach(btn => {
      btn.addEventListener('click', e => {
        e.stopPropagation();
        togglePopover(btn);
      });
      btn.addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowDown') {
          e.preventDefault();
          togglePopover(btn);
        }
      });
    });

    document.addEventListener('click', (e) => {
      if (openPopover && !openPopover.contains(e.target)) {
        closeOpenPopover(false);
      }
    });

    document.addEventListener('keydown', (e) => {
      if (!openPopover) return;
      if (e.key === 'Escape') {
        e.preventDefault();
        closeOpenPopover(true);
      } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        e.preventDefault();
        const items = Array.from(openPopover.querySelectorAll('[role="menuitem"], button, a, [tabindex]'))
          .filter(el => !el.hasAttribute('disabled'));
        if (!items.length) return;
        let i = items.indexOf(document.activeElement);
        if (i < 0) i = 0;
        i = e.key === 'ArrowDown' ? (i + 1) % items.length : (i - 1 + items.length) % items.length;
        items[i].focus();
      }
    });

    // liga os itens do menu "Mais" às ações existentes
    document.getElementById('btnImportFromPopover')?.addEventListener('click', () => {
      closeOpenPopover(false);
      document.getElementById('importFile')?.click();
    });
    document.getElementById('btnExportFromPopover')?.addEventListener('click', () => {
      closeOpenPopover(false);
      // usa sua função existente
      if (typeof exportAllNotes === 'function') exportAllNotes();
    });

    // Arquivo
    document.getElementById('mmOpen')?.addEventListener('click', () => {
      closeOpenPopover(false);
      fileInput.click();
    });
    document.getElementById('mmSave')?.addEventListener('click', () => {
      closeOpenPopover(false);
      // reaproveita lógica do salvar
      btnSaveFile?.click();
    });
    document.getElementById('mmPrint')?.addEventListener('click', () => {
      closeOpenPopover(false);
      window.print();
    });

    // Notas
    document.getElementById('mmRename')?.addEventListener('click', () => {
      closeOpenPopover(false);
      startTitleEditOn(noteTitleChip || noteTitleEl);
    });
    document.getElementById('mmDuplicate')?.addEventListener('click', () => {
      closeOpenPopover(false);
      const id = createNote(editor.value);
      openNote(id);
    });
    document.getElementById('mmExportAll')?.addEventListener('click', () => {
      closeOpenPopover(false);
      exportAllNotes();
    });
    
    document.getElementById('mmMarkdownPreview')?.addEventListener('click', () => {
      closeOpenPopover(false);
      const content = editor.value;
      if (content.trim()) {
        const meta = getCurrentNoteMeta();
        const title = meta ? `${meta.title}.md` : 'Nota.md';
        if (typeof openMarkdownViewer === 'function') {
          openMarkdownViewer({ 
            markdown: content, 
            title: title 
          });
        }
      } else {
        showToast('Nenhum conteúdo para visualizar', 'info');
      }
    });

    // Exibir (checkboxes sincronizados)
    const mmWrap  = document.getElementById('mmToggleWrap');
    const mmLines = document.getElementById('mmToggleLines');
    const mmMini  = document.getElementById('mmToggleMini');

    function syncMenuChecks(){
      if (mmWrap)  mmWrap.setAttribute('aria-checked', String(wrapOn));
      if (mmLines) mmLines.setAttribute('aria-checked', String(linesVisible));
      if (mmMini)  mmMini.setAttribute('aria-checked', String(miniVisible));
    }
    mmWrap?.addEventListener('click',  () => { setWrap(!wrapOn);  syncMenuChecks(); closeOpenPopover(false); });
    mmLines?.addEventListener('click', () => { setLineNumbers(!linesVisible); syncMenuChecks(); closeOpenPopover(false); });
    mmMini?.addEventListener('click',  () => { setMinimap(!miniVisible); syncMenuChecks(); closeOpenPopover(false); });

    // Ajuda
    document.getElementById('mmSettings')?.addEventListener('click', () => { closeOpenPopover(false); dlgSettings.showModal(); focusTrap(dlgSettings); });
    document.getElementById('mmShortcuts')?.addEventListener('click', () => {
      closeOpenPopover(false);
      dlgHelp.showModal();
      focusTrap(dlgHelp);
      // selecionar aba "Atalhos"
      document.querySelector('#help .help-tabs [data-tab="shortcuts"]')?.click();
    });

    // garantir sync sempre que os toggles mudarem
    const _origReflect = reflectToggles;
    reflectToggles = function(){
      _origReflect.call(this);
      syncMenuChecks();
    };
    const btnSettings = document.getElementById('btnSettings');
    const btnHelp = document.getElementById('btnHelp');
    
    // Font controls
    const btnFontDown = document.getElementById('btnFontDown');
    const btnFontUp = document.getElementById('btnFontUp');
    const fontSizeDisplay = document.getElementById('fontSizeDisplay');

    const dlgSettings = document.getElementById('settings');
    const switchWrap = document.getElementById('switchWrap');
    const switchLines = document.getElementById('switchLines');
    const switchMini = document.getElementById('switchMini');
    const fontSize = document.getElementById('fontSize');
    const lineHeight = document.getElementById('lineHeight');
    const padX = document.getElementById('padX');
    const fontSizeHint = document.getElementById('fontSizeHint');
    const lineHeightHint = document.getElementById('lineHeightHint');
    const padXHint = document.getElementById('padXHint');

    const dlgNotes = document.getElementById('notes');
    const notesList = document.getElementById('notesList');
    const btnDup = document.getElementById('btnDup');
    const btnDelAll = document.getElementById('btnDelAll');
    const btnNewInside = document.getElementById('btnNewInside');
    const noteFilter = document.getElementById('noteFilter');
    const dropzone = document.getElementById('dropzone');
    const btnImport = document.getElementById('btnImport');
    const btnExport = document.getElementById('btnExport');
    const importFile = document.getElementById('importFile');

    const fileInput = document.getElementById('file');

    // Find & Replace elements - updated for new structure
    const findBar = document.getElementById('findBar');
    const findInput = document.getElementById('findInput');
    const replaceInput = document.getElementById('replaceInput');
    const replaceRow = document.getElementById('replaceRow');
    const btnFindClose = document.getElementById('btnFindClose');
    const btnFindNext = document.getElementById('btnFindNext');
    const btnFindPrev = document.getElementById('btnFindPrev');
    const btnDoReplace = document.getElementById('btnDoReplace');
    const btnDoReplaceAll = document.getElementById('btnDoReplaceAll');
    const btnToggleReplace = document.getElementById('btnToggleReplace');
    const optCase = document.getElementById('optCase');
    const optRegex = document.getElementById('optRegex');
    const optMultiline = document.getElementById('optMultiline');
    const findCount = document.getElementById('findCount');

    // State tracking for options
    const findOptions = {
      case: false,
      regex: false,
      multiline: false
    };
    const goToLine = document.getElementById('goToLine');
    const goToLineInput = document.getElementById('goToLineInput');
    const btnGoToLineExecute = document.getElementById('btnGoToLineExecute');
    const btnGoToLineClose = document.getElementById('btnGoToLineClose');

    // ====== Storage Keys ======
    const INDEX_KEY = 'notes:index:v1';
    const CURRENT_KEY = 'notes:current:v1';
    const SETTINGS_KEY = 'editor:settings:v5'; // v5: novos campos glass/ui
    const NOTE_KEY = id => `note:${id}`;

    // ===== Utils =====
    const setVar = (k,v)=> document.documentElement.style.setProperty(k,v);
    function nowISO(){ return new Date().toISOString(); }
    function fmtDateTime(d){ const dt = typeof d === 'string' ? new Date(d) : d; const pad = n=> String(n).padStart(2,'0'); return `${dt.getFullYear()}-${pad(dt.getMonth()+1)}-${pad(dt.getDate())} ${pad(dt.getHours())}:${pad(dt.getMinutes())}`; }
    function genId(){ return Date.now().toString(36) + Math.random().toString(36).slice(2,6); }

    // ===== Glass & UI defaults =====
    const GLASS_DEFAULTS = { blur: 12, sat: 150, contrast: 1.04 };
    let uiReduceMotion = false;
    let uiDensity = 'comfortable';
    let uiHighContrast = false;

    // ===== Novas configurações do editor =====
    let autoSaveEnabled = true;
    let tabSize = 2;
    let toolbarVisible = true;
    let statusBarVisible = true;
    let notesPanelVisible = true;

    function applyGlass({blur, sat, contrast}) {
      setVar('--lg-blur', `${blur}px`);
      setVar('--lg-sat', `${sat}%`);
      setVar('--lg-contrast', contrast);
    }

    function applyDensity(mode){
      // Compacta reduz padding global de botões e editor
      document.documentElement.dataset.density = mode;
      const pad = parseInt(padX.value || 16, 10);
      setVar('--editor-padding', (mode === 'compact' ? Math.max(6, pad - 4) : pad) + 'px');
    }

    function applyMotion(reduce){
      // Além do @media nativo, forçamos 0s quando ativado no app
      document.documentElement.style.setProperty('--dur', reduce ? '0s' : '.25s');
    }

    function applyContrast(high){
      document.documentElement.classList.toggle('contrast-plus', !!high);
    }

    function applyTabSize(size) {
      setVar('--tab-size', size);
      const editor = document.getElementById('editor');
      if (editor) {
        editor.style.tabSize = size;
      }
    }

    function applyToolbarVisibility(visible) {
      const toolbar = document.querySelector('.toolbar');
      if (toolbar) {
        toolbar.style.display = visible ? '' : 'none';
      }
    }

    function applyStatusBarVisibility(visible) {
      const statusBar = document.querySelector('.status-bar');
      if (statusBar) {
        statusBar.style.display = visible ? '' : 'none';
      }
    }

    function applyNotesPanelVisibility(visible) {
      const notesPanel = document.querySelector('.notes-panel');
      if (notesPanel) {
        notesPanel.style.display = visible ? '' : 'none';
      }
    }

    function focusTrap(dialog){
      // foco inicial e retorno ao fechar
      const opener = document.activeElement;
      dialog.addEventListener('close', () => { if (opener && opener.focus) opener.focus(); }, { once:true });
      const first = dialog.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
      if (first) first.focus();
    }

    function loadIndex(){ return JSON.parse(localStorage.getItem(INDEX_KEY) || '[]'); }
    function saveIndex(arr){ localStorage.setItem(INDEX_KEY, JSON.stringify(arr)); }
    function getCurrentId(){ return localStorage.getItem(CURRENT_KEY); }
    function setCurrentId(id){ localStorage.setItem(CURRENT_KEY, id); }
    function saveNote(id, text, meta){ 
      try {
        localStorage.setItem(NOTE_KEY(id), JSON.stringify({ text, ...meta })); 
      } catch (e) {
        if (e.name === 'QuotaExceededError') {
          alert('Armazenamento cheio! Exclua notas antigas ou exporte um backup para liberar espaço.');
        }
      }
    }
    function loadNote(id){ const j = localStorage.getItem(NOTE_KEY(id)); return j ? JSON.parse(j) : null; }
    function deleteNoteStorage(id){ localStorage.removeItem(NOTE_KEY(id)); }

    // ===== State =====
    let currentId = null;
    let debounceSave = null;
    const baseTitle = 'Canvas de Texto — Editor v3';
    let isDirty = false;
    let lastSaveTime = null;
    let lastRenderedLineCount = 0;
    let wrapOn = false; // single source of truth agora
    let linesVisible = false;
    let miniVisible = false;

    // ===== Interação de linhas =====
    const lineUX = {
      hoverLine: null,
      anchorLine: null,       // para Shift+click/arraste
      bookmarks: new Set(),   // guarda números de linha (1-based)
      dragging: false,
    };

    // Cria elementos de realce no overlay (uma vez)
    const hoverEl = document.createElement('div');
    hoverEl.className = 'line-hover';
    const selEl = document.createElement('div');
    selEl.className = 'line-selection';
    highlights.appendChild(hoverEl);
    highlights.appendChild(selEl);
    hoverEl.style.display = 'none';
    selEl.style.display = 'none';

    function timeAgo(date) {
      if (!date) return '';
      const seconds = Math.floor((new Date() - date) / 1000);
      if (seconds < 5) return "agora mesmo";
      
      let interval = seconds / 31536000;
      if (interval > 1) { const n = Math.floor(interval); return `há ${n} ano${n > 1 ? 's' : ''}`; }
      interval = seconds / 2592000;
      if (interval > 1) { const n = Math.floor(interval); return `há ${n} mês${n > 1 ? 'es' : ''}`; }
      interval = seconds / 86400;
      if (interval > 1) { const n = Math.floor(interval); return `há ${n} dia${n > 1 ? 's' : ''}`; }
      interval = seconds / 3600;
      if (interval > 1) { const n = Math.floor(interval); return `há ${n} hora${n > 1 ? 's' : ''}`; }
      interval = seconds / 60;
      if (interval > 1) { const n = Math.floor(interval); return `há ${n} min`; }
      
      return `há ${Math.floor(seconds)}s`;
    }

    function updateLastSavedTime() {
        if (lastSaveTime && !isDirty) {
            saveStatus.textContent = `Salvo ${timeAgo(lastSaveTime)}`;
        }
    }

    function updateDocTitle(){
      const idx = loadIndex();
      const meta = currentId ? idx.find(n=>n.id===currentId) : null;
      const t = (meta && meta.title) ? meta.title : baseTitle;
      document.title = (isDirty ? '• ' : '') + t;
    }

    function getCurrentNoteMeta(){
      const idx = loadIndex();
      return currentId ? idx.find(n => n.id === currentId) : null;
    }

    // ===== Notes Ops =====
    function createNote(initialText=''){
      const id = genId();
      const createdAt = nowISO();
      const updatedAt = createdAt;
      const title = `Nota de ${fmtDateTime(createdAt)}`;
      const idx = loadIndex();
      idx.unshift({ id, title, createdAt, updatedAt });
      saveIndex(idx);
      saveNote(id, initialText, { createdAt, updatedAt });
      setCurrentId(id);
      return id;
    }
    function openNote(id){
      if(currentId){ doSave(); }
      const item = loadNote(id);
      if(!item){ alert('Nota não encontrada.'); return; }
      currentId = id; setCurrentId(id);
      editor.value = item.text || '';
      editor.scrollTop = 0; editor.scrollLeft = 0;
      
      // Carregar bookmarks se existirem
      lineUX.bookmarks.clear();
      if (item.bookmarks && Array.isArray(item.bookmarks)) {
        item.bookmarks.forEach(lineNum => lineUX.bookmarks.add(lineNum));
      }
      
      updateAllMeta();
      const idx = loadIndex();
      const meta = idx.find(n=>n.id===id);
      noteTitleEl.textContent = meta? meta.title : '—';
      if (noteTitleChipText) noteTitleChipText.textContent = meta ? meta.title : '—';
      isDirty = false; 
      lastSaveTime = meta ? new Date(meta.updatedAt) : new Date();
      updateDocTitle();
      updateLastSavedTime();
      updateMinimap(true); renderGutter(true);
    }
    function doSave(isManual=false){
      if(!currentId || !isDirty && !isManual) return;
      const text = editor.value; 
      const updatedAt = nowISO();
      const old = loadNote(currentId) || { createdAt: updatedAt };
      
      // Salvar bookmarks junto com a nota
      const bookmarksArray = Array.from(lineUX.bookmarks);
      saveNote(currentId, text, { 
        createdAt: old.createdAt, 
        updatedAt,
        bookmarks: bookmarksArray 
      });
      
      let idx = loadIndex();
      let meta = idx.find(n => n.id === currentId);
      
      if (meta) {
          meta.updatedAt = updatedAt;
      } else {
          // Should not happen if app logic is correct
          return;
      }

      // Move updated note to the top
      idx = idx.filter(n => n.id !== currentId);
      idx.unshift(meta);
      saveIndex(idx);
      
      if (dlgNotes.open) buildNotesList(); 
      
      isDirty = false; 
      lastSaveTime = new Date();
      updateDocTitle();
      updateLastSavedTime();
    }
    function deleteNote(id){
      let idx = loadIndex();
      idx = idx.filter(n=>n.id!==id); saveIndex(idx);
      deleteNoteStorage(id);
      if(currentId===id){
        if(idx.length){ openNote(idx[0].id); }
        else { const nid = createNote(''); openNote(nid); }
      }
      if (dlgNotes.open) buildNotesList();
    }
    function deleteAllNotes(){
      if(!confirm('Apagar TODAS as notas?')) return;
      if(!confirm('Tem certeza? Esta ação não pode ser desfeita.')) return;
      const idx = loadIndex();
      idx.forEach(n=> deleteNoteStorage(n.id));
      saveIndex([]); currentId=null; localStorage.removeItem(CURRENT_KEY);
      const nid = createNote(''); openNote(nid);
      if (dlgNotes.open) buildNotesList();
    }

    // ===== Import / Export =====
    function exportAllNotes() {
        const index = loadIndex();
        const notes = index.map(meta => {
            const note = loadNote(meta.id);
            return {
                id: meta.id,
                title: meta.title,
                text: note ? note.text : '',
                createdAt: meta.createdAt,
                updatedAt: meta.updatedAt,
                bookmarks: note ? (note.bookmarks || []) : []
            };
        });
        
        const backup = {
            version: '1.0',
            exportedAt: nowISO(),
            notes: notes,
        };

        const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `canvas_backup_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function handleImport(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const backup = JSON.parse(event.target.result);
                if (!backup.notes || !Array.isArray(backup.notes)) {
                    throw new Error('Invalid backup file format.');
                }

                let existingIndex = loadIndex();
                let importedCount = 0;

                backup.notes.forEach(note => {
                    // Simple import: add as new, don't check for duplicates
                    const newId = genId(); // Ensure unique ID
                    saveNote(newId, note.text, { 
                        createdAt: note.createdAt, 
                        updatedAt: note.updatedAt,
                        bookmarks: note.bookmarks || []
                    });
                    existingIndex.unshift({
                        id: newId,
                        title: note.title,
                        createdAt: note.createdAt,
                        updatedAt: note.updatedAt,
                    });
                    importedCount++;
                });

                saveIndex(existingIndex);
                buildNotesList();
                alert(`${importedCount} notes importadas com sucesso!`);

            } catch (err) {
                alert('Erro ao importar backup: ' + err.message);
            } finally {
                // Reset file input
                e.target.value = '';
            }
        };
        reader.readAsText(file);
    }

    // ===== Line Editing Shortcuts =====
    function getLineInfo() {
        const text = editor.value;
        const start = editor.selectionStart;
        const end = editor.selectionEnd;
        const hasSelection = start !== end;

        let lineStart, lineEnd;

        if (hasSelection) {
            lineStart = text.lastIndexOf('\n', start - 1) + 1;
            lineEnd = text.indexOf('\n', end);
            if (lineEnd === -1) lineEnd = text.length;
        } else {
            lineStart = text.lastIndexOf('\n', start - 1) + 1;
            lineEnd = text.indexOf('\n', start);
            if (lineEnd === -1) lineEnd = text.length;
        }
        
        return { text, start, end, lineStart, lineEnd, hasSelection };
    }

    function duplicateLineOrSelection() {
        const { text, start, end, lineStart, lineEnd, hasSelection } = getLineInfo();
        
        const contentToDuplicate = hasSelection 
            ? text.substring(start, end)
            : text.substring(lineStart, lineEnd) + '\n';
        
        const insertPosition = hasSelection ? end : lineEnd;
        
        editor.value = text.slice(0, insertPosition) + contentToDuplicate + text.slice(insertPosition);
        
        editor.setSelectionRange(insertPosition, insertPosition + contentToDuplicate.length);
        editor.dispatchEvent(new Event('input'));
    }

    function moveLineOrSelection(direction) {
        let { text, start, end, lineStart, lineEnd, hasSelection } = getLineInfo();
        
        if (text[lineEnd] === '\n') lineEnd++;
        const block = text.substring(lineStart, lineEnd);

        if (direction === 'up') {
            if (lineStart === 0) return;
            
            const prevLineStart = text.lastIndexOf('\n', lineStart - 2) + 1;
            const between = text.substring(prevLineStart, lineStart);
            
            editor.value = text.substring(0, prevLineStart) + block + between + text.substring(lineEnd);
            editor.setSelectionRange(start - between.length, end - between.length);

        } else { // down
            if (lineEnd === text.length) return;

            let nextLineEnd = text.indexOf('\n', lineEnd);
            if (nextLineEnd === -1) nextLineEnd = text.length; else nextLineEnd++;
            
            const between = text.substring(lineEnd, nextLineEnd);

            editor.value = text.substring(0, lineStart) + between + block + text.substring(nextLineEnd);
            editor.setSelectionRange(start + between.length, end + between.length);
        }
        editor.dispatchEvent(new Event('input'));
    }

    // ===== UI: Notes Dialog =====
    function buildNotesList(filter = ''){
      let idx = loadIndex();
      const q = (filter||'').toLowerCase().trim();
      if (q) {
        idx = idx.filter(n => {
          const note = loadNote(n.id);
          const content = note ? note.text : '';
          return n.title.toLowerCase().includes(q) || content.toLowerCase().includes(q);
        });
      }

      notesList.innerHTML = '';
      notesList.setAttribute('role','listbox');
      notesList.tabIndex = 0;

      if (!idx.length){
        const empty = document.createElement('div');
        empty.style.opacity = '.7'; empty.style.padding = '10px';
        empty.textContent = filter ? 'Nenhuma nota encontrada.' : 'Nenhuma nota.';
        notesList.appendChild(empty);
        return;
      }

      idx.forEach((n, i) => {
        const note = loadNote(n.id);
        const row = document.createElement('div');
        row.className = 'note-row';
        row.setAttribute('role','option');
        row.dataset.id = n.id;
        row.ariaSelected = String(n.id === currentId);

        const left = document.createElement('div');
        left.style.display = 'grid';
        left.style.gridTemplateColumns = '1fr';
        left.style.gap = '4px';

        const title = document.createElement('div');
        title.className = 'note-title';
        title.textContent = n.title;

        const meta = document.createElement('div');
        meta.className = 'note-meta';
        const kb = ((note?.text||'').length/1024).toFixed(1);
        meta.textContent = `${fmtDateTime(n.updatedAt)} • ${kb} KB`;

        left.append(title, meta);

        const actions = document.createElement('div');
        actions.className = 'note-actions';
        const openBtn = document.createElement('button');
        openBtn.className = 'tbtn'; openBtn.textContent = 'Abrir';
        openBtn.onclick = () => { dlgNotes.close(); openNote(n.id); };

        const delBtn = document.createElement('button');
        delBtn.className = 'tbtn'; delBtn.textContent = 'Apagar';
        delBtn.onclick = () => { deleteNote(n.id); };

        actions.append(openBtn, delBtn);

        row.append(left, actions);
        row.addEventListener('dblclick', () => { dlgNotes.close(); openNote(n.id); });
        row.addEventListener('click', () => {
          notesList.querySelectorAll('[aria-selected="true"]').forEach(el=>el.ariaSelected='false');
          row.ariaSelected = 'true';
        });

        notesList.appendChild(row);
      });
    }

    /* Navegação por teclado no modal de notas */
    dlgNotes.addEventListener('keydown', (e) => {
      const options = [...notesList.querySelectorAll('[role="option"]')];
      const current = options.findIndex(el => el.getAttribute('aria-selected') === 'true');
      if (!options.length) return;

      if (e.key === 'ArrowDown' || e.key === 'ArrowUp'){
        e.preventDefault();
        let next = current;
        if (e.key === 'ArrowDown') next = Math.min(options.length-1, Math.max(0, current + 1));
        else next = Math.max(0, current - 1);
        options.forEach(el => el.ariaSelected = 'false');
        options[next].ariaSelected = 'true';
        options[next].scrollIntoView({block:'nearest'});
      }
      else if (e.key === 'Enter'){
        e.preventDefault();
        const sel = options.find(el => el.getAttribute('aria-selected') === 'true') || options[0];
        if (sel) { dlgNotes.close(); openNote(sel.dataset.id); }
      }
      else if (e.key === 'Delete' || e.key === 'Backspace'){
        e.preventDefault();
        const sel = options.find(el => el.getAttribute('aria-selected') === 'true');
        if (sel) { deleteNote(sel.dataset.id); }
      }
    });

    // ===== Editor Meta =====
    function updateLnCol(){
      const pos = editor.selectionStart || 0; 
      const until = editor.value.slice(0, pos);
      const lines = until.split('\n'); 
      const ln = lines.length; // Esta é sempre a linha física (quebra \n)
      const col = lines[lines.length-1].length + 1;
      lnCol.textContent = `Ln ${ln}, Col ${col}`;
      
      if (linesVisible) {
        // Destaca se a linha estiver no range renderizado
        highlightCurrentLineInGutter(ln);
      }
    }
    
    function highlightCurrentLineInGutter(currentLine) {
      // Remove destaque anterior
      document.querySelectorAll('.gutter .ln.current').forEach(el => {
        el.classList.remove('current');
      });
      
      // Adiciona destaque à linha atual
      const gutterLines = document.querySelectorAll('.gutter .ln');
      gutterLines.forEach(el => {
        if (parseInt(el.textContent) === currentLine) {
          el.classList.add('current');
        }
      });
    }
    function updateWordCount(){ const words = editor.value.trim() ? editor.value.trim().split(/\s+/).length : 0; wordCountEl.textContent = `${words.toLocaleString('pt-BR')} ${words===1?'palavra':'palavras'}`; }
    
    function updateFooterInfo() {
      // Atualizar estado do wrap
      wrapStateEl.textContent = wrapOn ? 'Com quebra' : 'Sem quebra';
      
      // Tornar estado do wrap clicável
      if (!wrapStateEl.onclick) {
        wrapStateEl.style.cursor = 'pointer';
        wrapStateEl.title = 'Alternar quebra de linha (Alt+Z)';
        wrapStateEl.onclick = () => setWrap(!wrapOn);
      }
      
      // Adicionar informações sobre bookmarks se houver
      const bookmarkCount = lineUX.bookmarks.size;
      if (bookmarkCount > 0) {
        wrapStateEl.textContent += ` • ${bookmarkCount} marcador${bookmarkCount === 1 ? '' : 'es'}`;
      }
    }
    
    function updateProgress(){ 
      const el = editor; 
      const max = el.scrollHeight - el.clientHeight; 
      const pct = max > 0 ? (el.scrollTop / max) * 100 : 0; 
      progress.style.width = pct + '%'; 
      updateMiniViewport(); 
      
      if(linesVisible) {
        // Renderiza o gutter com sincronização inteligente
        renderGutter();
      }
    }
    function updateAllMeta(){ updateLnCol(); updateWordCount(); updateFooterInfo(); updateProgress(); }

    // ===== Wrap / Lines / Minimap (sincronizados) =====
    function reflectToggles(){
      // Toolbar
      btnToggleWrap.setAttribute('aria-pressed', String(wrapOn));
      btnToggleLines.setAttribute('aria-pressed', String(linesVisible));
      btnToggleMini.setAttribute('aria-pressed', String(miniVisible));
      // Switches
      switchWrap.setAttribute('aria-checked', String(wrapOn));
      switchLines.setAttribute('aria-checked', String(linesVisible));
      switchMini.setAttribute('aria-checked', String(miniVisible));
    }

    function setWrap(on){
      wrapOn = !!on;
      if(wrapOn){ 
        editor.setAttribute('wrap','soft'); 
        editor.style.whiteSpace='pre-wrap'; 
      } else { 
        editor.setAttribute('wrap','off'); 
        editor.style.whiteSpace='pre'; 
      }
      
      // Limpeza COMPLETA do gutter para evitar sobreposições
      if (linesVisible) {
        // Preservar posição de scroll atual
        const currentScrollTop = editor.scrollTop;
        
        // Limpeza total - remover todo conteúdo
        gutter.innerHTML = '';
        
        // Resetar referencias de containers
        gutter._inner = null;
        gutter._container = null;
        gutter._lastScrollTop = 0;
        lastRenderedLineCount = -1;
        
        // Restaurar scroll após limpeza
        editor.scrollTop = currentScrollTop;
      }
      
      // Invalidar métricas para forçar nova medição
      if (wrapOn) {
        wrapMetrics.heights = wrapMetrics.prefix = null;
        wrapMetrics.total = 0;
        wrapMetrics.widthsKey = '';
      }
      
      reflectToggles();
      updateFooterInfo();
      persistSettings(); 
      updateMinimap(true); 
      
      // Re-renderização imediata sem delay para evitar blink
      if (linesVisible) {
        renderGutter(true);
      }
      
      // Atualiza a posição/estado do cursor
      requestAnimationFrame(() => updateLnCol());
    }
    function setLineNumbers(on){
      linesVisible = !!on;
      
      // Limpa timeouts pendentes para evitar renderizações conflitantes
      clearTimeout(renderGutter._debounce);
      
      shell.classList.toggle('lines-on', linesVisible);
      gutter.setAttribute('aria-hidden', String(!linesVisible));

      // Acessibilidade: gutter focusável quando ativo
      if (linesVisible) {
        gutter.setAttribute('tabindex', '0');
        gutter.setAttribute('role', 'listbox');
        gutter.setAttribute('aria-label', 'Números de linha - Use setas para navegar, Enter para selecionar, Espaço para marcar');
        setTimeout(() => renderGutter(true), 10);
      } else {
        gutter.removeAttribute('tabindex');
        gutter.removeAttribute('role');
        gutter.removeAttribute('aria-label');
        gutter.innerHTML = '';
        gutter._inner = null;        // <- evita referência órfã
        gutter._lastScrollTop = 0;   // <- limpa cache de scroll
      }

      reflectToggles();
      persistSettings();
    }
    function setMinimap(on){
      miniVisible = !!on;
      shell.classList.toggle('minimap-on', miniVisible);
      minimap.hidden = !miniVisible; minimap.setAttribute('aria-hidden', String(!miniVisible));
      reflectToggles(); persistSettings(); updateMinimap(true);
    }

    // ===== Minimap text + lens =====
    function updateMinimap(force=false){
      if(!miniVisible) return;
      if(!force){ clearTimeout(updateMinimap._t); updateMinimap._t = setTimeout(()=> updateMinimap(true), 120); return; }
      const text = editor.value;
      if(text.length > 400000){ miniText.textContent = '[conteúdo grande — minimap simplificado]'; }
      else { miniText.textContent = text || ' '; }
      updateMiniViewport();
    }
    function getMiniTrackMetrics() {
      const mapH = minimap.clientHeight;
      const cs = getComputedStyle(miniText);
      const padTop = parseFloat(cs.paddingTop) || 0;
      const padBottom = parseFloat(cs.paddingBottom) || 0;
      const trackTop = padTop;                                // início da pista
      const trackHeight = Math.max(0, mapH - padTop - padBottom); // altura útil
      return { mapH, trackTop, trackHeight };
    }
    function updateMiniViewport() {
      if (!miniVisible) return;

      const { trackTop, trackHeight } = getMiniTrackMetrics();

      const scrollRange = Math.max(0, editor.scrollHeight - editor.clientHeight);
      const isScrollable = scrollRange > 1;

      // tamanho do visor proporcional ao que o editor mostra
      const ratio = editor.scrollHeight > 0 ? (editor.clientHeight / editor.scrollHeight) : 1;
      const lensH = Math.min(trackHeight, Math.max(24, Math.floor(trackHeight * Math.min(1, ratio))));

      const trackRange = Math.max(0, trackHeight - lensH);
      const topRel = (isScrollable && trackRange > 0)
        ? (editor.scrollTop / scrollRange) * trackRange
        : 0;

      miniViewport.style.height = lensH + 'px';
      miniViewport.style.top = (trackTop + topRel) + 'px';

      const disabled = !isScrollable || trackRange === 0;
      minimap.classList.toggle('mini-disabled', disabled);
      miniViewport.style.cursor = disabled ? 'default' : 'grab';
      miniViewport.style.pointerEvents = disabled ? 'none' : 'auto';
    }

    // Scrub & drag
    let dragging = false; let dragStartY = 0; let lensStartTop = 0;
    function scrollFromMinimap(clientY) {
      const { trackTop, trackHeight } = getMiniTrackMetrics();
      const lensH = miniViewport.clientHeight;

      const trackRange = Math.max(0, trackHeight - lensH);
      const scrollRange = Math.max(0, editor.scrollHeight - editor.clientHeight);
      if (trackRange === 0 || scrollRange === 0) return;

      const rect = minimap.getBoundingClientRect();
      const desiredRel = clientY - rect.top - trackTop - (lensH / 2);
      const yRel = Math.max(0, Math.min(desiredRel, trackRange));
      const pct = yRel / trackRange;

      editor.scrollTop = pct * scrollRange;
      updateProgress();
    }
    
    // Previne seleção de texto durante arrastar
    function preventTextSelection(e) {
      if (dragging) {
        e.preventDefault();
        return false;
      }
    }
    
    minimap.addEventListener('pointerdown', (e)=>{ 
      e.preventDefault(); 
      e.stopPropagation();
      minimap.setPointerCapture(e.pointerId); 
      scrollFromMinimap(e.clientY); 
      dragging = true;
      document.body.style.userSelect = 'none'; // Previne seleção durante o arrastar
    });
    
    window.addEventListener('pointermove', (e)=>{ 
      if(!dragging) return; 
      e.preventDefault();
      scrollFromMinimap(e.clientY); 
    });
    
    window.addEventListener('pointerup', (e)=>{ 
      if (dragging) {
        dragging = false; 
        document.body.style.userSelect = ''; // Restaura seleção
        if (minimap.hasPointerCapture(e.pointerId)) {
          minimap.releasePointerCapture(e.pointerId);
        }
      }
    });
    
    miniViewport.addEventListener('pointerdown', (e)=>{ 
      e.stopPropagation(); 
      e.preventDefault();
      dragging = true; 
      minimap.setPointerCapture(e.pointerId);
      document.body.style.userSelect = 'none';
    });
    
    // Previne seleção durante mouse move
    document.addEventListener('selectstart', preventTextSelection);
    document.addEventListener('dragstart', preventTextSelection);
    
    minimap.addEventListener('wheel', (e)=>{ 
      if (!miniVisible) return; 
      const scrollRange = Math.max(0, editor.scrollHeight - editor.clientHeight);
      if (scrollRange === 0) { e.preventDefault(); return; }
      e.preventDefault();
      editor.scrollTop += e.deltaY; 
      updateProgress(); 
    }, {passive: false});

    minimap.addEventListener('keydown', e => {
        if (!miniVisible) return;
        e.preventDefault();
        const page = editor.clientHeight;
        switch(e.key) {
            case 'ArrowUp': editor.scrollTop -= 20; break;
            case 'ArrowDown': editor.scrollTop += 20; break;
            case 'PageUp': editor.scrollTop -= page; break;
            case 'PageDown': editor.scrollTop += page; break;
            case 'Home': editor.scrollTop = 0; break;
            case 'End': editor.scrollTop = editor.scrollHeight; break;
            case 'Enter': editor.focus(); break;
        }
        updateProgress();
    });

    // ===== Wrap metrics (medidor offscreen para alturas por linha) =====
    const wrapMetrics = {
      measureEl: null,
      widthsKey: '',
      heights: null,      // array de alturas por linha física
      prefix: null,       // soma prefixada (cumulativa) de alturas
      total: 0
    };

    function invalidateWrapMetrics(){
      wrapMetrics.heights = null;
      wrapMetrics.prefix = null;
      wrapMetrics.total = 0;
      wrapMetrics.widthsKey = '';
    }

    function ensureMeasureEl(){
      if (wrapMetrics.measureEl) return wrapMetrics.measureEl;
      const el = document.createElement('div');
      el.id = 'wrapMeasure';
      el.style.cssText = [
        'position:fixed','left:-10000px','top:0','visibility:hidden',
        'white-space:pre-wrap','word-break:break-word','overflow-wrap:break-word',
        'tab-size:2'
      ].join(';');
      document.body.appendChild(el);
      wrapMetrics.measureEl = el;
      return el;
    }

    function buildWidthsKey(){
      // chave para invalidar cache quando largura/fonte mudam
      const cs = getComputedStyle(editor);
      const padL = parseFloat(cs.paddingLeft)||0;
      const padR = parseFloat(cs.paddingRight)||0;
      const contentW = editor.clientWidth - padL - padR;
      return [
        'w=', Math.max(0, Math.floor(contentW)),
        ';font=', cs.font,
        ';lh=', cs.lineHeight
      ].join('');
    }

    function measureWrappedHeights(){
      const el = ensureMeasureEl();
      const cs = getComputedStyle(editor);
      // espelha a tipografia do editor
      el.style.font = cs.font;
      el.style.lineHeight = cs.lineHeight;
      el.style.letterSpacing = cs.letterSpacing;
      el.style.tabSize = cs.tabSize || '2';

      // largura do conteúdo (sem padding) para simular o wrap do textarea
      const padL = parseFloat(cs.paddingLeft)||0;
      const padR = parseFloat(cs.paddingRight)||0;
      el.style.width = Math.max(0, editor.clientWidth - padL - padR) + 'px';

      const lines = editor.value.split('\n');
      el.innerHTML = ''; // limpa

      // criamos um bloco por linha física
      const frag = document.createDocumentFragment();
      for (let i = 0; i < lines.length; i++){
        const d = document.createElement('div');
        d.className = 'm-line';
        // linha vazia precisa de conteúdo para dar altura
        d.textContent = lines[i].length ? lines[i] : '\u00A0'; // nbsp
        frag.appendChild(d);
      }
      el.appendChild(frag);

      // mede
      const heights = new Array(lines.length);
      let total = 0;
      const prefix = new Array(lines.length);
      const kids = el.children;
      for (let i = 0; i < kids.length; i++){
        const h = kids[i].getBoundingClientRect().height; // px reais (com wrap)
        heights[i] = h;
        total += h;
        prefix[i] = total;
      }

      wrapMetrics.heights = heights;
      wrapMetrics.prefix = prefix;
      wrapMetrics.total = total;
      wrapMetrics.widthsKey = buildWidthsKey();
    }

    function measureWrappedHeightsDeferred() {
      const run = () => { try { measureWrappedHeights(); } catch {} };
      (window.requestIdleCallback || setTimeout)(run, 16);
    }

    // busca binária: primeira linha cujo topo acumulado ultrapassa y
    function lineAtY(y){
      const pre = wrapMetrics.prefix;
      let lo = 0, hi = pre.length - 1, ans = pre.length - 1;
      while (lo <= hi){
        const mid = (lo + hi) >> 1;
        if (pre[mid] > y){ ans = mid; hi = mid - 1; }
        else { lo = mid + 1; }
      }
      return ans; // índice (0-based)
    }

    // ===== Geometria unificada =====
    function lineGeometry(lineIdx) {
      const lh = parseFloat(getComputedStyle(editor).lineHeight);
      if (!wrapOn) {
        return { top: (lineIdx - 1) * lh, height: lh };
      }

      // Wrap: garante medições válidas
      if (!wrapMetrics.heights || wrapMetrics.widthsKey !== buildWidthsKey()) {
        measureWrappedHeights();
      }
      const h = wrapMetrics.heights[lineIdx - 1] ?? lh;
      const top = lineIdx <= 1 ? 0 : (wrapMetrics.prefix[lineIdx - 2] || 0);
      return { top, height: h };
    }

    // y relativo ao CONTEÚDO (sem padding) -> linha (1-based)
    function lineFromY(yContent) {
      if (!wrapOn) {
        const lh = parseFloat(getComputedStyle(editor).lineHeight);
        return Math.max(1, Math.floor(yContent / lh) + 1);
      }
      // usa sua busca binária sobre prefix[]
      return (lineAtY(yContent)) + 1;
    }

    function scrollLineIntoView(lineIdx, align = 'center') {
      const { top, height } = lineGeometry(lineIdx);
      const padTop = parseFloat(getComputedStyle(editor).paddingTop) || 0;
      let target;
      if (align === 'start') target = top;
      else if (align === 'end') target = top - (editor.clientHeight - height);
      else target = top - (editor.clientHeight / 2 - height / 2);
      editor.scrollTop = Math.max(0, target);
      updateProgress();
      renderGutter(false);
      updateMiniViewport();
    }

    // ===== Seleção de linhas =====
    function selectLineRange(fromLine, toLine) {
      const startLine = Math.max(1, Math.min(fromLine, toLine));
      const endLine = Math.max(fromLine, toLine);
      const start = getLineStartPosition(startLine);
      // fim no começo da próxima linha (ou final do texto)
      const end = endLine >= totalLines()
        ? editor.value.length
        : getLineStartPosition(endLine + 1) - 1; // -1 para incluir o \n
      editor.setSelectionRange(start, end);
      editor.focus();
      updateLnCol();
      showSelectionBand(startLine, endLine);
    }

    function showHoverBand(lineIdx) {
      const padTop = parseFloat(getComputedStyle(editor).paddingTop) || 0;
      const { top, height } = lineGeometry(lineIdx);
      hoverEl.style.top = (top - editor.scrollTop + padTop) + 'px';
      hoverEl.style.height = height + 'px';
      hoverEl.style.display = 'block';
    }
    function hideHoverBand() {
      hoverEl.style.display = 'none';
    }

    function showSelectionBand(fromLine, toLine) {
      const padTop = parseFloat(getComputedStyle(editor).paddingTop) || 0;
      const a = Math.max(1, Math.min(fromLine, toLine));
      const b = Math.max(fromLine, toLine);
      const gA = lineGeometry(a), gB = lineGeometry(b);
      const top = gA.top;
      const bottom = gB.top + gB.height;
      selEl.style.top = (top - editor.scrollTop + padTop) + 'px';
      selEl.style.height = (bottom - top) + 'px';
      selEl.style.display = 'block';
    }

    function clearSelectionBand() {
      selEl.style.display = 'none';
    }

    // ===== Gutter (line numbers) =====
    function totalLines(){ return (editor.value.match(/\n/g)||[]).length + 1; }
    
    // Função para encontrar a linha física baseada na posição do cursor
    function getPhysicalLineFromPosition(pos) {
      const textBeforeCursor = editor.value.slice(0, pos);
      return textBeforeCursor.split('\n').length;
    }
    
    // Função para obter a posição inicial de uma linha física
    function getLineStartPosition(lineNumber) {
      if (lineNumber <= 1) return 0;
      const lines = editor.value.split('\n');
      let pos = 0;
      for (let i = 0; i < lineNumber - 1; i++) {
        pos += lines[i].length + 1; // +1 para o \n
      }
      return pos;
    }
    
    // Função helper para criar elementos de linha com estilo consistente
    function createLineElement(lineNum, lineHeight, top = null, position = 'relative') {
      const div = document.createElement('div');
      div.className = 'ln';
      div.textContent = lineNum;
      
      // Adicionar classe bookmark se a linha estiver marcada
      if (lineUX.bookmarks.has(lineNum)) {
        div.classList.add('bookmark');
      }
      
      // Acessibilidade e tooltip
      div.setAttribute('role', 'option');
      div.setAttribute('aria-label', `Linha ${lineNum}`);
      div.setAttribute('title', 'Clique: selecionar • Shift+clique: intervalo • Alt+clique: marcador • Duplo clique: centralizar');
      
      // Estilo base consistente
      div.style.height = lineHeight + 'px';
      div.style.lineHeight = lineHeight + 'px';
      div.style.position = position;
      div.style.padding = '0 3px';
      div.style.textAlign = 'right';
      div.style.boxSizing = 'border-box';
      
      // Posicionamento específico para elementos absolutos
      if (position === 'absolute') {
        div.style.top = (top || 0) + 'px';
        div.style.left = '0';
        div.style.right = '0';
        div.style.width = '100%';
      }
      
      return div;
    }

    function renderGutter(force=false){
      if(!linesVisible) return;
      
      // Evita renderização simultânea
      if (renderGutter._rendering && !force) return;
      renderGutter._rendering = true;
      
      // DETECTAR MUDANÇA DE MODO para limpeza total
      const previousMode = renderGutter._lastMode;
      const currentMode = wrapOn ? 'wrap' : 'nowrap';
      const modeChanged = previousMode && previousMode !== currentMode;
      
      if (modeChanged || force) {
        gutter.innerHTML = '';
        gutter._inner = null;
        gutter._container = null;
      }
      
      renderGutter._lastMode = currentMode;
      
      // CONFIGURAÇÃO CONSISTENTE DE SCROLL
      // Sempre ocultar overflow para evitar scroll independente
      gutter.style.overflowY = 'hidden';
      gutter.style.overflowX = 'hidden';
      
      const tl = totalLines(); // Sempre conta apenas linhas físicas (quebras \n)
      const lh = parseFloat(getComputedStyle(editor).lineHeight);
      
      // Comportamentos completamente distintos para wrap vs sem wrap
      if (wrapOn) {
        // TRANSIÇÃO SEGURA PARA MODO WRAP
        // Sempre limpar conteúdo ao mudar de modo
        if (force) {
          gutter.innerHTML = '';
        }
        
        // fallback p/ arquivos gigantes (evita custo alto de medição)
        const big = editor.value.length > 500000 || tl > 20000;
        const needMeasure =
          !wrapMetrics.heights ||
          wrapMetrics.widthsKey !== buildWidthsKey();

        if (!big && (force || needMeasure)) {
          try {
            measureWrappedHeights();
          } catch (e) {
            console.warn('Erro ao medir alturas:', e);
            renderGutter._rendering = false;
            return;
          }
        }

        // Se muito grande, renderiza simples (melhor do que quebrar)
        if (big || !wrapMetrics.heights) {
          gutter.innerHTML = '';
          const frag = document.createDocumentFragment();
          for (let i = 1; i <= tl; i++) {
            const div = createLineElement(i, lh, null, 'relative');
            frag.appendChild(div);
          }
          gutter.appendChild(frag);
          lastRenderedLineCount = tl;
          renderGutter._rendering = false;
          return;
        }

        // Virtualização por altura real (wrap)
        const viewTop = editor.scrollTop;
        const viewH = editor.clientHeight;
        const viewBottom = viewTop + viewH;

        // Range visível + margem
        const startIdx = Math.max(0, lineAtY(Math.max(0, viewTop) ) - 3);
        const endIdx   = Math.min(wrapMetrics.heights.length - 1,
                                  lineAtY(viewBottom) + 3);

        // container interno para elementos virtuais
        if (!gutter._inner || !gutter._inner.isConnected) {
          // Garantir que não há conteúdo residual antes de criar o container
          gutter.innerHTML = '';
          
          gutter._inner = document.createElement('div');
          gutter._inner.style.position = 'relative';
          gutter._inner.style.width = '100%';
          gutter._inner.style.textAlign = 'right';
          gutter._inner.style.height = '100%'; // Altura relativa, não fixa
          gutter.appendChild(gutter._inner);
        }

        // Re-renderiza somente o range visível
        gutter._inner.innerHTML = '';
        const frag = document.createDocumentFragment();

        for (let i = startIdx; i <= endIdx; i++){
          const absoluteTop = i === 0 ? 0 : wrapMetrics.prefix[i - 1];
          // CORREÇÃO CRÍTICA: Posição relativa ao viewport para sincronização
          const relativeTop = absoluteTop - editor.scrollTop;
          const h = wrapMetrics.heights[i];
          const div = createLineElement(i + 1, h, relativeTop, 'absolute');
          frag.appendChild(div);
        }
        gutter._inner.appendChild(frag);

        lastRenderedLineCount = tl;
        renderGutter._rendering = false;
        return;
      } else {
        // TRANSIÇÃO SEGURA DO MODO WRAP PARA SEM WRAP
        // Limpeza completa para evitar sobreposições
        if (gutter._inner) {
          gutter._inner.remove();
          gutter._inner = null;
        }
        
        // Sempre limpar conteúdo ao mudar de modo
        if (force) {
          gutter.innerHTML = '';
        }
        
        // MODO SEM WRAP: Gutter sincronizado com editor
        const virtual = tl > 5000 || editor.value.length > 400000;
        
        gutter.style.position = 'relative';

        if (virtual) {
          // Renderização virtual para arquivos grandes
          const scrollTop = editor.scrollTop;
          const viewHeight = editor.clientHeight;
          
          // Obter o padding do editor para calcular o offset correto
          const editorStyles = getComputedStyle(editor);
          const editorPaddingTop = parseFloat(editorStyles.paddingTop) || 0;
          
          // Ajustar scrollTop para considerar apenas o conteúdo do texto
          const contentScrollTop = Math.max(0, scrollTop - editorPaddingTop);
          const startLine = Math.max(1, Math.floor(contentScrollTop / lh) - 2);
          const endLine = Math.min(tl, Math.ceil((contentScrollTop + viewHeight) / lh) + 2);
          
          if (force || Math.abs(scrollTop - (gutter._lastScrollTop || 0)) > lh) {
            gutter.innerHTML = '';
            gutter._lastScrollTop = scrollTop;
            
            const frag = document.createDocumentFragment();
            
            // Obter padding do gutter para alinhamento correto
            const gutterStyles = getComputedStyle(gutter);
            const gutterPaddingTop = parseFloat(gutterStyles.paddingTop) || 0;
            
            for (let lineNum = startLine; lineNum <= endLine; lineNum++) {
              // CORREÇÃO CRÍTICA: Posição relativa ao viewport, não absoluta
              const absoluteLineTop = (lineNum - 1) * lh;
              const relativeTop = absoluteLineTop - contentScrollTop + gutterPaddingTop;
              const div = createLineElement(lineNum, lh, relativeTop, 'absolute');
              frag.appendChild(div);
            }
            
            if (frag.children.length > 0) {
              gutter.appendChild(frag);
            }
          }
        } else {
          // Renderização normal para arquivos menores
          if (force || tl !== lastRenderedLineCount) {
            gutter.innerHTML = '';
            const frag = document.createDocumentFragment();
            
            for (let i = 1; i <= tl; i++) { 
              const div = createLineElement(i, lh, null, 'relative');
              frag.appendChild(div); 
            }
            gutter.appendChild(frag); 
            lastRenderedLineCount = tl;
          }
        }
        
        // Sincroniza scroll no modo sem wrap, garantindo que
        // o offset de scroll seja idêntico ao do editor
        gutter.scrollTop = editor.scrollTop;
      }
      
      renderGutter._rendering = false;
    }

    // ===== Theme Variable Declaration =====
    let currentTheme = 'auto';
    const lightScheme = window.matchMedia('(prefers-color-scheme: light)');

    // ===== Settings persist =====
    function persistSettings(){
      const data = {
        fs: Number(fontSize.value),
        lh: Number(lineHeight.value),
        pad: Number(padX.value),
        wrap: wrapOn, lines: linesVisible, mini: miniVisible,
        theme: currentTheme,
        glass: {
          blur: Number(document.getElementById('glassBlur')?.value || GLASS_DEFAULTS.blur),
          sat: Number(document.getElementById('glassSat')?.value || GLASS_DEFAULTS.sat),
          contrast: Number(document.getElementById('glassContrast')?.value || GLASS_DEFAULTS.contrast)
        },
        ui: {
          reduceMotion: uiReduceMotion,
          density: uiDensity,
          highContrast: uiHighContrast
        },
        editor: {
          autoSave: autoSaveEnabled,
          tabSize: tabSize,
          toolbar: toolbarVisible,
          statusBar: statusBarVisible,
          notesPanel: notesPanelVisible
        },
        currentId
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(data));
    }

    function restoreSettings(){
      const s = JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}');

      // Editor
      const fs = s.fs ?? 10; setVar('--editor-font-size', fs+'px'); fontSize.value = fs; fontSizeDisplay.textContent = fs; document.getElementById('fontSizeValueDisplay').textContent = fs + 'px'; updateRangeProgress(fontSize, fs, 8, 24);
      const lh = s.lh ?? 1.55; setVar('--line-height', lh); lineHeight.value = lh; document.getElementById('lineHeightValueDisplay').textContent = lh.toFixed(2); updateRangeProgress(lineHeight, lh, 1.3, 1.9);
      const pad = s.pad ?? 16; setVar('--editor-padding', pad+'px'); padX.value = pad; document.getElementById('padXValueDisplay').textContent = pad + 'px'; updateRangeProgress(padX, pad, 8, 40);

      wrapOn = !!(s.wrap ?? false); setWrap(wrapOn);
      linesVisible = !!(s.lines ?? false); setLineNumbers(linesVisible);
      miniVisible = !!(s.mini ?? false); setMinimap(miniVisible);

      // Tema
      setTheme(s.theme || 'auto');
      // Marcar radio de tema se existir (novo UI)
      const themeRadio = document.querySelector(`input[name="theme"][value="${currentTheme}"]`);
      if (themeRadio) themeRadio.checked = true;

      // Glass
      const g = Object.assign({}, GLASS_DEFAULTS, s.glass || {});
      applyGlass(g);
      ['glassBlur','glassSat','glassContrast'].forEach((id) => {
        const el = document.getElementById(id); 
        if (el) {
          const value = g[id === 'glassBlur' ? 'blur' : id === 'glassSat' ? 'sat' : 'contrast'];
          el.value = value;
          
          // Inicializar displays de valor
          if (id === 'glassBlur') {
            document.getElementById('glassBlurValue').textContent = value + 'px';
          } else if (id === 'glassSat') {
            document.getElementById('glassSatValue').textContent = value + '%';
          } else if (id === 'glassContrast') {
            document.getElementById('glassContrastValue').textContent = value.toFixed(2);
          }
        }
      });

      // UI
      const u = Object.assign({ reduceMotion:false, density:'comfortable', highContrast:false }, s.ui || {});
      uiReduceMotion = !!u.reduceMotion; applyMotion(uiReduceMotion);
      uiDensity = u.density; applyDensity(uiDensity);
      uiHighContrast = !!u.highContrast; applyContrast(uiHighContrast);
      const dm = document.querySelector(`input[name="density"][value="${uiDensity}"]`); if (dm) dm.checked = true;
      document.getElementById('switchMotion')?.setAttribute('aria-checked', String(uiReduceMotion));
      document.getElementById('switchContrast')?.setAttribute('aria-checked', String(uiHighContrast));

      // Novas configurações do editor
      const e = Object.assign({ 
        autoSave: true, 
        tabSize: 2, 
        toolbar: true, 
        statusBar: true, 
        notesPanel: true 
      }, s.editor || {});
      
      autoSaveEnabled = !!e.autoSave;
      tabSize = e.tabSize; applyTabSize(tabSize);
      toolbarVisible = !!e.toolbar; applyToolbarVisibility(toolbarVisible);
      statusBarVisible = !!e.statusBar; applyStatusBarVisibility(statusBarVisible);
      notesPanelVisible = !!e.notesPanel; applyNotesPanelVisibility(notesPanelVisible);
      
      // Atualizar controles UI - usar .checked para switches
      const autoSaveSwitch = document.getElementById('switchAutoSave');
      if (autoSaveSwitch) autoSaveSwitch.checked = autoSaveEnabled;
      
      const toolbarSwitch = document.getElementById('switchToolbar');
      if (toolbarSwitch) toolbarSwitch.checked = toolbarVisible;
      
      const statusBarSwitch = document.getElementById('switchStatusBar');
      if (statusBarSwitch) statusBarSwitch.checked = statusBarVisible;
      
      const notesPanelSwitch = document.getElementById('switchNotesPanel');
      if (notesPanelSwitch) notesPanelSwitch.checked = notesPanelVisible;
      
      const tabRadio = document.querySelector(`input[name="tabSize"][value="${tabSize}"]`);
      if (tabRadio) tabRadio.checked = true;

      if(s.currentId) currentId = s.currentId;
      updateHints();
    }
    function updateHints(){ 
      if (fontSizeHint)   fontSizeHint.textContent   = fontSize.value + ' px'; 
      if (lineHeightHint) lineHeightHint.textContent = Number(lineHeight.value).toFixed(2); 
      if (padXHint)       padXHint.textContent       = padX.value + ' px'; 
    }

    // Update range visual progress
    function updateRangeProgress(input, value, min, max) {
      const progress = ((value - min) / (max - min)) * 100;
      input.style.setProperty('--progress', progress + '%');
    }

    // Font size control functions
    function setFontSize(size) {
      const clampedSize = Math.max(8, Math.min(24, size));
      setVar('--editor-font-size', clampedSize + 'px');
      fontSize.value = clampedSize;
      fontSizeDisplay.textContent = clampedSize;
      if (fontSizeHint) fontSizeHint.textContent = clampedSize + ' px';
      updateRangeProgress(fontSize, clampedSize, 8, 24);
      
      // Visual feedback
      fontSizeDisplay.classList.add('changed');
      setTimeout(() => fontSizeDisplay.classList.remove('changed'), 300);
      
      persistSettings();
      renderGutter(true);
      updateMinimap(true);
    }

    function increaseFontSize() {
      const current = parseInt(fontSize.value);
      setFontSize(current + 1);
    }

    function decreaseFontSize() {
      const current = parseInt(fontSize.value);
      setFontSize(current - 1);
    }

    // ===== File open/save =====
    btnOpen?.addEventListener('click', ()=> fileInput.click());
    fileInput.addEventListener('change', async (e)=>{ const file = e.target.files[0]; if(!file) return; const text = await file.text(); editor.value = text; editor.scrollTop=0; editor.scrollLeft=0; editor.dispatchEvent(new Event('input')); e.target.value=''; });
    btnSaveFile?.addEventListener('click', ()=>{ 
      const idx = loadIndex();
      const meta = currentId ? idx.find(n => n.id === currentId) : null;
      const title = (meta && meta.title) ? meta.title.split('•')[0].trim().replace(/[^a-z0-9\s-]/gi, '_') : 'canvas';
      const filename = `${title}.md`;
      const blob = new Blob([editor.value], {type:'text/markdown;charset=utf-8'}); 
      const a = document.createElement('a'); 
      a.href = URL.createObjectURL(blob); 
      a.download = filename; 
      a.click(); 
      URL.revokeObjectURL(a.href); 
    });

    // ===== Notes Dialog events =====
    btnNotes.addEventListener('click', ()=>{ buildNotesList(); dlgNotes.showModal(); });
    btnNew.addEventListener('click', ()=>{ const id = createNote(''); openNote(id); });
    btnNewInside.addEventListener('click', ()=>{ const id = createNote(''); openNote(id); buildNotesList(); });
    btnDup.addEventListener('click', ()=>{ const id = createNote(editor.value); openNote(id); buildNotesList(); });
    btnDelAll.addEventListener('click', deleteAllNotes);
    noteFilter.addEventListener('input', () => buildNotesList(noteFilter.value));
    btnPrint?.addEventListener('click', () => window.print());
    btnExport.addEventListener('click', exportAllNotes);
    btnImport.addEventListener('click', () => importFile.click());
    importFile.addEventListener('change', handleImport);

    // ===== Toolbar toggles (agora independem do estado do switch) =====
    btnToggleWrap.addEventListener('click', ()=> setWrap(!wrapOn));
    btnToggleLines.addEventListener('click', ()=> setLineNumbers(!linesVisible));
    btnToggleMini.addEventListener('click', ()=> setMinimap(!miniVisible));

    // ===== Settings inputs =====
    // ========== Settings Modal interactions ==========
    // dlgSettings já declarado anteriormente

    // abrir com foco e trap
    btnSettings.addEventListener('click', () => { dlgSettings.showModal(); focusTrap(dlgSettings); });

    // ===== SETTINGS v2: navegação lateral, busca funcional e limpeza de duplicidades =====

    // CORREÇÃO: Garantir que o modal inicia fechado
    document.addEventListener('DOMContentLoaded', () => {
      const settingsModal = document.getElementById('settings');
      if (settingsModal && settingsModal.open) {
        settingsModal.close();
      }
    });

    // 1) Sidebar: rolar até a seção e destacar ativo
    const settingsDlg = document.getElementById('settings');
    const settingsBody = document.getElementById('settingsBody');
    const navButtons = Array.from(document.querySelectorAll('#settings .settings-nav [data-jump]'));
    const sections = Array.from(document.querySelectorAll('#settings .settings-section'));

    // CORREÇÃO ADICIONAL: Forçar fechamento imediato se estiver aberto
    if (settingsDlg && settingsDlg.open) {
      settingsDlg.close();
    }

    navButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const sel = btn.getAttribute('data-jump');
        const sec = document.querySelector(sel);
        if (!sec) return;
        
        // Marca como navegação manual e registra timestamp
        isManualNavigation = true;
        lastScrollTime = Date.now();
        manuallySelectedSection = sel; // Armazena a seção selecionada manualmente
        updateActiveNavigation(sel);
        
        // Comportamento de scroll diferenciado para seções finais
        const isBottomSection = ['#sec-files', '#sec-advanced', '#sec-about'].includes(sel);
        
        if (isBottomSection) {
          // Para seções finais, usa 'center' em vez de 'start' para evitar scroll excessivo
          sec.scrollIntoView({ behavior: 'smooth', block: 'center' });
        } else {
          sec.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        // Para seções problemáticas próximas ao final, usa timeout maior
        const timeout = isBottomSection ? 3000 : 1500;
        
        // Remove a flag após tempo suficiente para animação + margem de segurança
        setTimeout(() => {
          isManualNavigation = false;
          // Para seções finais, mantém a proteção por mais tempo
          if (!isBottomSection) {
            manuallySelectedSection = null;
          }
          // Força uma verificação final para garantir estado correto
          setTimeout(optimizedScrollSpy, 100);
        }, timeout);
        
        // Remove a proteção estendida para seções finais após 6 segundos
        if (isBottomSection) {
          setTimeout(() => {
            manuallySelectedSection = null;
          }, 6000);
        }
      });
    });

    // Função para atualizar navegação ativa
    function updateActiveNavigation(sectionId) {
      const previousActive = navButtons.find(b => b.hasAttribute('aria-current'));
      const previousId = previousActive ? previousActive.getAttribute('data-jump') : null;
      
      // Só atualiza se realmente mudou para evitar oscilações desnecessárias
      if (previousId === sectionId) return;
      
      navButtons.forEach(b => b.removeAttribute('aria-current'));
      const current = navButtons.find(b => b.getAttribute('data-jump') === sectionId);
      current?.setAttribute('aria-current', 'true');
      
      // Debug opcional (descomente para testar)
      // console.log('Active section changed:', previousId, '->', sectionId, 'Manual nav:', isManualNavigation);
    }

    // ScrollSpy otimizado com lógica melhorada para edge cases
    let scrollTimeout;
    let isManualNavigation = false;
    let lastScrollTime = 0;
    let manuallySelectedSection = null; // Armazena qual seção foi selecionada manualmente
    
    function optimizedScrollSpy() {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        // Evita conflitos durante navegação manual recente
        const timeSinceLastNav = Date.now() - lastScrollTime;
        if (isManualNavigation && timeSinceLastNav < 2000) return;
        
        const containerRect = settingsBody.getBoundingClientRect();
        const containerTop = containerRect.top;
        const containerHeight = containerRect.height;
        const containerBottom = containerTop + containerHeight;
        
        let activeSection = null;
        const visibleSections = [];
        
        // Primeiro passo: coleta todas as seções visíveis com suas métricas
        sections.forEach(section => {
          if (section.style.display === 'none') return; // Ignora seções filtradas
          
          const rect = section.getBoundingClientRect();
          const sectionTop = rect.top;
          const sectionBottom = rect.bottom;
          const sectionHeight = rect.height;
          
          // Verifica se a seção está pelo menos parcialmente visível
          if (sectionBottom > containerTop && sectionTop < containerBottom) {
            const visibleTop = Math.max(sectionTop, containerTop);
            const visibleBottom = Math.min(sectionBottom, containerBottom);
            const visibleHeight = visibleBottom - visibleTop;
            const visiblePercentage = visibleHeight / sectionHeight;
            
            visibleSections.push({
              section,
              rect,
              sectionTop,
              sectionBottom,
              sectionHeight,
              visibleHeight,
              visiblePercentage,
              distanceFromTop: Math.abs(sectionTop - containerTop),
              isFullyVisible: sectionTop >= containerTop && sectionBottom <= containerBottom,
              centerDistance: Math.abs((sectionTop + sectionBottom) / 2 - (containerTop + containerHeight / 2))
            });
          }
        });
        
        if (visibleSections.length === 0) return;
        
        // Ordena seções por posição (primeira no topo)
        visibleSections.sort((a, b) => a.sectionTop - b.sectionTop);
        
        // Estratégia de seleção refinada
        const scrollTop = settingsBody.scrollTop;
        const scrollHeight = settingsBody.scrollHeight;
        const maxScroll = scrollHeight - containerHeight;
        
        // Condições MUITO mais restritivas para comportamentos especiais
        const isVeryTop = scrollTop < 10; // Extremamente restritivo para o topo
        
        // Para o fundo, só considera se está REALMENTE no final E não é navegação manual recente
        const isAtAbsoluteBottom = scrollTop >= maxScroll - 5 && maxScroll > 0;
        const canUseBottomLogic = isAtAbsoluteBottom && timeSinceLastNav > 4000; // 4 segundos de proteção
        
        if (isVeryTop && visibleSections.length > 0) {
          // Apenas quando realmente no topo absoluto
          activeSection = visibleSections[0].section;
        } else if (canUseBottomLogic && visibleSections.length > 0) {
          // Apenas quando realmente no fundo absoluto E sem navegação manual recente
          const lastSection = visibleSections[visibleSections.length - 1];
          if (lastSection.section === sections[sections.length - 1] && lastSection.visiblePercentage > 0.5) {
            activeSection = lastSection.section;
          } else {
            // Se não está realmente vendo a última seção bem, usa lógica normal
            activeSection = null; // Força uso da lógica padrão abaixo
          }
        }
        
        // Se não foi determinado por condições especiais, usa lógica padrão
        if (!activeSection) {
          // PROTEÇÃO SUPER FORTE: Se há uma seção selecionada manualmente, prioriza ela
          if (manuallySelectedSection) {
            const manualSectionId = manuallySelectedSection.substring(1);
            const manualSection = visibleSections.find(s => s.section.id === manualSectionId);
            
            if (manualSection && manualSection.visiblePercentage > 0.15) { // Muito tolerante
              activeSection = manualSection.section;
            }
          }
          
          // Verificação adicional: se há uma seção atualmente ativa via navegação manual,
          // verifica se ela ainda está razoavelmente visível antes de mudá-la
          if (!activeSection) {
            const currentlyActive = navButtons.find(b => b.hasAttribute('aria-current'));
            if (currentlyActive) {
              const currentSectionId = currentlyActive.getAttribute('data-jump').substring(1);
              const currentSection = visibleSections.find(s => s.section.id === currentSectionId);
              
              // Proteção muito forte para seções finais após navegação manual
              const isBottomSectionActive = ['sec-files', 'sec-advanced', 'sec-about'].includes(currentSectionId);
              const protectionTime = isBottomSectionActive ? 5000 : 3000; // 5s para seções finais
              const minVisibility = isBottomSectionActive ? 0.2 : 0.3; // Menos exigente para seções finais
              
              if (timeSinceLastNav < protectionTime && currentSection && currentSection.visiblePercentage > minVisibility) {
                activeSection = currentSection.section;
              }
            }
          }
          
          // Se ainda não determinou uma seção, usa estratégia hierárquica refinada
          if (!activeSection) {
            // Prioridade 1: Seção com mais de 60% visível (aumentado de 50%)
            let bestSection = visibleSections.find(s => s.visiblePercentage > 0.6);
            
            if (bestSection) {
              activeSection = bestSection.section;
            } else {
              // Prioridade 2: Seção completamente visível (para seções pequenas)
              bestSection = visibleSections.find(s => s.isFullyVisible);
              
              if (bestSection) {
                activeSection = bestSection.section;
              } else {
                // Prioridade 3: Seção que cruza a linha de referência (25% do topo - mais baixo)
                const referencePoint = containerTop + (containerHeight * 0.25);
                bestSection = visibleSections.find(s => 
                  s.sectionTop <= referencePoint && s.sectionBottom > referencePoint
                );
                
                if (bestSection) {
                  activeSection = bestSection.section;
                } else {
                  // Prioridade 4: Seção com maior área visível
                  bestSection = visibleSections.reduce((best, current) => {
                    return current.visibleHeight > best.visibleHeight ? current : best;
                  });
                  
                  if (bestSection) {
                    activeSection = bestSection.section;
                  } else {
                    // Fallback final: seção mais próxima do centro
                    bestSection = visibleSections.reduce((closest, current) => {
                      return current.centerDistance < closest.centerDistance ? current : closest;
                    });
                    activeSection = bestSection.section;
                  }
                }
              }
            }
          }
        }
        
        if (activeSection) {
          const id = '#' + activeSection.id;
          updateActiveNavigation(id);
        }
      }, 100);
    }

    // Event listeners para scroll otimizado
    settingsBody.addEventListener('scroll', optimizedScrollSpy, { passive: true });
    
    // Listener para quando o scroll termina (melhor detecção de fim de animação)
    if ('onscrollend' in window) {
      settingsBody.addEventListener('scrollend', () => {
        if (isManualNavigation) {
          // Aguarda um pouco mais antes de reativar o scrollspy
          setTimeout(() => {
            isManualNavigation = false;
            optimizedScrollSpy();
          }, 200);
        }
      });
    }
    
    // ResizeObserver para recalcular quando o modal muda de tamanho
    if (window.ResizeObserver) {
      const resizeObserver = new ResizeObserver(() => {
        if (!isManualNavigation) {
          optimizedScrollSpy();
        }
      });
      resizeObserver.observe(settingsBody);
    }
    
    // Inicializa o estado ativo
    optimizedScrollSpy();

    // 2) Busca funcional (filtra grupos e destaca matches)
    const settingsSearch = document.getElementById('settingsSearch');

    function clearMarks(root) {
      root.querySelectorAll('mark.settings-hit').forEach(m => {
        const t = document.createTextNode(m.textContent);
        m.replaceWith(t);
      });
    }

    function highlightText(el, query) {
      if (!query) return;
      const rx = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      for (const node of Array.from(el.childNodes)) {
        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
          const parts = node.textContent.split(rx);
          if (parts.length > 1) {
            const frag = document.createDocumentFragment();
            parts.forEach((p, i) => {
              if (i % 2 === 1) {
                const mark = document.createElement('mark');
                mark.className = 'settings-hit';
                mark.textContent = p;
                frag.appendChild(mark);
              } else {
                frag.appendChild(document.createTextNode(p));
              }
            });
            node.replaceWith(frag);
          }
        }
      }
    }

    function filterSettings(q) {
      const query = (q || '').trim().toLowerCase();
      let firstMatch = null;

      sections.forEach(section => {
        clearMarks(section);
        let sectionHasMatch = false;

        // cada .subsection é uma "categoria" vertical
        section.querySelectorAll('.subsection').forEach(sub => {
          clearMarks(sub);
          const text = sub.textContent.toLowerCase();
          const match = query ? text.includes(query) : true;
          sub.style.display = match ? '' : 'none';
          if (match && query) {
            // highlight em títulos e labels
            sub.querySelectorAll('h4, label, .hint, .section-head').forEach(el => highlightText(el, query));
            if (!firstMatch) firstMatch = sub;
          }
          sectionHasMatch = sectionHasMatch || match;
        });

        // se nenhuma subseção bateu, esconde a seção
        section.style.display = sectionHasMatch ? '' : 'none';
      });

      // navega ao primeiro resultado
      if (firstMatch) {
        firstMatch.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
      
      // Recalcula o scrollspy após filtrar
      setTimeout(optimizedScrollSpy, 100);
    }

    settingsSearch.addEventListener('input', (e) => filterSettings(e.target.value));

    // Atalho: / foca busca; Enter vai para primeira seção com hit
    settingsDlg.addEventListener('keydown', (e) => {
      if (e.key === '/' && (document.activeElement.tagName !== 'INPUT')) {
        e.preventDefault(); 
        settingsSearch.focus(); 
        settingsSearch.select();
      } else if (e.key === 'Enter' && document.activeElement === settingsSearch) {
        const firstVisible = settingsBody.querySelector('.settings-section:not([style*="display: none"])');
        firstVisible?.scrollIntoView({behavior:'smooth', block:'start'});
      }
    });

    // 3) Switches (novos com <input type="checkbox">): sincronizar com seu estado
    function reflectSwitchesFromState() {
      document.getElementById('switchWrap').checked  = !!wrapOn;
      document.getElementById('switchLines').checked = !!linesVisible;
      document.getElementById('switchMini').checked  = !!miniVisible;
      document.getElementById('switchMotion').checked   = !!uiReduceMotion;
      document.getElementById('switchContrast').checked = !!uiHighContrast;
      
      // Novos switches - usar .checked em vez de setAttribute
      const autoSaveSwitch = document.getElementById('switchAutoSave');
      if (autoSaveSwitch) autoSaveSwitch.checked = autoSaveEnabled;
      
      const toolbarSwitch = document.getElementById('switchToolbar');
      if (toolbarSwitch) toolbarSwitch.checked = toolbarVisible;
      
      const statusBarSwitch = document.getElementById('switchStatusBar');
      if (statusBarSwitch) statusBarSwitch.checked = statusBarVisible;
      
      const notesPanelSwitch = document.getElementById('switchNotesPanel');
      if (notesPanelSwitch) notesPanelSwitch.checked = notesPanelVisible;
    }
    reflectSwitchesFromState();

    // 4) Listeners dos switches (reaproveitando suas funções apply/persist)
    document.getElementById('switchWrap').addEventListener('change', (e)=> setWrap(e.target.checked));
    document.getElementById('switchLines').addEventListener('change', (e)=> setLineNumbers(e.target.checked));
    document.getElementById('switchMini').addEventListener('change', (e)=> setMinimap(e.target.checked));
    document.getElementById('switchMotion').addEventListener('change', (e)=> { uiReduceMotion = e.target.checked; applyMotion(uiReduceMotion); persistSettings(); });
    document.getElementById('switchContrast').addEventListener('change', (e)=> { uiHighContrast = e.target.checked; applyContrast(uiHighContrast); persistSettings(); });

    // Event listeners para novas configurações
    document.getElementById('switchAutoSave')?.addEventListener('change', (e)=> { 
      autoSaveEnabled = e.target.checked; 
      persistSettings(); 
    });
    document.getElementById('switchToolbar')?.addEventListener('change', (e)=> { 
      toolbarVisible = e.target.checked; 
      applyToolbarVisibility(toolbarVisible); 
      persistSettings(); 
    });
    document.getElementById('switchStatusBar')?.addEventListener('change', (e)=> { 
      statusBarVisible = e.target.checked; 
      applyStatusBarVisibility(statusBarVisible); 
      persistSettings(); 
    });
    document.getElementById('switchNotesPanel')?.addEventListener('change', (e)=> { 
      notesPanelVisible = e.target.checked; 
      applyNotesPanelVisibility(notesPanelVisible); 
      persistSettings(); 
    });

    // Event listener para tamanho de tabulação
    document.querySelectorAll('input[name="tabSize"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        if (e.target.checked) {
          tabSize = Number(e.target.value);
          applyTabSize(tabSize);
          persistSettings();
        }
      });
    });

    // 5) Tema & Densidade (mantém compatibilidade)
    document.querySelectorAll('input[name="theme"]').forEach(r => {
      r.addEventListener('change', ()=> { setTheme(r.value); persistSettings(); });
    });
    document.querySelectorAll('input[name="density"]').forEach(r => {
      r.addEventListener('change', ()=> { uiDensity = r.value; applyDensity(uiDensity); persistSettings(); });
    });

    // 6) Ao abrir o modal, garantir estado dos switches + limpar busca + inicializar scrollspy
    document.getElementById('btnSettings').addEventListener('click', () => {
      settingsSearch.value = '';
      filterSettings('');
      reflectSwitchesFromState();
      // Inicializa scrollspy após um pequeno delay para garantir que o modal esteja renderizado
      setTimeout(() => {
        optimizedScrollSpy();
        // Garantir que a primeira seção esteja ativa inicialmente
        if (navButtons.length > 0 && !navButtons.find(b => b.hasAttribute('aria-current'))) {
          navButtons[0].setAttribute('aria-current', 'true');
        }
      }, 100);
    });

    // 7) Conectar botões de importar/exportar ao sistema existente
    document.getElementById('btnImportFromSettings')?.addEventListener('click', () => {
      document.getElementById('inputCfg')?.click();
    });
    document.getElementById('btnExportFromSettings')?.addEventListener('click', () => {
      exportSettings();
    });

    // ===== SETTINGS I/O (Export/Import/Reset) =====
    (function(){
      const KEY = 'editor:settings:v5';

      function exportSettings(){
        const data = localStorage.getItem(KEY) || '{}';
        const blob = new Blob([data], {type:'application/json'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `canvas_settings_${new Date().toISOString().slice(0,10)}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
      }

      function importSettingsFile(file){
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          try{
            const obj = JSON.parse(reader.result);
            localStorage.setItem(KEY, JSON.stringify(obj));
            // Reaplicar imediatamente
            restoreSettings();
            // Refresca UI dependente
            renderGutter(true);
            updateMinimap(true);
            alert('Configurações importadas.');
          }catch(err){ alert('Arquivo inválido.'); }
        };
        reader.readAsText(file);
      }

      function resetSettingsAll(){
        localStorage.removeItem(KEY);
        restoreSettings();
        renderGutter(true);
        updateMinimap(true);
        alert('Configurações restauradas aos padrões.');
      }

      // Botões
      document.getElementById('btnExportSettings')?.addEventListener('click', exportSettings);
      document.getElementById('btnExportSettings2')?.addEventListener('click', exportSettings);

      // Import de config: use um input escondido para não confundir com import de notas
      let inputCfg = document.getElementById('importSettingsFile');
      if(!inputCfg){
        inputCfg = document.createElement('input');
        inputCfg.type = 'file';
        inputCfg.accept = '.json';
        inputCfg.id = 'importSettingsFile';
        inputCfg.hidden = true;
        document.body.appendChild(inputCfg);
      }

      document.getElementById('btnImportNotes')?.addEventListener('click', () => {
        // este é para NOTAS, já existe handleImport() (de notas)
        document.getElementById('importFile')?.click();
      });

      // Se quiser um botão de Importar Config em "Avançado", crie-o e ligue aqui:
      document.getElementById('btnImportSettings')?.addEventListener('click', () => inputCfg.click());
      inputCfg.addEventListener('change', e => importSettingsFile(e.target.files[0]));

      // Reset geral
      document.getElementById('btnResetSettings')?.addEventListener('click', resetSettingsAll);
      document.getElementById('btnResetSettings2')?.addEventListener('click', resetSettingsAll);
    })();

    // 1) Chipbar: rolar até a seção e marcar chip ativo
    // Observa rolagem para atualizar chip ativo (antiga implementação removida)

    // 3) Quick toggles iguais à toolbar (antigas funções removidas)
    // 4) Reset/Export atalhos duplicados (head e seção avançado) (antigas funções removidas)
    // 5) Reset de SEÇÃO (opcional, se quiser granular) (antigas funções removidas)
    // Exemplo: chame resetSection('appearance') de um botão que você inserir no summary da seção.
    function resetSection(sectionId){
      if (!confirm('Restaurar padrões desta seção?')) return;

      switch(sectionId){
        case 'appearance': {
          // tema auto + glass defaults
          document.getElementById('theme-auto').checked = true; setTheme('auto');
          const g = { blur: 12, sat: 150, contrast: 1.04 };
          document.getElementById('glassBlur').value = g.blur;
          document.getElementById('glassSat').value = g.sat;
          document.getElementById('glassContrast').value = g.contrast;
          document.getElementById('glassBlurValue').textContent = g.blur + 'px';
          document.getElementById('glassSatValue').textContent = g.sat + '%';
          document.getElementById('glassContrastValue').textContent = g.contrast.toFixed(2);
          applyGlass(g); persistSettings();
          break;
        }
        case 'editor': {
          setFontSize(10);
          lineHeight.value = 1.55; document.getElementById('lineHeightValueDisplay').textContent = '1.55';
          setVar('--line-height', '1.55');
          padX.value = 16; document.getElementById('padXValueDisplay').textContent = '16px';
          setVar('--editor-padding', '16px');
          setWrap(false); setLineNumbers(false); setMinimap(false);
          persistSettings(); renderGutter(true); updateMinimap(true);
          break;
        }
        case 'interface': {
          uiReduceMotion = false; applyMotion(uiReduceMotion);
          uiDensity = 'comfortable'; applyDensity(uiDensity);
          document.getElementById('switchMotion').setAttribute('aria-checked','false');
          document.querySelector('#densitySeg input[value="comfortable"]').checked = true;
          persistSettings();
          break;
        }
        case 'accessibility': {
          uiHighContrast = false; applyContrast(false);
          document.getElementById('switchContrast').setAttribute('aria-checked','false');
          persistSettings();
          break;
        }
      }
    }

    // tema (segmented)
    document.querySelectorAll('input[name="theme"]').forEach(r=>{
      r.addEventListener('change', (e)=> setTheme(e.target.value));
    });

    // glass sliders
    ['glassBlur','glassSat','glassContrast'].forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener('input', ()=>{
        const value = Number(el.value);
        
        // Atualizar displays de valor
        if (id === 'glassBlur') {
          document.getElementById('glassBlurValue').textContent = value + 'px';
        } else if (id === 'glassSat') {
          document.getElementById('glassSatValue').textContent = value + '%';
        } else if (id === 'glassContrast') {
          document.getElementById('glassContrastValue').textContent = value.toFixed(2);
        }
        
        applyGlass({
          blur: Number(document.getElementById('glassBlur').value),
          sat: Number(document.getElementById('glassSat').value),
          contrast: Number(document.getElementById('glassContrast').value)
        });
        persistSettings();
      });
    });

    // density segmented
    document.getElementById('densitySeg')?.addEventListener('change', (e)=>{
      if (e.target.name === 'density'){
        uiDensity = e.target.value; applyDensity(uiDensity); persistSettings();
      }
    });

    // switches interface
    function toggleAriaSwitch(swId, on){
      const sw = document.getElementById(swId); if(!sw) return;
      const next = (on !== undefined) ? !!on : !(sw.getAttribute('aria-checked')==='true');
      sw.setAttribute('aria-checked', String(next));
      return next;
    }
    document.getElementById('switchMotion')?.addEventListener('click', ()=>{
      uiReduceMotion = toggleAriaSwitch('switchMotion');
      applyMotion(uiReduceMotion); persistSettings();
    });
    document.getElementById('switchContrast')?.addEventListener('click', ()=>{
      uiHighContrast = toggleAriaSwitch('switchContrast');
      applyContrast(uiHighContrast); persistSettings();
    });

    // botões utilidades (algumas removidas - agora integradas nas novas implementações)
    document.getElementById('btnExportFromSettings')?.addEventListener('click', ()=> btnExport.click());

    // ========== Help Center v2 — Liquid Glass ==========
    const dlgHelp = document.getElementById('help');
    const helpNavItems = document.querySelectorAll('.help-nav-item');
    const helpSections = document.querySelectorAll('.help-section');
    const helpSearch = document.getElementById('helpSearch');
    const helpTitle = document.querySelector('.help-title');
    const searchResultsSection = document.getElementById('section-search-results');
    const searchResults = document.getElementById('searchResults');
    
    // Keyboard shortcuts database (source of truth) - Expandido e Reorganizado
    const KEYBOARD_SHORTCUTS = [
      // === Arquivos ===
      { desc: 'Nova Nota', keys: ['⌘', 'N'], category: 'Arquivos', detail: 'Cria uma nova nota em branco' },
      { desc: 'Abrir Gerenciador de Notas', keys: ['⌘', 'O'], category: 'Arquivos', detail: 'Abre o painel de gerenciamento de notas' },
      { desc: 'Salvar como Arquivo', keys: ['⌘', 'S'], category: 'Arquivos', detail: 'Salva a nota atual como arquivo .md' },
      { desc: 'Imprimir', keys: ['⌘', 'P'], category: 'Arquivos', detail: 'Abre a visualização de impressão' },
      
      // === Edição de Texto ===
      { desc: 'Desfazer', keys: ['⌘', 'Z'], category: 'Edição', detail: 'Desfaz a última alteração' },
      { desc: 'Refazer', keys: ['⌘', 'Shift', 'Z'], category: 'Edição', detail: 'Refaz a última alteração desfeita' },
      { desc: 'Selecionar Tudo', keys: ['⌘', 'A'], category: 'Edição', detail: 'Seleciona todo o texto do documento' },
      { desc: 'Copiar', keys: ['⌘', 'C'], category: 'Edição', detail: 'Copia a seleção para a área de transferência' },
      { desc: 'Recortar', keys: ['⌘', 'X'], category: 'Edição', detail: 'Recorta a seleção para a área de transferência' },
      { desc: 'Colar', keys: ['⌘', 'V'], category: 'Edição', detail: 'Cola o conteúdo da área de transferência' },
      { desc: 'Duplicar Linha/Seleção', keys: ['⌘', 'D'], category: 'Edição', detail: 'Duplica a linha atual ou seleção' },
      { desc: 'Mover Linha para Cima', keys: ['Alt', '↑'], category: 'Edição', detail: 'Move a linha atual para cima' },
      { desc: 'Mover Linha para Baixo', keys: ['Alt', '↓'], category: 'Edição', detail: 'Move a linha atual para baixo' },
      { desc: 'Renomear Nota', keys: ['F2'], category: 'Edição', detail: 'Edita o título da nota atual' },
      
      // === Busca e Navegação ===
      { desc: 'Buscar', keys: ['⌘', 'F'], category: 'Busca e Navegação', detail: 'Abre a barra de busca' },
      { desc: 'Buscar e Substituir', keys: ['⌘', 'H'], category: 'Busca e Navegação', detail: 'Abre a barra de busca com substituição' },
      { desc: 'Próximo Resultado', keys: ['F3'], category: 'Busca e Navegação', detail: 'Vai para o próximo resultado da busca' },
      { desc: 'Resultado Anterior', keys: ['Shift', 'F3'], category: 'Busca e Navegação', detail: 'Vai para o resultado anterior da busca' },
      { desc: 'Ir para Linha', keys: ['⌘', 'G'], category: 'Busca e Navegação', detail: 'Salta para uma linha específica' },
      { desc: 'Fechar Busca', keys: ['Escape'], category: 'Busca e Navegação', detail: 'Fecha a barra de busca' },
      
      // === Visualização ===
      { desc: 'Quebra de Linha', keys: ['Alt', 'Z'], category: 'Visualização', detail: 'Liga/desliga quebra automática de linha' },
      { desc: 'Alternar Numeração', keys: ['⌘', 'L'], category: 'Visualização', detail: 'Mostra/oculta números de linha' },
      { desc: 'Alternar Bookmark', keys: ['⌘', 'B'], category: 'Visualização', detail: 'Liga/desliga bookmark na linha atual' },
      { desc: 'Alternar Bookmark (Alt)', keys: ['F3'], category: 'Visualização', detail: 'Alternativa para bookmark' },
      { desc: 'Alternar Minimap', keys: ['⌘', 'M'], category: 'Visualização', detail: 'Mostra/oculta o minimap' },
      { desc: 'Aumentar Fonte', keys: ['⌘', '+'], category: 'Visualização', detail: 'Aumenta o tamanho da fonte' },
      { desc: 'Diminuir Fonte', keys: ['⌘', '-'], category: 'Visualização', detail: 'Diminui o tamanho da fonte' },
      { desc: 'Resetar Fonte', keys: ['⌘', '0'], category: 'Visualização', detail: 'Restaura o tamanho padrão da fonte' },
      { desc: 'Modo Foco', keys: ['F11'], category: 'Visualização', detail: 'Alterna para tela cheia (depende do navegador)' },
      
      // === Sistema ===
      { desc: 'Ajustes', keys: ['⌘', ','], category: 'Sistema', detail: 'Abre o painel de configurações' },
      { desc: 'Centro de Ajuda', keys: ['⌘', '/'], category: 'Sistema', detail: 'Abre este centro de ajuda' },
      { desc: 'Fechar Modal', keys: ['Escape'], category: 'Sistema', detail: 'Fecha qualquer modal ou painel aberto' },
      
      // === Atalhos Especiais ===
      { desc: 'Clique na Linha/Coluna', keys: ['Click'], category: 'Especiais', detail: 'Clique no rodapé para ir para linha' },
      { desc: 'Duplo Clique no Título', keys: ['Double Click'], category: 'Especiais', detail: 'Duplo clique no título para renomear' },
      { desc: 'Arrastar Arquivo', keys: ['Drag & Drop'], category: 'Especiais', detail: 'Arraste .txt/.md para abrir' }
    ];

    // Platform detection for shortcuts
    const isMac = /Mac|iPhone|iPad|iPod/.test(navigator.platform);
    
    function formatShortcutKey(key) {
      if (key === '⌘') return isMac ? '⌘' : 'Ctrl';
      return key;
    }
    
    function renderShortcutKeys(keys) {
      return keys.map(key => `<span class="key">${formatShortcutKey(key)}</span>`).join('<span class="key-plus">+</span>');
    }

    // Content database for search
    const HELP_CONTENT = [
      {
        section: 'overview',
        title: 'Visão Geral',
        content: 'Canvas editor de texto moderno minimalista produtividade experiência usuário interface limpa numeração linhas minimap busca avançada',
        snippet: 'Um editor de texto moderno e minimalista com foco na produtividade.'
      },
      {
        section: 'shortcuts',
        title: 'Atalhos de Teclado',
        content: 'atalhos teclado shortcuts keyboard nova nota abrir buscar substituir ir linha duplicar mover quebra renomear fonte aumentar diminuir resetar numeração minimap ajustes ajuda',
        snippet: 'Acelere seu fluxo de trabalho com atalhos poderosos.'
      },
      {
        section: 'features',
        title: 'Funcionalidades',
        content: 'busca substituição regex expressões regulares minimap navegação gerenciador notas filtros exportação importação configurações fontes temas auto-salvamento',
        snippet: 'Sistema avançado de busca, minimap, gerenciador de notas e muito mais.'
      },
      {
        section: 'tips',
        title: 'Dicas e Truques',
        content: 'dicas truques regex multilinha mover duplicar navegação drag drop arquivos txt md',
        snippet: 'Aprenda truques para ser mais produtivo no Canvas.'
      },
      {
        section: 'about',
        title: 'Sobre',
        content: 'sobre canvas liquid glass blur transparências client-side acessibilidade responsivo armazenamento local',
        snippet: 'Saiba mais sobre o Canvas e suas características.'
      }
    ];

    // Initialize help center
    btnHelp.addEventListener('click', () => { 
      dlgHelp.showModal(); 
      focusTrap(dlgHelp); 
      // Ensure shortcuts are rendered when help opens
      setTimeout(renderShortcuts, 100);
    });
    
    // Event listener para o Markdown Viewer
    document.addEventListener('DOMContentLoaded', function() {
      const btnMarkdownPreview = document.getElementById('btnMarkdownPreview');
      if (btnMarkdownPreview) {
        btnMarkdownPreview.addEventListener('click', () => {
          const content = editor.value;
          if (content.trim()) {
            const meta = getCurrentNoteMeta();
            const title = meta ? `${meta.title}.md` : 'Nota.md';
            if (typeof openMarkdownViewer === 'function') {
              openMarkdownViewer({ 
                markdown: content, 
                title: title 
              });
            } else {
              showToast('MDV ainda não foi carregado', 'error');
            }
          } else {
            // Exemplo de teste se não houver conteúdo
            if (typeof openMarkdownViewer === 'function') {
              openMarkdownViewer({
                title: 'Demo MDV',
                markdown: `# Visualizador de Markdown

Este é o **Visualizador de Markdown (MDV)** do Canvas de Texto!

## Recursos

- ✅ Renderização completa de Markdown
- ✅ Destaque de sintaxe com \`highlight.js\`
- ✅ Busca in-page com navegação
- ✅ Zoom ajustável
- ✅ Design Liquid Glass
- ✅ Suporte a LaTeX: $E=mc^2$
- ✅ Suporte a Mermaid (diagramas)

### Exemplo de código

\`\`\`javascript
function exemplo() {
  console.log("Olá, MDV!");
}
\`\`\`

### Exemplo de tabela

| Recurso | Status |
|---------|--------|
| Markdown | ✅ |
| LaTeX | ✅ |
| Mermaid | ✅ |

### Blockquote

> Este é um exemplo de citação no MDV.

---

**Pressione \`/\` para buscar ou use Ctrl+/Cmd+ e Ctrl-/Cmd- para zoom!**`
              });
            } else {
              showToast('MDV ainda não foi carregado', 'error');
            }
          }
        });
      }
    });

    // Navigation between sections
    helpNavItems.forEach(item => {
      item.addEventListener('click', () => {
        const sectionId = item.dataset.section;
        showHelpSection(sectionId);
        
        // Update navigation state
        helpNavItems.forEach(nav => nav.classList.remove('active'));
        item.classList.add('active');
        
        // Clear search if navigating manually
        if (helpSearch.value) {
          helpSearch.value = '';
          helpTitle.textContent = 'Centro de Ajuda';
        }
      });
    });

    function showHelpSection(sectionId) {
      helpSections.forEach(section => {
        section.classList.remove('active');
        if (section.id === `section-${sectionId}`) {
          section.classList.add('active');
        }
      });
    }

    function renderShortcuts() {
      const shortcutsList = document.getElementById('shortcutsList');
      if (!shortcutsList) return;
      
      // Group shortcuts by category
      const groupedShortcuts = {};
      KEYBOARD_SHORTCUTS.forEach(shortcut => {
        if (!groupedShortcuts[shortcut.category]) {
          groupedShortcuts[shortcut.category] = [];
        }
        groupedShortcuts[shortcut.category].push(shortcut);
      });
      
      // Category icons
      const categoryIcons = {
        'Arquivos': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14,2 14,8 20,8"/></svg>',
        'Edição': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>',
        'Busca e Navegação': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/></svg>',
        'Visualização': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>',
        'Sistema': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>',
        'Especiais': '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>'
      };
      
      let html = '';
      
      // Render categories in order
      const categoryOrder = ['Arquivos', 'Edição', 'Busca e Navegação', 'Visualização', 'Sistema', 'Especiais'];
      
      categoryOrder.forEach(category => {
        if (groupedShortcuts[category]) {
          const shortcuts = groupedShortcuts[category];
          const icon = categoryIcons[category] || '';
          
          html += `
            <div class="shortcuts-category" data-category="${category}">
              <h3 class="shortcuts-category-title">
                <span class="shortcuts-category-icon">${icon}</span>
                ${category}
              </h3>
              <div class="shortcuts-list">
          `;
          
          shortcuts.forEach(shortcut => {
            html += `
              <div class="shortcut-item">
                <div class="shortcut-info">
                  <div class="shortcut-desc">${shortcut.desc}</div>
                  <div class="shortcut-detail">${shortcut.detail}</div>
                </div>
                <div class="shortcut-keys">${renderShortcutKeys(shortcut.keys)}</div>
              </div>
            `;
          });
          
          html += `
              </div>
            </div>
          `;
        }
      });
      
      shortcutsList.innerHTML = html;
    }

    // Search functionality
    helpSearch.addEventListener('input', debounce((e) => {
      const query = e.target.value.trim().toLowerCase();
      
      if (!query) {
        // Return to current section or default
        const activeNav = document.querySelector('.help-nav-item.active');
        const currentSection = activeNav ? activeNav.dataset.section : 'overview';
        showHelpSection(currentSection);
        helpTitle.textContent = 'Centro de Ajuda';
        return;
      }
      
      performHelpSearch(query);
    }, 300));

    function performHelpSearch(query) {
      // Search in content and shortcuts
      const results = [];
      
      // Search help content
      HELP_CONTENT.forEach(item => {
        if (item.content.includes(query) || item.title.toLowerCase().includes(query)) {
          results.push({
            type: 'content',
            section: item.section,
            title: item.title,
            snippet: highlightText(item.snippet, query)
          });
        }
      });
      
      // Search shortcuts
      KEYBOARD_SHORTCUTS.forEach(shortcut => {
        const desc = shortcut.desc.toLowerCase();
        const detail = shortcut.detail.toLowerCase();
        const keys = shortcut.keys.join(' ').toLowerCase();
        const category = shortcut.category.toLowerCase();
        
        if (desc.includes(query) || detail.includes(query) || keys.includes(query) || category.includes(query)) {
          results.push({
            type: 'shortcut',
            title: shortcut.desc,
            snippet: `${shortcut.detail} — Atalho: ${shortcut.keys.map(formatShortcutKey).join(' + ')}`,
            shortcut: shortcut,
            section: 'shortcuts'
          });
        }
      });
      
      displaySearchResults(results, query);
    }

    function displaySearchResults(results, query) {
      helpTitle.textContent = `Resultados para "${query}"`;
      
      let html = '';
      if (results.length === 0) {
        html = `
          <div style="text-align: center; padding: 40px; color: color-mix(in srgb, var(--c-content) 60%, transparent);">
            <svg style="width: 48px; height: 48px; margin-bottom: 16px; opacity: 0.5;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"/>
              <path d="M21 21l-4.35-4.35"/>
            </svg>
            <div>Nenhum resultado encontrado</div>
            <div style="font-size: 13px; margin-top: 8px;">Tente termos diferentes ou navegue pelas seções</div>
          </div>
        `;
      } else {
        results.forEach(result => {
          html += `
            <div class="search-result-item" data-section="${result.section || ''}" data-type="${result.type}">
              <div class="search-result-title">${highlightText(result.title, query)}</div>
              <div class="search-result-snippet">${result.snippet}</div>
            </div>
          `;
        });
      }
      
      searchResults.innerHTML = html;
      showHelpSection('search-results');
      
      // Add click handlers to results
      searchResults.querySelectorAll('.search-result-item').forEach(item => {
        item.addEventListener('click', () => {
          const section = item.dataset.section;
          if (section && section !== 'search-results') {
            // Clear search and navigate to section
            helpSearch.value = '';
            showHelpSection(section);
            helpTitle.textContent = 'Centro de Ajuda';
            
            // Update navigation
            helpNavItems.forEach(nav => nav.classList.remove('active'));
            const targetNav = document.querySelector(`[data-section="${section}"]`);
            if (targetNav) targetNav.classList.add('active');
          }
        });
      });
    }

    function highlightText(text, query) {
      if (!query) return text;
      const regex = new RegExp(`(${escapeRegex(query)})`, 'gi');
      return text.replace(regex, '<span class="search-highlight">$1</span>');
    }

    function escapeRegex(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Keyboard shortcuts for help center
    dlgHelp.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        dlgHelp.close();
      }
      // Removed duplicate Ctrl+/ handler - handled globally
    });

    // Initialize with overview section
    showHelpSection('overview');
    
    // Legacy compatibility - remove old help system references
    document.querySelectorAll('#help .help-tabs [role="tab"]').forEach(tab => {
      // Remove old tab system event listeners if they exist
      const newTab = tab.cloneNode(true);
      tab.parentNode?.replaceChild(newTab, tab);
    });
    
    // Font size controls
    fontSize.addEventListener('input', ()=>{ 
      const size = parseInt(fontSize.value);
      setVar('--editor-font-size', size+'px'); 
      fontSizeDisplay.textContent = size;
      document.getElementById('fontSizeValueDisplay').textContent = size + 'px';
      updateHints(); 
      updateRangeProgress(fontSize, size, 8, 24);
      persistSettings(); 
      renderGutter(true); 
      updateMinimap(true); 
    });
    
    lineHeight.addEventListener('input', ()=>{ 
      const lh = parseFloat(lineHeight.value);
      setVar('--line-height', lh); 
      document.getElementById('lineHeightValueDisplay').textContent = lh.toFixed(2);
      updateHints(); 
      updateRangeProgress(lineHeight, lh, 1.3, 1.9);
      persistSettings(); 
      renderGutter(true); 
      updateMinimap(true); 
    });
    
    padX.addEventListener('input', ()=>{ 
      const pad = parseInt(padX.value);
      setVar('--editor-padding', pad+'px'); 
      document.getElementById('padXValueDisplay').textContent = pad + 'px'; 
      updateHints(); 
      updateRangeProgress(padX, pad, 8, 40);
      persistSettings(); 
    });

    // Toolbar font controls
    btnFontUp.addEventListener('click', increaseFontSize);
    btnFontDown.addEventListener('click', decreaseFontSize);

    function toggleSwitch(sw){ const on = !(sw.getAttribute('aria-checked')==='true'); sw.setAttribute('aria-checked', String(on)); return on; }
    switchWrap.addEventListener('click', ()=> setWrap(toggleSwitch(switchWrap)));
    switchLines.addEventListener('click', ()=> setLineNumbers(toggleSwitch(switchLines)));
    switchMini.addEventListener('click', ()=> setMinimap(toggleSwitch(switchMini)));
    ;['keydown'].forEach(ev=>{
      switchWrap.addEventListener(ev, e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); setWrap(toggleSwitch(switchWrap)); }});
      switchLines.addEventListener(ev, e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); setLineNumbers(toggleSwitch(switchLines)); }});
      switchMini.addEventListener(ev, e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); setMinimap(toggleSwitch(switchMini)); }});
    });

    // ===== Editor events =====
    function scheduleSave(){
      isDirty = true; 
      updateDocTitle(); 
      saveStatus.textContent = 'Salvando…';
      clearTimeout(debounceSave); 
      debounceSave = setTimeout(()=>{ doSave(); }, 1000); 
    }
    editor.addEventListener('input', () => {
      updateWordCount();
      scheduleSave();
      updateMinimap();
      
      // Renderização do gutter sincronizada com o modo wrap
      if (linesVisible) {
        if (wrapOn) {
          // No modo wrap, invalida métricas primeiro e agenda re-renderização
          invalidateWrapMetrics();
          clearTimeout(renderGutter._debounce);
          renderGutter._debounce = setTimeout(() => renderGutter(true), 50);
        } else {
          // No modo sem wrap, renderiza imediatamente
          renderGutter(true);
        }
      }
      
      // Atualiza hover/seleção desenhados no overlay ao escrever
      if (lineUX.hoverLine) showHoverBand(lineUX.hoverLine);
      const selStart = editor.selectionStart, selEnd = editor.selectionEnd;
      if (selStart !== selEnd) {
        const a = getPhysicalLineFromPosition(selStart);
        const b = getPhysicalLineFromPosition(selEnd);
        showSelectionBand(a, b);
      } else {
        clearSelectionBand();
      }
      
      updateLnCol(); // atualiza destaque da linha atual
    });
    editor.addEventListener('scroll', () => {
      updateProgress();
      // Sync highlights overlay scroll
      highlights.scrollTop = editor.scrollTop;
      highlights.scrollLeft = editor.scrollLeft;
      
      // Atualiza hover/seleção desenhados no overlay ao rolar
      if (lineUX.hoverLine) showHoverBand(lineUX.hoverLine);
      const selStart = editor.selectionStart, selEnd = editor.selectionEnd;
      if (selStart !== selEnd) {
        const a = getPhysicalLineFromPosition(selStart);
        const b = getPhysicalLineFromPosition(selEnd);
        showSelectionBand(a, b);
      } else {
        clearSelectionBand();
      }
      
      // SINCRONIZAÇÃO CRÍTICA DO GUTTER
      if (linesVisible) {
        // Debounce para performance, mas manter responsividade
        clearTimeout(renderGutter._scrollDebounce);
        renderGutter._scrollDebounce = setTimeout(() => {
          renderGutter(false);
        }, 8); // 8ms = ~120fps máximo
      }
      
      // Update highlights for new viewport
      if (!findBar.hidden && findMatches.length > 0) {
        highlightViewportHits();
      }
    }, {passive:true});
    editor.addEventListener('keyup', updateLnCol);
    editor.addEventListener('click', updateLnCol);

    // ===== Interatividade no GUTTER =====

    // Mapear clientY -> linha (considerando padding/scroll do editor)
    function clientYToLine(clientY) {
      const edRect = editor.getBoundingClientRect();
      const padTop = parseFloat(getComputedStyle(editor).paddingTop) || 0;
      const yContent = (clientY - edRect.top) - padTop + editor.scrollTop;
      return Math.max(1, Math.min(totalLines(), lineFromY(yContent)));
    }

    // Hover
    gutter.addEventListener('mousemove', (e) => {
      if (!linesVisible) return;
      const line = clientYToLine(e.clientY);
      if (lineUX.hoverLine !== line) {
        lineUX.hoverLine = line;
        showHoverBand(line);
      }
    });
    gutter.addEventListener('mouseleave', () => {
      lineUX.hoverLine = null;
      hideHoverBand();
    });

    // Click / Shift+Click / Alt+Click / duplo clique
    gutter.addEventListener('mousedown', (e) => {
      if (!linesVisible) return;
      e.preventDefault(); // mantém foco no editor
      const line = clientYToLine(e.clientY);

      // Alt => toggle bookmark
      if (e.altKey) {
        if (lineUX.bookmarks.has(line)) lineUX.bookmarks.delete(line);
        else lineUX.bookmarks.add(line);
        renderGutter(true); // reaplica classe .bookmark
        return;
      }

      if (e.shiftKey && lineUX.anchorLine) {
        selectLineRange(lineUX.anchorLine, line);
      } else {
        // define âncora e seleciona somente a linha
        lineUX.anchorLine = line;
        selectLineRange(line, line);
      }

      // Arraste para seleção por linhas
      lineUX.dragging = true;
    });

    window.addEventListener('mousemove', (e) => {
      if (!lineUX.dragging) return;
      const line = clientYToLine(e.clientY);
      if (line !== null) {
        selectLineRange(lineUX.anchorLine || line, line);
      }
    });
    window.addEventListener('mouseup', () => {
      lineUX.dragging = false;
    });

    // Duplo clique -> centraliza
    gutter.addEventListener('dblclick', (e) => {
      if (!linesVisible) return;
      e.preventDefault();
      const line = clientYToLine(e.clientY);
      scrollLineIntoView(line, 'center');
    });

    // Menu contextual simples
    gutter.addEventListener('contextmenu', (e) => {
      if (!linesVisible) return;
      e.preventDefault();
      const line = clientYToLine(e.clientY);
      // Se não estava selecionada, selecione-a
      const { selectionStart, selectionEnd } = editor;
      const selStartLine = getPhysicalLineFromPosition(selectionStart);
      const selEndLine = getPhysicalLineFromPosition(selectionEnd);
      if (!(line >= selStartLine && line <= selEndLine)) {
        selectLineRange(line, line);
      }
      // Ações rápidas (mínimas); você pode trocar por seu popover bonito
      const act = prompt('Ação: (c)opiar, (d)uplicar, (x)apagar, (m)over↑, (n)over↓, (b)ookmark');
      switch ((act || '').toLowerCase()) {
        case 'c': document.execCommand('copy'); break; // simples (funciona no textarea)
        case 'd': duplicateLineOrSelection(); break;
        case 'x': document.execCommand('insertText', false, ''); break;
        case 'm': moveLineOrSelection('up'); break;
        case 'n': moveLineOrSelection('down'); break;
        case 'b': 
          const base = selStartLine;
          for (let L = selStartLine; L <= selEndLine; L++) lineUX.bookmarks.add(L);
          renderGutter(true);
          break;
      }
    });

    // ===== Navegação por teclado no gutter =====
    gutter.addEventListener('keydown', (e) => {
      if (!linesVisible) return;
      
      const currentLine = getPhysicalLineFromPosition(editor.selectionStart);
      let targetLine = currentLine;
      
      switch(e.key) {
        case 'ArrowUp':
          e.preventDefault();
          targetLine = Math.max(1, currentLine - 1);
          break;
        case 'ArrowDown':
          e.preventDefault();
          targetLine = Math.min(totalLines(), currentLine + 1);
          break;
        case 'PageUp':
          e.preventDefault();
          const pageUp = Math.floor(editor.clientHeight / parseFloat(getComputedStyle(editor).lineHeight));
          targetLine = Math.max(1, currentLine - pageUp);
          break;
        case 'PageDown':
          e.preventDefault();
          const pageDown = Math.floor(editor.clientHeight / parseFloat(getComputedStyle(editor).lineHeight));
          targetLine = Math.min(totalLines(), currentLine + pageDown);
          break;
        case 'Home':
          e.preventDefault();
          targetLine = 1;
          break;
        case 'End':
          e.preventDefault();
          targetLine = totalLines();
          break;
        case 'Enter':
          e.preventDefault();
          selectLineRange(currentLine, currentLine);
          return;
        case ' ':
          e.preventDefault();
          // Toggle bookmark na linha atual
          if (lineUX.bookmarks.has(currentLine)) {
            lineUX.bookmarks.delete(currentLine);
          } else {
            lineUX.bookmarks.add(currentLine);
          }
          renderGutter(true);
          doSave(true);
          return;
        default:
          return;
      }
      
      // Ir para a linha alvo
      scrollLineIntoView(targetLine, 'center');
      selectLineRange(targetLine, targetLine);
    });

    // Gutter scroll management - comportamento condicional baseado no modo wrap
    gutter.addEventListener('wheel', (e) => {
      if (!wrapOn && linesVisible) {
        // Só permite scroll do gutter no modo sem wrap
        e.preventDefault();
        editor.scrollTop += e.deltaY;
        updateProgress();
      }
      // No modo wrap, o evento passa através (comportamento padrão)
    }, {passive: false});

    // Tab insere 	
    editor.addEventListener('keydown', (e)=>{
      // Line editing shortcuts
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'd') {
        e.preventDefault();
        duplicateLineOrSelection();
      }
      if (e.altKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
        e.preventDefault();
        moveLineOrSelection(e.key === 'ArrowUp' ? 'up' : 'down');
      }
      
      // Bookmark toggle (F3 ou Cmd/Ctrl+B)
      if (e.key === 'F3' || ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'b')) {
        e.preventDefault();
        const currentLine = getPhysicalLineFromPosition(editor.selectionStart);
        if (lineUX.bookmarks.has(currentLine)) {
          lineUX.bookmarks.delete(currentLine);
        } else {
          lineUX.bookmarks.add(currentLine);
        }
        renderGutter(true);
        doSave(true); // força salvamento dos bookmarks
      }

      if(e.key==='Tab'){
        e.preventDefault(); const start = editor.selectionStart; const end = editor.selectionEnd; const v = editor.value; editor.value = v.slice(0,start) + '	' + v.slice(end); editor.selectionStart = editor.selectionEnd = start + 1; editor.dispatchEvent(new Event('input')); updateLnCol();
      }
      if(e.altKey && e.key.toLowerCase()==='z'){ e.preventDefault(); setWrap(!wrapOn); }
      
      if((e.metaKey||e.ctrlKey) && e.key==='o'){ e.preventDefault(); buildNotesList(); dlgNotes.showModal(); }

      if((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==='n'){ e.preventDefault(); const id = createNote(''); openNote(id); }
      if((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==='s'){ e.preventDefault(); btnSaveFile.click(); }
      if((e.metaKey||e.ctrlKey) && e.key===','){ e.preventDefault(); dlgSettings.open?dlgSettings.close():dlgSettings.showModal(); }
      if((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==='p'){ e.preventDefault(); window.print(); }
      if((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==='m'){ e.preventDefault(); setMinimap(!minimapOn); }
      if((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==='l'){ e.preventDefault(); setLineNumbers(!linesVisible); }
      
      // Font size controls
      if((e.metaKey||e.ctrlKey) && (e.key==='=' || e.key==='+')){ e.preventDefault(); increaseFontSize(); }
      if((e.metaKey||e.ctrlKey) && e.key==='-'){ e.preventDefault(); decreaseFontSize(); }
      if((e.metaKey||e.ctrlKey) && e.key==='0'){ e.preventDefault(); setFontSize(10); } // Reset to default
    });

    // ===== Cross-tab sync & Unload =====
    window.addEventListener('beforeunload', (e) => {
      if (isDirty) {
        doSave(); // Garante que o último estado seja salvo antes de sair
        e.preventDefault();
        e.returnValue = 'Você tem alterações não salvas. Deseja sair?';
      }
    });
    window.addEventListener('storage', (e)=>{
      if (e.key === INDEX_KEY || (e.key && e.key.startsWith('note:'))) {
        if (dlgNotes.open) buildNotesList();
        if (currentId && e.key === NOTE_KEY(currentId) && document.activeElement !== editor) {
          const item = loadNote(currentId);
          if (item && editor.value !== item.text) { editor.value = item.text || ''; updateAllMeta(); isDirty = false; updateDocTitle(); }
        }
      }
      if (e.key === SETTINGS_KEY) restoreSettings();
    });

    // ===== Init =====
    (function init(){
      restoreSettings();
      // Inicializar progresso visual dos ranges
      updateRangeProgress(fontSize, parseInt(fontSize.value), 8, 24);
      updateRangeProgress(lineHeight, parseFloat(lineHeight.value), 1.3, 1.9);
      updateRangeProgress(padX, parseInt(padX.value), 8, 40);
      
      // ResizeObserver para invalidar medições no modo wrap
      const ro = new ResizeObserver(() => {
        invalidateWrapMetrics();
        if (linesVisible) renderGutter(true);
        updateMinimap(true);
      });
      ro.observe(editor);
      
      // carregar nota atual ou criar
      const idx = loadIndex(); let id = getCurrentId(); if(!id){ id = idx[0]?.id; } if(!id){ id = createNote(''); }
      openNote(id);

      setInterval(updateLastSavedTime, 5000);
      
      // garantir sync do more-menu no init
      syncMenuChecks?.();
    })();

    // ===== Title Editing =====
    function startTitleEditOn(targetEl) {
      // targetEl: noteTitleEl (footer) OU noteTitleChip (appbar)
      if (!targetEl || targetEl.querySelector('input')) return;

      // título atual
      const idx = loadIndex();
      const meta = idx.find(n => n.id === currentId);
      if (!meta) return;

      const currentTitle = meta.title;
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentTitle;
      input.className = 'title-editor';
      input.setAttribute('aria-label','Título da nota');

      if (targetEl === noteTitleChip) {
        // limpar chip e embutir input
        targetEl.innerHTML = '';
        targetEl.appendChild(input);
      } else {
        // footer
        targetEl.innerHTML = '';
        targetEl.appendChild(input);
      }

      input.focus();
      input.select();

      const finish = (confirm) => {
        input.removeEventListener('blur', onBlur);
        input.removeEventListener('keydown', onKeydown);
        if (confirm && input.value.trim()) {
          finishTitleEdit(input.value.trim());
        } else {
          // restaura visual se cancelar
          if (noteTitleEl) noteTitleEl.textContent = meta.title;
          if (noteTitleChip && noteTitleChipText) {
            noteTitleChip.innerHTML = `
              <svg class="ticon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 20h4l10-10a2.828 2.828 0 0 0-4-4L4 16v4z"></path><path d="M13.5 6.5l4 4"/></svg>
              <span id="noteTitleChipText">${meta.title}</span>`;
          }
        }
      };

      const onBlur = () => finish(true);
      const onKeydown = (e) => {
        if (e.key === 'Enter') { e.preventDefault(); finish(true); }
        else if (e.key === 'Escape') { e.preventDefault(); finish(false); }
      };

      input.addEventListener('blur', onBlur);
      input.addEventListener('keydown', onKeydown);
    }

    function startTitleEdit() { startTitleEditOn(noteTitleEl); } // compat
    noteTitleEl.addEventListener('dblclick', startTitleEdit);
    noteTitleChip?.addEventListener('dblclick', () => startTitleEditOn(noteTitleChip));

    function finishTitleEdit(newTitle) {
      const idx = loadIndex();
      const meta = idx.find(n => n.id === currentId);
      if (!meta) {
        if (noteTitleEl) noteTitleEl.textContent = '—';
        if (noteTitleChipText) noteTitleChipText.textContent = '—';
        return;
      }

      if (newTitle) {
        meta.title = newTitle;
        meta.updatedAt = nowISO();

        // atualizar index (move pro topo)
        let index = loadIndex();
        let noteIndex = index.findIndex(n => n.id === currentId);
        if (noteIndex > -1) {
          index[noteIndex] = meta;
          index.splice(noteIndex, 1);
          index.unshift(meta);
          saveIndex(index);
        }

        if (noteTitleEl) noteTitleEl.textContent = meta.title;
        if (noteTitleChip) {
          noteTitleChip.innerHTML = `
            <svg class="ticon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 20h4l10-10a2.828 2.828 0 0 0-4-4L4 16v4z"></path><path d="M13.5 6.5l4 4"/></svg>
            <span id="noteTitleChipText">${meta.title}</span>`;
        }

        updateDocTitle();
        if (dlgNotes.open) buildNotesList();
        lastSaveTime = new Date();
        updateLastSavedTime();
      } else {
        // Restore original title on cancel
        if (noteTitleEl) noteTitleEl.textContent = meta.title;
        if (noteTitleChip) {
          noteTitleChip.innerHTML = `
            <svg class="ticon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 20h4l10-10a2.828 2.828 0 0 0-4-4L4 16v4z"></path><path d="M13.5 6.5l4 4"/></svg>
            <span id="noteTitleChipText">${meta.title}</span>`;
        }
      }
    }

    noteTitleEl.addEventListener('dblclick', startTitleEdit);
    window.addEventListener('keydown', e => {
        if (e.key === 'F2' && document.activeElement.tagName.toLowerCase() !== 'textarea') {
            e.preventDefault();
            startTitleEdit();
        }
    });

    // ===== Find & Replace Logic - Enhanced =====
    let findMatches = [];
    let findIdx = 0;
    let replaceMode = false;

    function openFindBar(withReplace = false) {
      findBar.hidden = false;
      
      // Set replace mode
      replaceMode = withReplace;
      replaceRow.hidden = !replaceMode;
      btnToggleReplace.setAttribute('aria-pressed', String(replaceMode));
      
      // Pre-fill with selection if any
      const selection = editor.value.substring(editor.selectionStart, editor.selectionEnd);
      if (selection && selection.indexOf('\n') === -1) { // Single line selection only
        findInput.value = selection;
      }
      
      findInput.focus();
      findInput.select();
      computeFind();
      
      // Update global search state
      const gs = document.getElementById('globalSearch');
      if (gs) {
        gs.setAttribute('aria-expanded','true');
        gs.value = findInput.value; // Sync values
      }
    }

    function closeFindBar() {
      findBar.hidden = true;
      replaceMode = false;
      const gs = document.getElementById('globalSearch');
      if (gs) {
        gs.setAttribute('aria-expanded','false');
        gs.value = ''; // Clear global search
      }
      editor.focus();
      clearFindDecorations();
    }

    function toggleReplaceMode() {
      replaceMode = !replaceMode;
      replaceRow.hidden = !replaceMode;
      btnToggleReplace.setAttribute('aria-pressed', String(replaceMode));
      
      if (replaceMode) {
        replaceInput.focus();
      } else {
        findInput.focus();
      }
    }

    // Option button handlers - updated for new structure
    function toggleOption(optionName, button) {
      findOptions[optionName] = !findOptions[optionName];
      button.setAttribute('aria-pressed', String(findOptions[optionName]));
      computeFind(); // Recompute with new options
    }

    function computeFind() {
      clearTimeout(computeFind._t);
      computeFind._t = setTimeout(() => {
        const q = findInput.value;
        if (!q) {
          findMatches = [];
          findCount.textContent = '0/0';
          clearFindDecorations();
          return;
        }
        
        try {
          const flags = findOptions.case ? 'g' : 'gi';
          const src = findOptions.regex ? q : q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const re = new RegExp(src, findOptions.multiline ? flags + 'm' : flags);
          const text = editor.value;
          findMatches = [];
          let m;
          
          // Limite para evitar travamento em textos muito grandes
          const maxMatches = 10000;
          while ((m = re.exec(text)) && findMatches.length < maxMatches) {
            findMatches.push({ start: m.index, end: m.index + m[0].length });
            if (m.index === re.lastIndex) re.lastIndex++; // avoid zero-length loops
          }
          
          if (findMatches.length >= maxMatches) {
            findCount.textContent = `${maxMatches}+ resultados`;
          } else {
            findIdx = Math.min(findIdx, findMatches.length - 1);
            updateFindCount();
          }
          
          highlightViewportHits();
          
          // Auto-scroll to first match if we have results
          if (findMatches.length > 0 && findIdx < 0) {
            findIdx = 0;
            goToHit(0);
          }
          
        } catch (e) {
          // Invalid regex - show error in count
          if (findOptions.regex) {
            findCount.textContent = 'Regex inválida';
            findMatches = [];
            clearFindDecorations();
          }
        }
      }, 150);
    }

    function updateFindCount() {
      if (findMatches.length === 0) {
        findCount.textContent = '0/0';
      } else {
        const current = Math.max(0, findIdx) + 1;
        findCount.textContent = `${current}/${findMatches.length}`;
      }
    }

    // Smart positioning for find bar to avoid covering current match
    function repositionFindBar() {
      if (findBar.hidden || findMatches.length === 0) return;
      
      const currentMatch = findMatches[findIdx];
      if (!currentMatch) return;
      
      // Calculate line position of current match
      const textBefore = editor.value.substring(0, currentMatch.start);
      const matchLine = textBefore.split('\n').length;
      const lineHeight = parseFloat(getComputedStyle(editor).lineHeight);
      const matchY = (matchLine - 1) * lineHeight - editor.scrollTop;
      
      // If match is in top area where findbar might cover it, move findbar down
      if (matchY < 120 && window.innerWidth > 640) {
        findBar.style.top = '120px';
      } else {
        findBar.style.top = '12px';
      }
    }

    // Integra o campo de busca global com a Find Bar - enhanced
    const globalSearch = document.getElementById('globalSearch');
    if (globalSearch) {
      globalSearch.addEventListener('focus', () => {
        openFindBar(false);
      });
      
      globalSearch.addEventListener('input', () => {
        if (findBar.hidden) openFindBar(false);
        findInput.value = globalSearch.value || '';
        computeFind();
      });
      
      // Clear global search when find bar closes
      globalSearch.addEventListener('blur', () => {
        if (findBar.hidden) {
          globalSearch.value = '';
        }
      });
    }

    function goToHit(i) {
      if (!findMatches.length) return;
      findIdx = (i + findMatches.length) % findMatches.length;
      const hit = findMatches[findIdx];
      editor.selectionStart = hit.start;
      editor.selectionEnd = hit.end;
      
      // Better scrolling - position match in center of viewport
      const textBefore = editor.value.substring(0, hit.start);
      const linesBefore = textBefore.split('\n').length;
      const lineHeight = parseFloat(getComputedStyle(editor).lineHeight);
      const editorHeight = editor.clientHeight;
      const targetScrollTop = Math.max(0, (linesBefore - Math.floor(editorHeight / lineHeight / 2)) * lineHeight);
      editor.scrollTop = targetScrollTop;
      
      updateFindCount();
      highlightViewportHits();
      repositionFindBar(); // Smart repositioning
    }

    // Replace functions - enhanced with better feedback
    function replaceOne() {
      if (!findMatches.length || findIdx < 0 || findIdx >= findMatches.length) {
        showToast('Nenhum resultado para substituir', 'info');
        return;
      }
      
      const hit = findMatches[findIdx];
      if (!hit) return;
      
      const repl = replaceInput.value;
      const v = editor.value;
      editor.value = v.slice(0, hit.start) + repl + v.slice(hit.end);
      editor.selectionStart = hit.start;
      editor.selectionEnd = hit.start + repl.length;
      editor.dispatchEvent(new Event('input'));
      scheduleSave();
      updateAllMeta();
      
      // Recompute and try to maintain position
      const oldIdx = findIdx;
      computeFind();
      
      // Advance to next match if available
      if (findMatches.length > 0) {
        findIdx = Math.min(oldIdx, findMatches.length - 1);
        if (findIdx >= 0) goToHit(findIdx);
      }
      
      showToast('Texto substituído', 'success');
    }

    function replaceAll() {
      if (!findMatches.length) {
        showToast('Nenhum resultado para substituir', 'info');
        return;
      }
      
      const repl = replaceInput.value;
      const q = findInput.value;
      const originalCount = findMatches.length;
      
      try {
        const flags = findOptions.case ? 'g' : 'gi';
        const src = findOptions.regex ? q : q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const re = new RegExp(src, findOptions.multiline ? flags + 'm' : flags);
        
        const oldValue = editor.value;
        editor.value = oldValue.replace(re, repl);
        
        if (editor.value !== oldValue) {
          editor.dispatchEvent(new Event('input'));
          scheduleSave();
          updateAllMeta();
          computeFind();
          showToast(`${originalCount} substituições realizadas`, 'success');
        } else {
          showToast('Nenhuma substituição realizada', 'info');
        }
      } catch (e) {
        console.error('Replace error:', e);
        showToast('Erro na substituição', 'error');
      }
    }

    // Clear replacement highlights (placeholder function)
    function clearReplacementHighlights() {
      // This function can be expanded later if needed
      // For now, it's just a placeholder to prevent errors
    }

    // Initialize find bar event listeners - updated for new structure
    function initializeFindBarEvents() {
        // Button click handlers
        btnFindNext.onclick = () => goToHit(findIdx + 1);
        btnFindPrev.onclick = () => goToHit(findIdx - 1);
        btnFindClose.onclick = closeFindBar;
        btnDoReplace.onclick = replaceOne;
        btnDoReplaceAll.onclick = replaceAll;
        btnToggleReplace.onclick = toggleReplaceMode;
        
        // Option button toggles - updated class names
        optRegex.onclick = () => toggleOption('regex', optRegex);
        optCase.onclick = () => toggleOption('case', optCase);
        optMultiline.onclick = () => toggleOption('multiline', optMultiline);
        
        // Input event listeners
        findInput.addEventListener('input', () => {
          computeFind();
          // Sync with global search
          const gs = document.getElementById('globalSearch');
          if (gs) gs.value = findInput.value;
        });
        
        replaceInput.addEventListener('input', () => {
            clearReplacementHighlights();
        });
        
        // Enhanced keyboard shortcuts for find bar
        findInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.shiftKey) {
                    goToHit(findIdx - 1);
                } else {
                    goToHit(findIdx + 1);
                }
            } else if (e.key === 'Escape') {
                closeFindBar();
            } else if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'h') {
                e.preventDefault();
                if (!replaceMode) toggleReplaceMode();
            }
        });
        
        replaceInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.ctrlKey || e.metaKey) {
                    replaceAll();
                } else {
                    replaceOne();
                }
            } else if (e.key === 'Escape') {
                closeFindBar();
            }
        });
    }
    
    // Call initialization
    initializeFindBarEvents();

    function highlightViewportHits() {
      if (!findMatches.length) { 
        highlights.innerHTML = ''; 
        return; 
      }

      const scrollTop = editor.scrollTop;
      const lineH = parseFloat(getComputedStyle(editor).lineHeight);
      const lines = editor.value.split('\n');

      // Calculate viewport range with optimized buffer
      const linesPerView = Math.ceil(editor.clientHeight / lineH);
      const bufferLines = Math.min(50, Math.max(10, Math.floor(linesPerView * 0.5))); // Adaptive buffer
      const currentTopLine = Math.max(0, Math.floor(scrollTop / lineH) - bufferLines);
      const endLine = Math.min(lines.length, currentTopLine + linesPerView + (bufferLines * 2));

      const startChar = lines.slice(0, currentTopLine).join('\n').length + (currentTopLine ? 1 : 0);
      const endChar = lines.slice(0, endLine).join('\n').length;

      // Filter matches that are actually visible
      const visibleMatches = findMatches.filter(m => 
        m.start < endChar && m.end > startChar
      );

      // Early exit if no visible matches
      if (visibleMatches.length === 0) {
        const padTopPx = currentTopLine * lineH;
        const padBottomPx = Math.max(0, (lines.length - endLine) * lineH);
        highlights.innerHTML = `<div style="height:${padTopPx}px"></div><div style="height:${padBottomPx}px"></div>`;
        return;
      }

      const visible = editor.value.slice(startChar, endChar);
      let html = '';
      let last = 0;
      
      // Process visible matches efficiently
      visibleMatches.forEach(m => {
        const s = Math.max(0, m.start - startChar);
        const e = Math.min(visible.length, m.end - startChar);
        if (s > last) html += escapeHtml(visible.slice(last, s));
        const isCurrent = (m === findMatches[findIdx]);
        html += `<mark class="${isCurrent ? 'find-hit current' : 'find-hit'}">${escapeHtml(visible.slice(s, e))}</mark>`;
        last = e;
      });
      html += escapeHtml(visible.slice(last));

      const padTopPx = currentTopLine * lineH;
      const padBottomPx = Math.max(0, (lines.length - endLine) * lineH);
      highlights.innerHTML = `<div style="height:${padTopPx}px"></div>${html}<div style="height:${padBottomPx}px"></div>`;
    }

    function clearFindDecorations() {
      highlights.innerHTML = '';
    }

    function escapeHtml(str) {
      return str.replace(/[&<>"']/g, (match) => {
        switch (match) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '"': return '&quot;';
          case "'": return '&#39;';
          default: return match;
        }
      });
    }

    // Enhanced keyboard handling
    findInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (e.shiftKey) {
          goToHit(findIdx - 1);
        } else {
          goToHit(findIdx + 1);
        }
      }
      if (e.key === 'Escape') {
        e.preventDefault();
        closeFindBar();
      }
    });

    replaceInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (e.ctrlKey || e.metaKey) {
          btnDoReplaceAll.click();
        } else {
          btnDoReplace.click();
        }
      }
      if (e.key === 'Escape') {
        e.preventDefault();
        closeFindBar();
      }
    });

    // Global keyboard shortcuts - enhanced for new findbar
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        openFindBar(false);
      }
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'h') {
        e.preventDefault();
        openFindBar(true); // Open directly in replace mode
      }
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'g') {
        e.preventDefault();
        openGoToLine();
      }
      if ((e.metaKey || e.ctrlKey) && e.key === '/') {
        e.preventDefault();
        if (dlgHelp.open) {
          dlgHelp.close();
        } else {
          dlgHelp.showModal(); 
          focusTrap(dlgHelp);
          // Ensure shortcuts are rendered when help opens via keyboard
          setTimeout(renderShortcuts, 100);
        }
      }
      
      // Markdown Viewer - Cmd/Ctrl + Shift + P
      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'p') {
        e.preventDefault();
        const content = editor.value;
        if (content.trim()) {
          const meta = getCurrentNoteMeta();
          const title = meta ? `${meta.title}.md` : 'Nota.md';
          if (typeof openMarkdownViewer === 'function') {
            openMarkdownViewer({ 
              markdown: content, 
              title: title 
            });
          }
        } else {
          showToast('Nenhum conteúdo para visualizar', 'info');
        }
      }
      
      // F3 navigation for search results (global)
      if (e.key === 'F3' && findBar.hidden === false) {
        e.preventDefault();
        if (e.shiftKey) {
          goToHit(findIdx - 1);
        } else {
          goToHit(findIdx + 1);
        }
      }
      
      if (e.key === 'Escape' && !findBar.hidden) {
        e.preventDefault();
        closeFindBar();
      }
      
      // Enhanced navigation when find bar is open
      if (!findBar.hidden && findMatches.length > 0) {
        if (e.key === 'F3' || (e.key === 'Enter' && document.activeElement !== findInput && document.activeElement !== replaceInput)) {
          e.preventDefault();
          if (e.shiftKey) {
            goToHit(findIdx - 1);
          } else {
            goToHit(findIdx + 1);
          }
        }
      }
    });

    // ===== Go To Line =====
    function openGoToLine() {
        goToLine.hidden = false;
        goToLineInput.focus();
        goToLineInput.select();
    }

    function closeGoToLine() {
        goToLine.hidden = true;
        goToLineInput.value = '';
        editor.focus();
    }
    function executeGoToLine() {
        const lineNum = parseInt(goToLineInput.value || '1', 10);
        const totalLinesCount = totalLines();
        
        if (isNaN(lineNum) || lineNum < 1 || lineNum > totalLinesCount) {
          // Animação de shake para número inválido
          goToLine.classList.add('shake');
          setTimeout(() => goToLine.classList.remove('shake'), 500);
          goToLineInput.select();
          return;
        }
        
        scrollLineIntoView(lineNum, 'center'); // Usar lineNum diretamente (1-based)
        selectLineRange(lineNum, lineNum); // Usar lineNum diretamente (1-based)
        goToLine.hidden = true;
        goToLineInput.value = '';
    }

    // Event listeners para os botões
    btnGoToLineExecute.addEventListener('click', executeGoToLine);
    btnGoToLineClose.addEventListener('click', closeGoToLine);
    
    goToLineInput.addEventListener('blur', closeGoToLine);

    // ===== Footer clicável + "Ir para linha" =====
    // Footer: clicar em Ln/Col abre "Ir para linha"
    lnCol.style.cursor = 'pointer';
    lnCol.title = 'Ir para linha (⌘/Ctrl + G)';
    lnCol.addEventListener('click', () => {
      goToLine.hidden = false;
      goToLineInput.value = '';
      goToLineInput.focus();
    });

    // Atalho global (Cmd/Ctrl+G) - já existe mas vou melhorar
    // Confirmar "Ir para..." - melhorar o goToLineInput
    goToLineInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault(); // Impede que o Enter se propague para o editor
        executeGoToLine();
      } else if (e.key === 'Escape') {
        e.preventDefault(); // Impede que o Escape se propague
        closeGoToLine();
      }
    });

    // ===== Selection Stats =====
    let selectionTimeout = null;
    function updateSelectionStats() {
        clearTimeout(selectionTimeout);
        selectionTimeout = setTimeout(() => {
            const selection = editor.value.substring(editor.selectionStart, editor.selectionEnd);
            if (selection) {
                const charCount = selection.length;
                const wordCount = selection.trim().split(/\s+/).filter(Boolean).length;
                selectionStats.textContent = `Sel: ${charCount} chars • ${wordCount} palavras`;
                selectionStats.hidden = false;
                selectionSep.hidden = false;
                
                // Mostrar banda de seleção se múltiplas linhas
                const selStart = editor.selectionStart, selEnd = editor.selectionEnd;
                if (selStart !== selEnd) {
                  const a = getPhysicalLineFromPosition(selStart);
                  const b = getPhysicalLineFromPosition(selEnd);
                  showSelectionBand(a, b);
                } else {
                  clearSelectionBand();
                }
            } else {
                selectionStats.hidden = true;
                selectionSep.hidden = true;
                clearSelectionBand();
            }
        }, 50);
    }


    document.addEventListener('selectionchange', updateSelectionStats);
    editor.addEventListener('keyup', updateSelectionStats);
    editor.addEventListener('mouseup', updateSelectionStats);


    // ===== Theme Switcher =====

    function applyTheme(theme) {
        if (theme === 'auto') {
            document.documentElement.dataset.theme = lightScheme.matches ? 'light' : 'dark';
        } else {
            document.documentElement.dataset.theme = theme;
        }
    }

    function setTheme(theme) {
        currentTheme = theme;
        
        // Update button styles - only if themeSwitcher is available
        const themeSwitcher = document.getElementById('themeSwitcher');
        if (themeSwitcher) {
            themeSwitcher.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('btn-active', btn.dataset.themeValue === theme);
                btn.setAttribute('aria-pressed', btn.dataset.themeValue === theme);
            });
        }
        
        applyTheme(theme);
        persistSettings();
    }

    // Initialize theme switcher event listener
    const themeSwitcher = document.getElementById('themeSwitcher');
    if (themeSwitcher) {
        themeSwitcher.addEventListener('click', e => {
            const target = e.target.closest('button');
            if (target && target.dataset.themeValue) {
                setTheme(target.dataset.themeValue);
            }
        });
    }

    lightScheme.addEventListener('change', () => {
        if (currentTheme === 'auto') {
            applyTheme('auto');
        }
    });

    // ===== Clean and Stable Drag & Drop System =====
    let isDraggingFiles = false;
    let dragLeaveTimeout = null;

    // Check if drag event contains files
    function hasFiles(e) {
        if (!e.dataTransfer) return false;
        
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) return true;
        if (e.dataTransfer.items) {
            for (let i = 0; i < e.dataTransfer.items.length; i++) {
                if (e.dataTransfer.items[i].kind === 'file') return true;
            }
        }
        
        if (e.dataTransfer.types) {
            return e.dataTransfer.types.includes('Files');
        }
        
        return false;
    }

    function showDropzone() {
        if (!isDraggingFiles) {
            isDraggingFiles = true;
            dropzone.removeAttribute('hidden');
            // Use a small delay to ensure smooth animation
            requestAnimationFrame(() => {
                dropzone.classList.add('show');
            });
        }
        clearTimeout(dragLeaveTimeout);
    }

    function hideDropzone() {
        clearTimeout(dragLeaveTimeout);
        dragLeaveTimeout = setTimeout(() => {
            if (isDraggingFiles) {
                isDraggingFiles = false;
                dropzone.classList.remove('show');
                // Hide after animation completes
                setTimeout(() => {
                    dropzone.setAttribute('hidden', '');
                }, 250);
            }
        }, 100);
    }

    // Simplified drag handlers
    document.addEventListener('dragenter', (e) => {
        if (hasFiles(e)) {
            e.preventDefault();
            showDropzone();
        }
    });

    document.addEventListener('dragleave', (e) => {
        // Only hide if we're leaving the window
        if (!e.relatedTarget || e.relatedTarget.nodeName === 'HTML') {
            hideDropzone();
        }
    });

    document.addEventListener('dragover', (e) => {
        if (isDraggingFiles) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }
    });

    document.addEventListener('drop', (e) => {
        e.preventDefault();
        
        // Immediately hide dropzone
        isDraggingFiles = false;
        clearTimeout(dragLeaveTimeout);
        dropzone.classList.remove('show');
        setTimeout(() => {
            dropzone.setAttribute('hidden', '');
        }, 250);

        // Process files
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            const file = e.dataTransfer.files[0];
            
            // Validate file type
            const validExtensions = ['.txt', '.md', '.markdown'];
            const validMimeTypes = ['text/plain', 'text/markdown', 'text/x-markdown'];
            
            const fileName = file.name.toLowerCase();
            const fileType = file.type.toLowerCase();
            
            const isValidExtension = validExtensions.some(ext => fileName.endsWith(ext));
            const isValidMimeType = validMimeTypes.includes(fileType);
            
            if (isValidExtension || isValidMimeType || fileType.startsWith('text/')) {
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    try {
                        const newNoteId = createNote(event.target.result);
                        openNote(newNoteId);
                        
                        // Update note title
                        let idx = loadIndex();
                        let meta = idx.find(n => n.id === newNoteId);
                        if (meta) {
                            const nameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
                            meta.title = nameWithoutExt || file.name;
                            meta.updatedAt = nowISO();
                            saveIndex(idx);
                            noteTitleEl.textContent = meta.title;
                            updateDocTitle();
                        }
                        
                        showToast(`Arquivo "${file.name}" carregado`, 'success');
                        
                    } catch (error) {
                        console.error('Error reading file:', error);
                        showToast('Erro ao ler o arquivo', 'error');
                    }
                };
                
                reader.onerror = () => {
                    showToast('Erro ao ler o arquivo', 'error');
                };
                
                reader.readAsText(file);
                
            } else {
                showToast('Tipo de arquivo não suportado', 'error');
            }
        }
    });

    // Prevent default behaviors and ensure clean state
    window.addEventListener('dragend', () => {
        hideDropzone();
    });

    window.addEventListener('focus', () => {
        if (isDraggingFiles) {
            hideDropzone();
        }
    });

    // Enhanced Toast notification system (Liquid Glass Kit) — corrigido
    function showToast(message, type = 'info', timeout = 4000){
      // remove toasts existentes
      document.querySelectorAll('.glass-toast').forEach(t => t.remove());
      const toast = document.createElement('div');
      toast.className = `glass-toast ${type}`;
      toast.setAttribute('role','status');
      toast.setAttribute('aria-live','polite');
      toast.textContent = message;
      document.body.appendChild(toast);
      // animação de entrada
      requestAnimationFrame(() => toast.classList.add('show'));
      // saída automática
      const hide = () => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 420);
      };
      const id = setTimeout(hide, timeout);
      // saída manual
      toast.addEventListener('click', () => {
        clearTimeout(id);
        hide();
      });
      return toast;
    }

    // Prevent default drag behaviors on the document
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.addEventListener(eventName, e => {
            // Only prevent default for non-editor elements to allow text drag/drop in editor
            if (e.target !== editor && !editor.contains(e.target)) {
                e.preventDefault();
                e.stopPropagation();
            }
        });
    });

    // Safety net: se o dropzone ficou aberto, fecha ao focar a janela
    window.addEventListener('focus', () => {
      if (isDraggingFiles) {
        isDraggingFiles = false;
        dropzone.classList.remove('show');
        dropzone.setAttribute('hidden', '');
      }
    });
      // ===== Correção: Fechar modais ao clicar no X ou fora =====
      function setupDialogClose(dialogId) {
        const dlg = document.getElementById(dialogId);
        if (!dlg) return;
        
        // Botões X (todos os .sheet-close dentro do modal)
        dlg.querySelectorAll('.sheet-close').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dlg.close();
          });
        });
        
        // Clique fora do modal
        dlg.addEventListener('click', (e) => {
          if (e.target === dlg) {
            dlg.close();
          }
        });
        
        // Tecla ESC
        dlg.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            e.preventDefault();
            dlg.close();
          }
        });
      }

      setupDialogClose('settings');
      setupDialogClose('help');
      setupDialogClose('notes');
      setupDialogClose('mdv');

      // CORREÇÃO FINAL: Garantir que todos os modais estejam fechados na inicialização
      ['settings', 'help', 'notes', 'mdv'].forEach(id => {
        const modal = document.getElementById(id);
        if (modal && modal.open) {
          modal.close();
        }
      });

      // ===== VISUALIZADOR DE MARKDOWN (MDV) - LIQUID GLASS =====
      
      // Aguardar DOM carregar para garantir que os elementos existam
      document.addEventListener('DOMContentLoaded', function initMDV() {
        // Se já foi inicializado, não fazer novamente
        if (window.openMarkdownViewer) return;
        
        /* ===== Helpers para carregar sob demanda ===== */
        function loadScriptOnce(url, globalProp){
          return new Promise((resolve, reject)=>{
            if (globalProp && window[globalProp]) return resolve(window[globalProp]);
            const s = document.createElement('script'); s.src = url; s.async = true; s.crossOrigin='anonymous';
            s.onload = ()=> resolve(window[globalProp] || true); s.onerror = reject; document.head.appendChild(s);
          });
        }
        function loadCssOnce(url, id){
          if (id && document.getElementById(id)) return;
          const l = document.createElement('link'); l.rel='stylesheet'; l.href=url; l.crossOrigin='anonymous'; if (id) l.id=id;
          document.head.appendChild(l);
        }

        /* ===== Config base (pegamos defaults e deixamos ler do APP_SETTINGS se existir) ===== */
        const DEFAULT_MDV_SETTINGS = {
          scale: 1.0,
          lineHeight: 1.6,
          columnWidthCh: 72,
          codeLineNumbers: false,
          highlightTheme: 'auto', // 'auto' | 'light' | 'dark'
          enableMermaid: true,
          enableMath: true,
        };
        function getMDVSettings(){
          const root = (window.APP_SETTINGS && window.APP_SETTINGS.markdownViewer) || {};
          return { ...DEFAULT_MDV_SETTINGS, ...root };
        }
        function applyHLJSTheme(theme){
          const link = document.getElementById('hljs-theme');
          if (!link) return;
          const isDark = theme === 'dark' || (theme === 'auto' && matchMedia('(prefers-color-scheme: dark)').matches);
          link.href = isDark
            ? 'https://cdn.jsdelivr.net/npm/highlight.js@11/styles/github-dark.min.css'
            : 'https://cdn.jsdelivr.net/npm/highlight.js@11/styles/github.min.css';
        }

        /* ===== Instâncias ===== */
        const mdvDlg = document.getElementById('mdv');
        const mdvArticle = document.getElementById('mdvArticle');
        const mdvContent = document.getElementById('mdvContent');
        const mdvTitle = document.getElementById('mdvTitle');
        const mdvClose = document.getElementById('mdvClose');

        // Log para debug
        console.log('MDV Elements:', {
          mdvDlg: !!mdvDlg,
          mdvArticle: !!mdvArticle,
          mdvContent: !!mdvContent,
          mdvTitle: !!mdvTitle,
          mdvClose: !!mdvClose
        });

        // Se elementos não existem, não prosseguir
        if (!mdvDlg || !mdvArticle || !mdvContent || !mdvTitle) {
          console.warn('MDV: Elementos essenciais não encontrados, pulando inicialização');
          return;
        }

      /* ===== Markdown → HTML com segurança ===== */
      function initMarkdown() {
        if (typeof marked !== 'undefined') {
          marked.setOptions({
            gfm: true,
            breaks: false,
            smartLists: true,
            smartypants: true,
            mangle: false,
          });
          
          // Contador para IDs únicos de cabeçalhos
          const usedIds = new Set();
          function createSlug(text) {
            let slug = text
              .toLowerCase()
              .trim()
              .replace(/[^\w\s-]/g, '') // Remove caracteres especiais
              .replace(/[\s_-]+/g, '-') // Substitui espaços e _ por -
              .replace(/^-+|-+$/g, ''); // Remove - do início e fim
            
            // Garantir ID único
            let finalSlug = slug;
            let counter = 1;
            while (usedIds.has(finalSlug)) {
              finalSlug = `${slug}-${counter}`;
              counter++;
            }
            usedIds.add(finalSlug);
            return finalSlug;
          }
          
          const renderer = new marked.Renderer();
          renderer.link = function(href, title, text){
            const t = title ? ` title="${title}"` : '';
            return `<a href="${href}" target="_blank" rel="noopener noreferrer"${t}>${text}</a>`;
          };
          renderer.heading = function(text, level, raw){
            const id = createSlug(raw);
            return `<h${level} id="${id}">${text}<a class="h-anchor" href="#${id}" aria-label="Copiar link de seção">#</a></h${level}>`;
          };
          window.mdvRenderer = renderer;
        }
      }

      async function renderMarkdown(mdText){
        // Aguarda os scripts carregarem se necessário
        if (typeof marked === 'undefined' || typeof DOMPurify === 'undefined') {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        initMarkdown();
        
        // 1) Markdown → HTML
        const unsafe = marked.parse(mdText, { renderer: window.mdvRenderer });

        // 2) Sanitizar
        const clean = DOMPurify.sanitize(unsafe, {
          ADD_ATTR: ['target','rel','class','id','style','aria-label','aria-hidden','data-*'],
          ADD_TAGS: ['iframe','details','summary'] // se precisar
        });

        // 3) Inserir
        mdvArticle.innerHTML = clean;

        // 4) Syntax highlight
        if (typeof hljs !== 'undefined') {
          document.querySelectorAll('#mdv pre code').forEach(el => {
            try {
              hljs.highlightElement(el);
            } catch(e) {
              console.warn('Highlight.js error:', e);
            }
          });
        }

        // 5) Mermaid (quando houver)
        const hasMermaid = !!mdvArticle.querySelector('code.language-mermaid');
        if (hasMermaid && getMDVSettings().enableMermaid){
          try {
            await loadScriptOnce('https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js', 'mermaid');
            mermaid.initialize({ startOnLoad:false, theme: matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default' });
            mdvArticle.querySelectorAll('code.language-mermaid').forEach(code=>{
              const pre = code.closest('pre'); const parent = pre?.parentNode || code.parentNode;
              const d = document.createElement('div'); d.className = 'mermaid'; d.textContent = code.textContent;
              pre ? parent.replaceChild(d, pre) : parent.replaceChild(d, code);
            });
            await mermaid.run({ querySelector: '#mdv .mermaid' });
          } catch(e) {
            console.warn('Mermaid loading failed:', e);
          }
        }

        // 6) Math (KaTeX) — auto-render se encontrar delimitadores
        const mdStringHasMath = /\$\$[\s\S]+?\$\$|(?<!\\)\$[^$\n]+\$/m.test(mdText);
        if (mdStringHasMath && getMDVSettings().enableMath){
          try {
            loadCssOnce('https://cdn.jsdelivr.net/npm/katex@0.16/dist/katex.min.css', 'katex-css');
            await loadScriptOnce('https://cdn.jsdelivr.net/npm/katex@0.16/dist/katex.min.js', 'katex');
            await loadScriptOnce('https://cdn.jsdelivr.net/npm/katex@0.16/dist/contrib/auto-render.min.js', 'renderMathInElement');
            window.renderMathInElement(mdvArticle, {
              delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false},
                {left: "\\[", right: "\\]", display: true}
              ],
              throwOnError: false
            });
          } catch(e) {
            console.warn('KaTeX loading failed:', e);
          }
        }
      }

      /* ===== API pública ===== */
      async function openMarkdownViewer({ markdown, src, title }){
        if (!mdvDlg || !mdvContent || !mdvTitle) {
          console.error('MDV: Elementos necessários não encontrados');
          showToast('Erro ao abrir visualizador', 'error');
          return;
        }

        mdvTitle.textContent = title || 'Visualizador Markdown';

        // Carregar conteúdo
        let md = markdown || '';
        await renderMarkdown(md);

        // Abrir modal
        mdvDlg.showModal();
      }

      /* ===== Ligações de UI ===== */
      if (mdvDlg) {
        mdvDlg.addEventListener('keydown', (e)=>{
          if (e.key === 'Escape') mdvDlg.close('cancel');
        });
      }

      if (mdvClose) {
        mdvClose.addEventListener('click', ()=> mdvDlg.close('cancel'));
      }

      // Exponha a função
      window.openMarkdownViewer = openMarkdownViewer;

      // ===== FIM DO MDV =====

      }); // Fim do DOMContentLoaded MDV
  </script>

  <!-- MDV Modal HTML -->
  <dialog id="mdv" class="dialog-sheet" aria-modal="true" aria-labelledby="mdvTitle">
    <!-- Head -->
    <div class="mdv-head">
      <div class="mdv-title">
        <h3 id="mdvTitle">Visualizador Markdown</h3>
      </div>
      <button class="mdv-close" id="mdvClose" title="Fechar" aria-label="Fechar">✕</button>
    </div>

    <!-- Body -->
    <div class="mdv-body">
      <div id="mdvContent" class="mdv-content">
        <article class="prose" id="mdvArticle"><!-- conteúdo MD renderizado aqui --></article>
      </div>
    </div>
  </dialog>

  <!-- CDNs essenciais para o MDV -->
  <script src="https://cdn.jsdelivr.net/npm/marked@12/marked.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3/dist/purify.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" crossorigin="anonymous"></script>
  <link id="hljs-theme" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11/styles/github.min.css" crossorigin="anonymous">

</body>
</html>