<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Circle Physics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif;
            color: #fff;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        /* Menu Toggle Button */
        #menuToggle {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        #menuToggle:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: scale(1.05);
        }

        #menuToggle span {
            width: 20px;
            height: 2px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 2px;
            transition: all 0.3s ease;
        }

        #menuToggle.active span:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }

        #menuToggle.active span:nth-child(2) {
            opacity: 0;
        }

        #menuToggle.active span:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        /* Side Menu */
        #sideMenu {
            position: absolute;
            top: 0;
            left: -320px;
            width: 300px;
            height: 100%;
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow-y: auto;
            z-index: 999;
            padding: 80px 20px 20px;
        }

        #sideMenu.active {
            left: 0;
        }

        #sideMenu::-webkit-scrollbar {
            width: 6px;
        }

        #sideMenu::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        #sideMenu::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .menu-title {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 30px;
            letter-spacing: 2px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .menu-section {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .menu-section:last-child {
            border-bottom: none;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.4);
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
        }

        .control-value {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 500;
        }

        /* Slider */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Number Input */
        input[type="number"] {
            width: 60px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            text-align: center;
            transition: all 0.2s ease;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: rgba(102, 126, 234, 0.5);
            background: rgba(255, 255, 255, 0.08);
        }

        /* Toggle Switch */
        .switch-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .switch-label {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
        }

        .switch {
            position: relative;
            width: 44px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .switch-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            border-radius: 24px;
        }

        .switch-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background: rgba(255, 255, 255, 0.8);
            transition: all 0.3s ease;
            border-radius: 50%;
        }

        .switch input:checked + .switch-slider {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .switch input:checked + .switch-slider:before {
            transform: translateX(20px);
            background: white;
        }

        /* Color Theme Selector */
        .color-themes {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .color-theme {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .color-theme:hover {
            transform: scale(1.1);
        }

        .color-theme.active {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .color-theme-preview {
            width: 100%;
            height: 100%;
            display: flex;
            flex-wrap: wrap;
        }

        .color-theme-preview span {
            width: 50%;
            height: 50%;
        }

        /* Buttons */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
        }

        .btn-primary:hover {
            opacity: 0.9;
        }

        /* Stats Display */
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            min-width: 150px;
            z-index: 100;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.5);
        }

        .stat-value {
            font-weight: 500;
        }

        /* Collision System Styles */
        .control-subsection {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            border-left: 2px solid rgba(102, 126, 234, 0.3);
        }

        .subsection-label {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 10px;
        }

        .collision-mode-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            margin-left: 6px;
        }

        .mode-normal { background: rgba(100, 255, 100, 0.2); color: #6f6; }
        .mode-sticky { background: rgba(255, 200, 0, 0.2); color: #fc0; }
        .mode-explosive { background: rgba(255, 50, 50, 0.2); color: #f44; }
        .mode-absorbing { background: rgba(200, 100, 255, 0.2); color: #c6f; }
        .mode-phase { background: rgba(100, 200, 255, 0.2); color: #6cf; }

        select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        select:focus {
            outline: none;
            border-color: rgba(102, 126, 234, 0.5);
            background: rgba(255, 255, 255, 0.08);
        }

        select option {
            background: #1a1a2e;
            color: rgba(255, 255, 255, 0.9);
        }

        /* Advanced Color Theme Selector */
        .theme-selector-container {
            margin-top: 10px;
        }

        .theme-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
        }

        .theme-info-text {
            flex: 1;
        }

        .theme-name {
            font-size: 11px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 2px;
        }

        .theme-description {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.4);
        }

        .theme-preview-mini {
            display: flex;
            gap: 3px;
            margin-left: 10px;
        }

        .theme-preview-mini span {
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }

        .color-count-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            margin-bottom: 12px;
        }

        .color-count-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .color-count-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
        }

        .color-count-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: transparent;
            color: white;
        }

        .theme-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
            padding: 2px;
        }

        .theme-grid::-webkit-scrollbar {
            width: 4px;
        }

        .theme-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.02);
        }

        .theme-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
        }

        .theme-card {
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .theme-card:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }

        .theme-card.active {
            background: rgba(102, 126, 234, 0.15);
            border-color: rgba(102, 126, 234, 0.5);
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.2);
        }

        .theme-card-name {
            font-size: 10px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 6px;
            text-align: center;
        }

        .theme-card-preview {
            display: flex;
            gap: 2px;
            height: 20px;
            border-radius: 4px;
            overflow: hidden;
        }

        .theme-card-preview span {
            flex: 1;
        }

        /* Preset Styles */
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
            padding: 2px;
        }

        .preset-grid::-webkit-scrollbar {
            width: 4px;
        }

        .preset-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.02);
        }

        .preset-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
        }

        .preset-card {
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preset-card:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(2px);
        }

        .preset-card.active {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.6);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.3);
        }

        .preset-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 6px;
        }

        .preset-card-name {
            font-size: 12px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            letter-spacing: 0.5px;
        }

        .preset-card.active .preset-card-name {
            color: #fff;
        }

        .preset-badge {
            font-size: 8px;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .badge-default { background: rgba(100, 255, 100, 0.2); color: #6f6; }
        .badge-battle { background: rgba(255, 100, 100, 0.2); color: #f66; }
        .badge-physics { background: rgba(100, 200, 255, 0.2); color: #6cf; }
        .badge-chaos { background: rgba(255, 150, 0, 0.2); color: #fa0; }
        .badge-zen { background: rgba(200, 200, 255, 0.2); color: #ccf; }

        .preset-card-description {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .preset-card.active .preset-card-description {
            color: rgba(255, 255, 255, 0.7);
        }

        .preset-features {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .preset-feature {
            font-size: 8px;
            padding: 2px 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 500;
        }

        .preset-card.active .preset-feature {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.6);
        }
    </style>
</head>
<body>
    <!-- Menu Toggle Button -->
    <div id="menuToggle">
        <span></span>
        <span></span>
        <span></span>
    </div>

    <!-- Side Menu -->
    <div id="sideMenu">
        <h1 class="menu-title">PHYSICS LAB</h1>

        <!-- Presets -->
        <div class="menu-section">
            <div class="section-title">Presets</div>
            <div class="preset-grid" id="presetGrid">
                <!-- Preset cards will be dynamically generated -->
            </div>
        </div>

        <!-- Simulation Controls -->
        <div class="menu-section">
            <div class="section-title">Simulation</div>
            
            <div class="control-group">
                <div class="control-label">
                    <span>Speed</span>
                    <span class="control-value" id="speedValue">100%</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="speedSlider" min="0" max="500" value="100">
                    <input type="number" id="speedInput" min="0" max="500" value="100">
                </div>
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Ball Count</span>
                    <span class="control-value" id="ballCountValue">4</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="ballCountSlider" min="1" max="32" value="4">
                    <input type="number" id="ballCountInput" min="1" max="32" value="4">
                </div>
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Ball Size</span>
                    <span class="control-value" id="ballSizeValue">12px</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="ballSizeSlider" min="4" max="30" value="12">
                    <input type="number" id="ballSizeInput" min="4" max="30" value="12">
                </div>
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Circle Size</span>
                    <span class="control-value" id="circleSizeValue">35%</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="circleSizeSlider" min="20" max="45" value="35">
                    <input type="number" id="circleSizeInput" min="20" max="45" value="35">
                </div>
            </div>
        </div>

        <!-- Physics Settings -->
        <div class="menu-section">
            <div class="section-title">Physics</div>

            <div class="switch-container">
                <span class="switch-label">Accelerate with Lines</span>
                <label class="switch">
                    <input type="checkbox" id="accelerateWithLines">
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="control-group" id="accelerationGroup" style="display: none;">
                <div class="control-label">
                    <span>Acceleration per Line</span>
                    <span class="control-value" id="accelerationValue">5%</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="accelerationSlider" min="1" max="50" value="5">
                    <input type="number" id="accelerationInput" min="1" max="50" value="5">
                </div>
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Gravity Mode</span>
                </div>
                <select id="gravityModeSelect" style="width: 100%; padding: 8px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; color: rgba(255, 255, 255, 0.8); font-size: 12px; margin-top: 5px;">
                    <option value="none">Disabled</option>
                    <option value="center">Center of Map</option>
                    <option value="mutual">Mutual (Ball to Ball)</option>
                    <option value="down">Downward (Earth-like)</option>
                </select>
            </div>

            <div class="switch-container">
                <span class="switch-label">Spacetime Fabric</span>
                <label class="switch">
                    <input type="checkbox" id="spacetimeFabric">
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="control-group" id="fabricIntensityGroup" style="display: none;">
                <div class="control-label">
                    <span>Fabric Intensity</span>
                    <span class="control-value" id="fabricIntensityValue">100%</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="fabricIntensitySlider" min="10" max="200" value="100">
                    <input type="number" id="fabricIntensityInput" min="10" max="200" value="100">
                </div>
            </div>

            <div class="control-group" id="fabricOpacityGroup" style="display: none;">
                <div class="control-label">
                    <span>Fabric Opacity</span>
                    <span class="control-value" id="fabricOpacityValue">40%</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="fabricOpacitySlider" min="10" max="100" value="40">
                    <input type="number" id="fabricOpacityInput" min="10" max="100" value="40">
                </div>
            </div>

            <div class="control-group" id="fabricDensityGroup" style="display: none;">
                <div class="control-label">
                    <span>Fabric Density</span>
                    <span class="control-value" id="fabricDensityValue">12</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="fabricDensitySlider" min="6" max="24" value="12">
                    <input type="number" id="fabricDensityInput" min="6" max="24" value="12">
                </div>
            </div>

            <div class="control-group" id="gravityIntensityGroup" style="display: none;">
                <div class="control-label">
                    <span>Gravity Intensity</span>
                    <span class="control-value" id="gravityIntensityValue">100</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="gravityIntensitySlider" min="0" max="1000" value="100" step="10">
                    <input type="number" id="gravityIntensityInput" min="0" max="1000" value="100" step="10">
                </div>
            </div>

            <div class="control-group" id="gravityMassGroup" style="display: none;">
                <div class="control-label">
                    <span>Ball Mass</span>
                    <span class="control-value" id="gravityMassValue">1.0</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="gravityMassSlider" min="10" max="300" value="10" step="1">
                    <input type="number" id="gravityMassInput" min="0.1" max="30" value="1.0" step="0.1">
                </div>
            </div>

            <div class="control-group" id="gravityDampingGroup" style="display: none;">
                <div class="control-label">
                    <span>Velocity Damping</span>
                    <span class="control-value" id="gravityDampingValue">1.00</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="gravityDampingSlider" min="90" max="100" value="100" step="1">
                    <input type="number" id="gravityDampingInput" min="0.9" max="1.0" value="1.0" step="0.01">
                </div>
            </div>

            <div class="switch-container">
                <span class="switch-label">Elastic Lines</span>
                <label class="switch">
                    <input type="checkbox" id="elasticLines">
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="switch-container">
                <span class="switch-label">Collision Damping</span>
                <label class="switch">
                    <input type="checkbox" id="collisionDamping">
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="control-group" id="dampingGroup" style="display: none;">
                <div class="control-label">
                    <span>Damping Factor</span>
                    <span class="control-value" id="dampingValue">0.9</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="dampingSlider" min="50" max="100" value="90">
                    <input type="number" id="dampingInput" min="50" max="100" value="90">
                </div>
            </div>
        </div>

        <!-- Collision System -->
        <div class="menu-section">
            <div class="section-title">Collision System</div>
            
            <!-- General Controls -->
            <div class="control-subsection">
                <div class="subsection-label">General</div>
                
                <div class="switch-container">
                    <span class="switch-label">Enable Collisions</span>
                    <label class="switch">
                        <input type="checkbox" id="collisionsEnabled" checked>
                        <span class="switch-slider"></span>
                    </label>
                </div>
                
                <div class="switch-container">
                    <span class="switch-label">Ball-to-Ball</span>
                    <label class="switch">
                        <input type="checkbox" id="ballToBallCollisions" checked>
                        <span class="switch-slider"></span>
                    </label>
                </div>
                
                <div class="switch-container">
                    <span class="switch-label">Ball-to-Wall</span>
                    <label class="switch">
                        <input type="checkbox" id="ballToWallCollisions" checked>
                        <span class="switch-slider"></span>
                    </label>
                </div>
            </div>
            
            <!-- Physics Parameters -->
            <div class="control-subsection">
                <div class="subsection-label">Physics</div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Restitution (Elasticity)</span>
                        <span class="control-value" id="restitutionValue">1.00</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="restitutionSlider" min="0" max="200" value="100">
                        <input type="number" id="restitutionInput" min="0" max="2.0" value="1.0" step="0.1">
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Force Boost</span>
                        <span class="control-value" id="forceBoostValue">100%</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="forceBoostSlider" min="50" max="500" value="100">
                        <input type="number" id="forceBoostInput" min="50" max="500" value="100">
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Friction</span>
                        <span class="control-value" id="frictionValue">0.00</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="frictionSlider" min="0" max="100" value="0">
                        <input type="number" id="frictionInput" min="0" max="1.0" value="0" step="0.1">
                    </div>
                </div>
            </div>
            
            <!-- Special Options -->
            <div class="control-subsection">
                <div class="subsection-label">Special</div>
                
                <div class="switch-container">
                    <span class="switch-label">Preserve Speed Magnitude</span>
                    <label class="switch">
                        <input type="checkbox" id="preserveSpeed">
                        <span class="switch-slider"></span>
                    </label>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Collision Mode
                        <span class="collision-mode-badge mode-normal" id="modeBadge">NORMAL</span>
                        </span>
                    </div>
                    <select id="collisionModeSelect" style="margin-top: 8px;">
                        <option value="normal">Normal</option>
                        <option value="sticky">Sticky (Balls Stick Together)</option>
                        <option value="explosive">Explosive (Gain Energy)</option>
                        <option value="absorbing">Absorbing (Transfer Momentum)</option>
                        <option value="phase">Phase Through (No Collisions)</option>
                    </select>
                </div>
                
                <!-- Mode-specific Parameters -->
                <div id="stickyParams" style="display: none;">
                    <div class="control-group">
                        <div class="control-label">
                            <span>Sticky Duration</span>
                            <span class="control-value" id="stickyDurationValue">0.5s</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="stickyDurationSlider" min="10" max="500" value="50">
                            <input type="number" id="stickyDurationInput" min="0.1" max="5.0" value="0.5" step="0.1">
                        </div>
                    </div>
                </div>
                
                <div id="explosiveParams" style="display: none;">
                    <div class="control-group">
                        <div class="control-label">
                            <span>Explosive Boost</span>
                            <span class="control-value" id="explosiveBoostValue">150%</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="explosiveBoostSlider" min="110" max="300" value="150">
                            <input type="number" id="explosiveBoostInput" min="1.1" max="3.0" value="1.5" step="0.1">
                        </div>
                    </div>
                </div>
                
                <div id="absorbingParams" style="display: none;">
                    <div class="control-group">
                        <div class="control-label">
                            <span>Absorbing Factor</span>
                            <span class="control-value" id="absorbingFactorValue">50%</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="absorbingFactorSlider" min="0" max="100" value="50">
                            <input type="number" id="absorbingFactorInput" min="0" max="1.0" value="0.5" step="0.1">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Advanced -->
            <div class="control-subsection">
                <div class="subsection-label">Advanced</div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Collision Cooldown</span>
                        <span class="control-value" id="cooldownValue">0.0s</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="cooldownSlider" min="0" max="100" value="0">
                        <input type="number" id="cooldownInput" min="0" max="1.0" value="0" step="0.05">
                    </div>
                </div>
            </div>
        </div>

        <!-- Visual Effects -->
        <div class="menu-section">
            <div class="section-title">Visual Effects</div>

            <div class="switch-container">
                <span class="switch-label">Motion Trails</span>
                <label class="switch">
                    <input type="checkbox" id="motionTrails">
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="switch-container">
                <span class="switch-label">Collision Effects</span>
                <label class="switch">
                    <input type="checkbox" id="collisionEffects" checked>
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="switch-container">
                <span class="switch-label">Particle Effects</span>
                <label class="switch">
                    <input type="checkbox" id="particleEffects" checked>
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="switch-container">
                <span class="switch-label">Glow Effect</span>
                <label class="switch">
                    <input type="checkbox" id="glowEffect">
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Line Opacity</span>
                    <span class="control-value" id="lineOpacityValue">60%</span>
                </div>
                <div class="slider-container">
                    <input type="range" id="lineOpacitySlider" min="10" max="100" value="60">
                    <input type="number" id="lineOpacityInput" min="10" max="100" value="60">
                </div>
            </div>
        </div>

        <!-- Game Modes -->
        <div class="menu-section">
            <div class="section-title">Game Modes</div>

            <div class="switch-container">
                <span class="switch-label">Lines System</span>
                <label class="switch">
                    <input type="checkbox" id="linesEnabled" checked>
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="switch-container">
                <span class="switch-label">Auto Respawn</span>
                <label class="switch">
                    <input type="checkbox" id="autoRespawn">
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="switch-container">
                <span class="switch-label">Elimination Mode</span>
                <label class="switch">
                    <input type="checkbox" id="eliminationMode" checked>
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="switch-container">
                <span class="switch-label">Line Stealing</span>
                <label class="switch">
                    <input type="checkbox" id="lineStealing" checked>
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div class="switch-container">
                <span class="switch-label">Power-ups</span>
                <label class="switch">
                    <input type="checkbox" id="powerUps">
                    <span class="switch-slider"></span>
                </label>
            </div>
        </div>

        <!-- Chainsaw Mode -->
        <div class="menu-section">
            <div class="section-title">Chainsaw Mode</div>
            
            <!-- Master Toggle -->
            <div class="switch-container">
                <span class="switch-label">Enable Chainsaw Mode</span>
                <label class="switch">
                    <input type="checkbox" id="chainsawModeEnabled">
                    <span class="switch-slider"></span>
                </label>
            </div>

            <div id="chainsawModeSettings" style="display: none;">
                <!-- Lives System -->
                <div class="control-subsection">
                    <div class="subsection-label">Lives System</div>
                    
                    <div class="switch-container">
                        <span class="switch-label">Enable Lives Mode</span>
                        <label class="switch">
                            <input type="checkbox" id="chainsawLivesMode">
                            <span class="switch-slider"></span>
                        </label>
                    </div>

                    <div class="control-group" id="startingLivesGroup" style="display: none;">
                        <div class="control-label">
                            <span>Starting Lives</span>
                            <span class="control-value" id="startingLivesValue">5</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="startingLivesSlider" min="1" max="10" value="5">
                            <input type="number" id="startingLivesInput" min="1" max="10" value="5">
                        </div>
                    </div>
                </div>

                <!-- Spawn Mechanics -->
                <div class="control-subsection">
                    <div class="subsection-label">Spawn Mechanics</div>
                    
                    <div class="control-group">
                        <div class="control-label">
                            <span>Max Saws on Map</span>
                            <span class="control-value" id="maxSawsValue">2</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="maxSawsSlider" min="1" max="5" value="2">
                            <input type="number" id="maxSawsInput" min="1" max="5" value="2">
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span>Spawn Interval</span>
                            <span class="control-value" id="sawSpawnIntervalValue">5s</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="sawSpawnIntervalSlider" min="2" max="30" value="5">
                            <input type="number" id="sawSpawnIntervalInput" min="2" max="30" value="5">
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span>Initial Delay</span>
                            <span class="control-value" id="initialSawDelayValue">3s</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="initialSawDelaySlider" min="0" max="20" value="3">
                            <input type="number" id="initialSawDelayInput" min="0" max="20" value="3">
                        </div>
                    </div>
                </div>

                <!-- Saw Behavior -->
                <div class="control-subsection">
                    <div class="subsection-label">Saw Behavior</div>
                    
                    <div class="control-group">
                        <div class="control-label">
                            <span>Usage Type</span>
                        </div>
                        <select id="sawBehaviorSelect" style="margin-top: 8px;">
                            <option value="single-hit">Single Hit</option>
                            <option value="durability">Durability (Charges)</option>
                            <option value="timed">Timed (Seconds)</option>
                        </select>
                    </div>

                    <div class="control-group" id="sawChargesGroup" style="display: none;">
                        <div class="control-label">
                            <span>Saw Charges</span>
                            <span class="control-value" id="sawChargesValue">3</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="sawChargesSlider" min="1" max="5" value="3">
                            <input type="number" id="sawChargesInput" min="1" max="5" value="3">
                        </div>
                    </div>

                    <div class="control-group" id="sawDurationGroup" style="display: none;">
                        <div class="control-label">
                            <span>Saw Duration</span>
                            <span class="control-value" id="sawDurationValue">15s</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" id="sawDurationSlider" min="5" max="30" value="15">
                            <input type="number" id="sawDurationInput" min="5" max="30" value="15">
                        </div>
                    </div>
                </div>

                <!-- Saw Clash -->
                <div class="control-subsection">
                    <div class="subsection-label">Saw vs Saw Collision</div>
                    
                    <div class="control-group">
                        <div class="control-label">
                            <span>Clash Behavior</span>
                        </div>
                        <select id="sawClashBehaviorSelect" style="margin-top: 8px;">
                            <option value="both-break">Both Break</option>
                            <option value="ricochet">Ricochet</option>
                            <option value="null">Null (Pass Through)</option>
                        </select>
                    </div>
                </div>

                <!-- Saw Types -->
                <div class="control-subsection">
                    <div class="subsection-label">Available Saw Types</div>
                    
                    <div class="switch-container">
                        <span class="switch-label">Standard Saw</span>
                        <label class="switch">
                            <input type="checkbox" id="sawTypeStandard" checked>
                            <span class="switch-slider"></span>
                        </label>
                    </div>

                    <div class="switch-container">
                        <span class="switch-label">Heavy Saw</span>
                        <label class="switch">
                            <input type="checkbox" id="sawTypeHeavy" checked>
                            <span class="switch-slider"></span>
                        </label>
                    </div>

                    <div class="switch-container">
                        <span class="switch-label">Light Saw</span>
                        <label class="switch">
                            <input type="checkbox" id="sawTypeLight" checked>
                            <span class="switch-slider"></span>
                        </label>
                    </div>

                    <div class="switch-container">
                        <span class="switch-label">Vortex Saw</span>
                        <label class="switch">
                            <input type="checkbox" id="sawTypeVortex" checked>
                            <span class="switch-slider"></span>
                        </label>
                    </div>

                    <div class="switch-container">
                        <span class="switch-label">EMP Saw</span>
                        <label class="switch">
                            <input type="checkbox" id="sawTypeEmp" checked>
                            <span class="switch-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Color Themes -->
        <div class="menu-section">
            <div class="section-title">Color Themes</div>
            
            <!-- Current Theme Info -->
            <div class="theme-info">
                <div class="theme-info-text">
                    <div class="theme-name" id="currentThemeName">Classic</div>
                    <div class="theme-description" id="currentThemeDescription">Traditional primary colors</div>
                </div>
                <div class="theme-preview-mini" id="currentThemePreview">
                    <!-- Preview colors will be inserted here -->
                </div>
            </div>

            <!-- Color Count Selector -->
            <div class="control-group">
                <div class="control-label">
                    <span>Color Count</span>
                    <span class="control-value" id="colorCountValue">4 colors</span>
                </div>
                <div class="color-count-selector">
                    <button class="color-count-btn active" data-count="4">4</button>
                    <button class="color-count-btn" data-count="8">8</button>
                    <button class="color-count-btn" data-count="16">16</button>
                    <button class="color-count-btn" data-count="32">32</button>
                </div>
            </div>

            <!-- Theme Grid -->
            <div class="theme-grid" id="themeGrid">
                <!-- Theme cards will be dynamically generated -->
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="menu-section">
            <div class="button-group">
                <button class="btn btn-primary" id="resetBtn">Reset</button>
                <button class="btn" id="pauseBtn">Pause</button>
            </div>
            <div class="button-group">
                <button class="btn" id="exportBtn">Export Settings</button>
                <button class="btn" id="importBtn">Import Settings</button>
            </div>
        </div>
    </div>

    <!-- Stats Display -->
    <div id="stats">
        <div class="stat-row">
            <span class="stat-label">Active Balls:</span>
            <span class="stat-value" id="activeBalls">4</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Total Lines:</span>
            <span class="stat-value" id="totalLines">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">FPS:</span>
            <span class="stat-value" id="fps">60</span>
        </div>
    </div>

    <!-- Canvas -->
    <canvas id="simCanvas"></canvas>

    <script>
        /**
         * COLOR UTILITIES
         * Functions for color manipulation and palette generation
         */
        const ColorUtils = {
            /**
             * Convert hex color to RGB
             */
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            },

            /**
             * Convert RGB to hex
             */
            rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (Math.round(r) << 16) + (Math.round(g) << 8) + Math.round(b)).toString(16).slice(1);
            },

            /**
             * Convert RGB to HSL
             */
            rgbToHsl(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return { h: h * 360, s: s * 100, l: l * 100 };
            },

            /**
             * Convert HSL to RGB
             */
            hslToRgb(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                let r, g, b;

                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return { r: r * 255, g: g * 255, b: b * 255 };
            },

            /**
             * Interpolate between two colors in RGB space
             */
            interpolateColors(color1, color2, factor) {
                const c1 = this.hexToRgb(color1);
                const c2 = this.hexToRgb(color2);
                const r = c1.r + (c2.r - c1.r) * factor;
                const g = c1.g + (c2.g - c1.g) * factor;
                const b = c1.b + (c2.b - c1.b) * factor;
                return this.rgbToHex(r, g, b);
            },

            /**
             * Generate a palette of colors from a set of key colors
             * @param {Array} keyColors - Array of hex color strings
             * @param {Number} count - Number of colors to generate
             */
            generatePalette(keyColors, count) {
                if (count <= keyColors.length) {
                    return keyColors.slice(0, count);
                }

                const palette = [];
                const segments = keyColors.length - 1;
                const colorsPerSegment = Math.floor((count - keyColors.length) / segments);
                const remainder = (count - keyColors.length) % segments;

                for (let i = 0; i < segments; i++) {
                    palette.push(keyColors[i]);
                    const extraColor = i < remainder ? 1 : 0;
                    const steps = colorsPerSegment + extraColor + 1;
                    
                    for (let j = 1; j < steps; j++) {
                        const factor = j / steps;
                        palette.push(this.interpolateColors(keyColors[i], keyColors[i + 1], factor));
                    }
                }
                palette.push(keyColors[keyColors.length - 1]);

                return palette.slice(0, count);
            },

            /**
             * Generate colors using HSL rotation
             * @param {String} baseColor - Starting color in hex
             * @param {Number} count - Number of colors to generate
             * @param {Number} hueRange - Range of hue rotation (0-360)
             * @param {Number} saturationVariation - Variation in saturation
             * @param {Number} lightnessVariation - Variation in lightness
             */
            generateHslPalette(baseColor, count, hueRange = 360, saturationVariation = 10, lightnessVariation = 10) {
                const rgb = this.hexToRgb(baseColor);
                const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
                const palette = [];

                for (let i = 0; i < count; i++) {
                    const hueOffset = (hueRange / count) * i;
                    const satOffset = (Math.sin(i) * saturationVariation);
                    const lightOffset = (Math.cos(i) * lightnessVariation);
                    
                    const newH = (hsl.h + hueOffset) % 360;
                    const newS = Math.max(0, Math.min(100, hsl.s + satOffset));
                    const newL = Math.max(20, Math.min(80, hsl.l + lightOffset));
                    
                    const newRgb = this.hslToRgb(newH, newS, newL);
                    palette.push(this.rgbToHex(newRgb.r, newRgb.g, newRgb.b));
                }

                return palette;
            }
        };

        /**
         * ADVANCED COLOR THEME SYSTEM
         * Each theme has key colors that define its spectrum
         * Colors are generated uniformly across the spectrum for each configuration
         */
        const COLOR_THEME_DEFINITIONS = {
            classic: {
                name: 'Classic',
                description: 'Traditional primary colors',
                keyColors: ['#FF3B30', '#FFCC00', '#4CD964', '#007AFF']
            },
            neon: {
                name: 'Neon Lights',
                description: 'Vibrant electric colors',
                keyColors: ['#FF006E', '#FFBE0B', '#00F5FF', '#8338EC']
            },
            pastel: {
                name: 'Pastel Dreams',
                description: 'Soft and gentle colors',
                keyColors: ['#FFB3BA', '#FFFFBA', '#BAFFC9', '#BAE1FF']
            },
            fire: {
                name: 'Inferno',
                description: 'Hot flames and embers',
                keyColors: ['#FF0000', '#FF4500', '#FF8C00', '#FFD700']
            },
            ocean: {
                name: 'Deep Ocean',
                description: 'Cool underwater tones',
                keyColors: ['#001F3F', '#0074D9', '#7FDBFF', '#39CCCC']
            },
            forest: {
                name: 'Enchanted Forest',
                description: 'Natural green spectrum',
                keyColors: ['#2ECC40', '#3D9970', '#01FF70', '#85E085']
            },
            sunset: {
                name: 'Sunset Sky',
                description: 'Warm evening colors',
                keyColors: ['#FF6B9D', '#FF8C42', '#FFA62B', '#C73E1D']
            },
            galaxy: {
                name: 'Cosmic Galaxy',
                description: 'Deep space colors',
                keyColors: ['#4A00E0', '#8E2DE2', '#DA22FF', '#9733EE']
            },
            cyberpunk: {
                name: 'Cyberpunk',
                description: 'Futuristic neon',
                keyColors: ['#00FF41', '#FF0080', '#00D9FF', '#FFD700']
            },
            retro: {
                name: 'Retro Wave',
                description: 'Vintage 80s style',
                keyColors: ['#FF6AD5', '#C774E8', '#AD8CFF', '#8795E8']
            },
            candy: {
                name: 'Candy Shop',
                description: 'Sweet colorful treats',
                keyColors: ['#FF1493', '#FF69B4', '#FFB6C1', '#FF80BF']
            },
            mono: {
                name: 'Monochrome',
                description: 'Grayscale spectrum',
                keyColors: ['#FFFFFF', '#CCCCCC', '#999999', '#666666', '#333333']
            },
            arctic: {
                name: 'Arctic Ice',
                description: 'Cool icy blues',
                keyColors: ['#E0F7FF', '#B3E5FC', '#81D4FA', '#4FC3F7']
            },
            toxic: {
                name: 'Toxic Waste',
                description: 'Radioactive greens',
                keyColors: ['#CCFF00', '#9ACD32', '#7FFF00', '#32CD32']
            }
        };

        /**
         * Generate all theme palettes for all color counts
         */
        function generateThemePalettes() {
            const themes = {};
            const colorCounts = [4, 8, 16, 32];

            for (const [themeKey, themeDef] of Object.entries(COLOR_THEME_DEFINITIONS)) {
                themes[themeKey] = {
                    name: themeDef.name,
                    description: themeDef.description,
                    palettes: {}
                };

                colorCounts.forEach(count => {
                    themes[themeKey].palettes[count] = ColorUtils.generatePalette(themeDef.keyColors, count);
                });
            }

            return themes;
        }

        /**
         * COLOR THEMES - Cached palettes
         */
        const COLOR_THEMES = generateThemePalettes();

        /**
         * PRESET DEFINITIONS
         * Curated configurations for different gameplay experiences
         */
        const PRESET_DEFINITIONS = {
            personalized: {
                name: 'Personalized',
                description: 'Custom settings modified by user',
                badge: 'zen',
                features: ['Custom', 'User-Defined', 'Modified'],
                config: null // Will be dynamically set
            },
            
            classicArena: {
                name: 'Classic Arena',
                description: 'Traditional competitive gameplay with lines and elimination',
                badge: 'default',
                features: ['4 Balls', 'Lines', 'Elimination', 'Perfect Physics'],
                config: {
                    ballCount: 4,
                    ballRadius: 12,
                    ballSpeed: 220,
                    speedMultiplier: 1,
                    colors: COLOR_THEMES.classic.palettes[4],
                    currentTheme: "classic",
                    currentColorCount: 4,
                    circleRadiusRatio: 0.35,
                    lineOpacity: 0.6,
                    lineWidth: 2,
                    accelerateWithLines: false,
                    accelerationPerLine: 0.05,
                    gravityMode: "none",
                    gravityIntensity: 100,
                    gravityMass: 1,
                    gravityDamping: 1,
                    elasticLines: false,
                    collisionDamping: false,
                    dampingFactor: 0.9,
                    collision: {
                        enabled: true,
                        ballToBallEnabled: true,
                        ballToWallEnabled: true,
                        restitution: 1,
                        friction: 0,
                        normalForceBoost: 1,
                        preserveSpeedMagnitude: false,
                        mode: "normal",
                        stickyDuration: 0.5,
                        explosiveBoost: 1.5,
                        absorbingFactor: 0.5,
                        minSeparationVelocity: 0,
                        collisionCooldown: 0,
                        showCollisionPoints: false,
                        modeSpecificEffects: true
                    },
                    motionTrails: false,
                    collisionEffects: true,
                    particleEffects: true,
                    glowEffect: false,
                    spacetimeFabric: false,
                    fabricIntensity: 1,
                    fabricDensity: 12,
                    fabricOpacity: 0.4,
                    autoRespawn: false,
                    eliminationMode: true,
                    lineStealing: true,
                    linesEnabled: true,
                    powerUps: false,
                    chainsawMode: {
                        enabled: false,
                        livesMode: false,
                        startingLives: 5,
                        maxSawsOnMap: 2,
                        sawSpawnInterval: 5,
                        initialSawDelay: 3,
                        sawBehavior: "single-hit",
                        sawCharges: 3,
                        sawDuration: 15,
                        sawClashBehavior: "both-break",
                        enabledSawTypes: {
                            standard: true,
                            heavy: true,
                            light: true,
                            vortex: true,
                            emp: true
                        }
                    },
                    isPaused: false
                }
            },
            
            chainsaw1v1: {
                name: 'Chainsaw 1v1',
                description: 'Intense duel with chainsaw hazards and lives system',
                badge: 'battle',
                features: ['2 Balls', 'Chainsaws', '5 Lives', 'High Stakes'],
                config: {
                    ballCount: 2,
                    ballRadius: 22,
                    ballSpeed: 220,
                    speedMultiplier: 0.75,
                    colors: COLOR_THEMES.galaxy.palettes[4],
                    currentTheme: "galaxy",
                    currentColorCount: 4,
                    circleRadiusRatio: 0.24,
                    lineOpacity: 0.6,
                    lineWidth: 2,
                    accelerateWithLines: false,
                    accelerationPerLine: 0.05,
                    gravityMode: "mutual",
                    gravityIntensity: 310,
                    gravityMass: 3,
                    gravityDamping: 1,
                    elasticLines: false,
                    collisionDamping: false,
                    dampingFactor: 0.9,
                    collision: {
                        enabled: true,
                        ballToBallEnabled: true,
                        ballToWallEnabled: true,
                        restitution: 1,
                        friction: 0,
                        normalForceBoost: 1,
                        preserveSpeedMagnitude: false,
                        mode: "normal",
                        stickyDuration: 0.5,
                        explosiveBoost: 1.1,
                        absorbingFactor: 0.5,
                        minSeparationVelocity: 0,
                        collisionCooldown: 0,
                        showCollisionPoints: false,
                        modeSpecificEffects: true
                    },
                    motionTrails: false,
                    collisionEffects: true,
                    particleEffects: true,
                    glowEffect: false,
                    spacetimeFabric: false,
                    fabricIntensity: 1,
                    fabricDensity: 12,
                    fabricOpacity: 0.4,
                    autoRespawn: false,
                    eliminationMode: true,
                    lineStealing: true,
                    linesEnabled: false,
                    powerUps: false,
                    chainsawMode: {
                        enabled: true,
                        livesMode: true,
                        startingLives: 5,
                        maxSawsOnMap: 1,
                        sawSpawnInterval: 2,
                        initialSawDelay: 0,
                        sawBehavior: "single-hit",
                        sawCharges: 3,
                        sawDuration: 15,
                        sawClashBehavior: "both-break",
                        enabledSawTypes: {
                            standard: true,
                            heavy: false,
                            light: false,
                            vortex: false,
                            emp: false
                        }
                    },
                    isPaused: false
                }
            },
            
            gravityBallet: {
                name: 'Gravity Ballet',
                description: 'Elegant orbital dance with mutual gravitational attraction',
                badge: 'physics',
                features: ['6 Balls', 'Mutual Gravity', 'Spacetime', 'Orbital'],
                config: {
                    ballCount: 6,
                    ballRadius: 10,
                    ballSpeed: 180,
                    speedMultiplier: 1,
                    colors: COLOR_THEMES.sunset.palettes[8],
                    currentTheme: "sunset",
                    currentColorCount: 8,
                    circleRadiusRatio: 0.38,
                    lineOpacity: 0.4,
                    lineWidth: 1,
                    accelerateWithLines: false,
                    accelerationPerLine: 0.05,
                    gravityMode: "mutual",
                    gravityIntensity: 200,
                    gravityMass: 2,
                    gravityDamping: 0.995,
                    elasticLines: false,
                    collisionDamping: false,
                    dampingFactor: 0.95,
                    collision: {
                        enabled: true,
                        ballToBallEnabled: true,
                        ballToWallEnabled: true,
                        restitution: 0.95,
                        friction: 0,
                        normalForceBoost: 0.8,
                        preserveSpeedMagnitude: false,
                        mode: "normal",
                        stickyDuration: 0.5,
                        explosiveBoost: 1.5,
                        absorbingFactor: 0.5,
                        minSeparationVelocity: 0,
                        collisionCooldown: 0,
                        showCollisionPoints: false,
                        modeSpecificEffects: true
                    },
                    motionTrails: true,
                    collisionEffects: true,
                    particleEffects: false,
                    glowEffect: true,
                    spacetimeFabric: true,
                    fabricIntensity: 1.5,
                    fabricDensity: 16,
                    fabricOpacity: 0.5,
                    autoRespawn: false,
                    eliminationMode: false,
                    lineStealing: false,
                    linesEnabled: false,
                    powerUps: false,
                    chainsawMode: {
                        enabled: false,
                        livesMode: false,
                        startingLives: 5,
                        maxSawsOnMap: 2,
                        sawSpawnInterval: 5,
                        initialSawDelay: 3,
                        sawBehavior: "single-hit",
                        sawCharges: 3,
                        sawDuration: 15,
                        sawClashBehavior: "both-break",
                        enabledSawTypes: {
                            standard: true,
                            heavy: true,
                            light: true,
                            vortex: true,
                            emp: true
                        }
                    },
                    isPaused: false
                }
            },
            
            chaosArena: {
                name: 'Chaos Arena',
                description: 'High-energy mayhem with explosive collisions',
                badge: 'chaos',
                features: ['12 Balls', 'Explosive', 'Fast', 'Particles'],
                config: {
                    ballCount: 12,
                    ballRadius: 8,
                    ballSpeed: 280,
                    speedMultiplier: 1.3,
                    colors: COLOR_THEMES.fire.palettes[16],
                    currentTheme: "fire",
                    currentColorCount: 16,
                    circleRadiusRatio: 0.40,
                    lineOpacity: 0.7,
                    lineWidth: 2,
                    accelerateWithLines: true,
                    accelerationPerLine: 0.08,
                    gravityMode: "none",
                    gravityIntensity: 100,
                    gravityMass: 1,
                    gravityDamping: 1,
                    elasticLines: false,
                    collisionDamping: false,
                    dampingFactor: 0.9,
                    collision: {
                        enabled: true,
                        ballToBallEnabled: true,
                        ballToWallEnabled: true,
                        restitution: 1.05,
                        friction: 0,
                        normalForceBoost: 1.2,
                        preserveSpeedMagnitude: false,
                        mode: "explosive",
                        stickyDuration: 0.5,
                        explosiveBoost: 1.3,
                        absorbingFactor: 0.5,
                        minSeparationVelocity: 0,
                        collisionCooldown: 0,
                        showCollisionPoints: false,
                        modeSpecificEffects: true
                    },
                    motionTrails: true,
                    collisionEffects: true,
                    particleEffects: true,
                    glowEffect: true,
                    spacetimeFabric: false,
                    fabricIntensity: 1,
                    fabricDensity: 12,
                    fabricOpacity: 0.4,
                    autoRespawn: true,
                    eliminationMode: true,
                    lineStealing: true,
                    linesEnabled: true,
                    powerUps: false,
                    chainsawMode: {
                        enabled: false,
                        livesMode: false,
                        startingLives: 5,
                        maxSawsOnMap: 2,
                        sawSpawnInterval: 5,
                        initialSawDelay: 3,
                        sawBehavior: "single-hit",
                        sawCharges: 3,
                        sawDuration: 15,
                        sawClashBehavior: "both-break",
                        enabledSawTypes: {
                            standard: true,
                            heavy: true,
                            light: true,
                            vortex: true,
                            emp: true
                        }
                    },
                    isPaused: false
                }
            },
            
            minimalZen: {
                name: 'Minimal Zen',
                description: 'Pure physics meditation with just two spheres',
                badge: 'zen',
                features: ['2 Balls', 'Clean', 'Relaxing', 'Pure Physics'],
                config: {
                    ballCount: 2,
                    ballRadius: 18,
                    ballSpeed: 150,
                    speedMultiplier: 0.8,
                    colors: COLOR_THEMES.pastel.palettes[4],
                    currentTheme: "pastel",
                    currentColorCount: 4,
                    circleRadiusRatio: 0.30,
                    lineOpacity: 0.3,
                    lineWidth: 1,
                    accelerateWithLines: false,
                    accelerationPerLine: 0.05,
                    gravityMode: "none",
                    gravityIntensity: 100,
                    gravityMass: 1,
                    gravityDamping: 1,
                    elasticLines: false,
                    collisionDamping: false,
                    dampingFactor: 0.9,
                    collision: {
                        enabled: true,
                        ballToBallEnabled: true,
                        ballToWallEnabled: true,
                        restitution: 1,
                        friction: 0,
                        normalForceBoost: 1,
                        preserveSpeedMagnitude: false,
                        mode: "normal",
                        stickyDuration: 0.5,
                        explosiveBoost: 1.5,
                        absorbingFactor: 0.5,
                        minSeparationVelocity: 0,
                        collisionCooldown: 0,
                        showCollisionPoints: false,
                        modeSpecificEffects: true
                    },
                    motionTrails: false,
                    collisionEffects: false,
                    particleEffects: false,
                    glowEffect: false,
                    spacetimeFabric: false,
                    fabricIntensity: 1,
                    fabricDensity: 12,
                    fabricOpacity: 0.4,
                    autoRespawn: false,
                    eliminationMode: false,
                    lineStealing: false,
                    linesEnabled: false,
                    powerUps: false,
                    chainsawMode: {
                        enabled: false,
                        livesMode: false,
                        startingLives: 5,
                        maxSawsOnMap: 2,
                        sawSpawnInterval: 5,
                        initialSawDelay: 3,
                        sawBehavior: "single-hit",
                        sawCharges: 3,
                        sawDuration: 15,
                        sawClashBehavior: "both-break",
                        enabledSawTypes: {
                            standard: true,
                            heavy: true,
                            light: true,
                            vortex: true,
                            emp: true
                        }
                    },
                    isPaused: false
                }
            },
            
            speedBattle: {
                name: 'Speed Battle',
                description: 'Lightning-fast action with velocity-based gameplay',
                badge: 'battle',
                features: ['6 Balls', 'High Speed', 'Lines', 'Fast-Paced'],
                config: {
                    ballCount: 6,
                    ballRadius: 10,
                    ballSpeed: 350,
                    speedMultiplier: 1.5,
                    colors: COLOR_THEMES.neon.palettes[8],
                    currentTheme: "neon",
                    currentColorCount: 8,
                    circleRadiusRatio: 0.38,
                    lineOpacity: 0.8,
                    lineWidth: 2,
                    accelerateWithLines: true,
                    accelerationPerLine: 0.10,
                    gravityMode: "none",
                    gravityIntensity: 100,
                    gravityMass: 1,
                    gravityDamping: 1,
                    elasticLines: false,
                    collisionDamping: false,
                    dampingFactor: 0.9,
                    collision: {
                        enabled: true,
                        ballToBallEnabled: true,
                        ballToWallEnabled: true,
                        restitution: 1.1,
                        friction: 0,
                        normalForceBoost: 1.3,
                        preserveSpeedMagnitude: true,
                        mode: "normal",
                        stickyDuration: 0.5,
                        explosiveBoost: 1.5,
                        absorbingFactor: 0.5,
                        minSeparationVelocity: 0,
                        collisionCooldown: 0,
                        showCollisionPoints: false,
                        modeSpecificEffects: true
                    },
                    motionTrails: true,
                    collisionEffects: true,
                    particleEffects: true,
                    glowEffect: true,
                    spacetimeFabric: false,
                    fabricIntensity: 1,
                    fabricDensity: 12,
                    fabricOpacity: 0.4,
                    autoRespawn: false,
                    eliminationMode: true,
                    lineStealing: true,
                    linesEnabled: true,
                    powerUps: false,
                    chainsawMode: {
                        enabled: false,
                        livesMode: false,
                        startingLives: 5,
                        maxSawsOnMap: 2,
                        sawSpawnInterval: 5,
                        initialSawDelay: 3,
                        sawBehavior: "single-hit",
                        sawCharges: 3,
                        sawDuration: 15,
                        sawClashBehavior: "both-break",
                        enabledSawTypes: {
                            standard: true,
                            heavy: true,
                            light: true,
                            vortex: true,
                            emp: true
                        }
                    },
                    isPaused: false
                }
            },
            
            orbitalDance: {
                name: 'Orbital Dance',
                description: 'Center gravity with elastic connections',
                badge: 'physics',
                features: ['5 Balls', 'Center Gravity', 'Elastic', 'Spacetime'],
                config: {
                    ballCount: 5,
                    ballRadius: 14,
                    ballSpeed: 200,
                    speedMultiplier: 1,
                    colors: COLOR_THEMES.ocean.palettes[8],
                    currentTheme: "ocean",
                    currentColorCount: 8,
                    circleRadiusRatio: 0.35,
                    lineOpacity: 0.5,
                    lineWidth: 2,
                    accelerateWithLines: false,
                    accelerationPerLine: 0.05,
                    gravityMode: "center",
                    gravityIntensity: 400,
                    gravityMass: 1.5,
                    gravityDamping: 0.998,
                    elasticLines: true,
                    collisionDamping: false,
                    dampingFactor: 0.9,
                    collision: {
                        enabled: true,
                        ballToBallEnabled: true,
                        ballToWallEnabled: true,
                        restitution: 0.9,
                        friction: 0,
                        normalForceBoost: 0.9,
                        preserveSpeedMagnitude: false,
                        mode: "normal",
                        stickyDuration: 0.5,
                        explosiveBoost: 1.5,
                        absorbingFactor: 0.5,
                        minSeparationVelocity: 0,
                        collisionCooldown: 0,
                        showCollisionPoints: false,
                        modeSpecificEffects: true
                    },
                    motionTrails: true,
                    collisionEffects: true,
                    particleEffects: false,
                    glowEffect: true,
                    spacetimeFabric: true,
                    fabricIntensity: 1.2,
                    fabricDensity: 14,
                    fabricOpacity: 0.6,
                    autoRespawn: false,
                    eliminationMode: false,
                    lineStealing: false,
                    linesEnabled: false,
                    powerUps: false,
                    chainsawMode: {
                        enabled: false,
                        livesMode: false,
                        startingLives: 5,
                        maxSawsOnMap: 2,
                        sawSpawnInterval: 5,
                        initialSawDelay: 3,
                        sawBehavior: "single-hit",
                        sawCharges: 3,
                        sawDuration: 15,
                        sawClashBehavior: "both-break",
                        enabledSawTypes: {
                            standard: true,
                            heavy: true,
                            light: true,
                            vortex: true,
                            emp: true
                        }
                    },
                    isPaused: false
                }
            },
            
            heavyArtillery: {
                name: 'Heavy Artillery',
                description: 'Massive spheres with powerful gravitational influence',
                badge: 'physics',
                features: ['3 Balls', 'Large Size', 'Strong Gravity', 'Slow'],
                config: {
                    ballCount: 3,
                    ballRadius: 26,
                    ballSpeed: 120,
                    speedMultiplier: 0.6,
                    colors: COLOR_THEMES.retro.palettes[4],
                    currentTheme: "retro",
                    currentColorCount: 4,
                    circleRadiusRatio: 0.28,
                    lineOpacity: 0.5,
                    lineWidth: 3,
                    accelerateWithLines: false,
                    accelerationPerLine: 0.05,
                    gravityMode: "mutual",
                    gravityIntensity: 500,
                    gravityMass: 5,
                    gravityDamping: 0.99,
                    elasticLines: false,
                    collisionDamping: true,
                    dampingFactor: 0.85,
                    collision: {
                        enabled: true,
                        ballToBallEnabled: true,
                        ballToWallEnabled: true,
                        restitution: 0.8,
                        friction: 0.1,
                        normalForceBoost: 1.5,
                        preserveSpeedMagnitude: false,
                        mode: "normal",
                        stickyDuration: 0.5,
                        explosiveBoost: 1.5,
                        absorbingFactor: 0.5,
                        minSeparationVelocity: 0,
                        collisionCooldown: 0,
                        showCollisionPoints: false,
                        modeSpecificEffects: true
                    },
                    motionTrails: false,
                    collisionEffects: true,
                    particleEffects: true,
                    glowEffect: false,
                    spacetimeFabric: true,
                    fabricIntensity: 2,
                    fabricDensity: 10,
                    fabricOpacity: 0.7,
                    autoRespawn: false,
                    eliminationMode: false,
                    lineStealing: false,
                    linesEnabled: false,
                    powerUps: false,
                    chainsawMode: {
                        enabled: false,
                        livesMode: false,
                        startingLives: 5,
                        maxSawsOnMap: 2,
                        sawSpawnInterval: 5,
                        initialSawDelay: 3,
                        sawBehavior: "single-hit",
                        sawCharges: 3,
                        sawDuration: 15,
                        sawClashBehavior: "both-break",
                        enabledSawTypes: {
                            standard: true,
                            heavy: true,
                            light: true,
                            vortex: true,
                            emp: true
                        }
                    },
                    isPaused: false
                }
            },
            
            particleStorm: {
                name: 'Particle Storm',
                description: 'Many small particles creating visual spectacle',
                badge: 'chaos',
                features: ['20 Balls', 'Small', 'Particles', 'Visual'],
                config: {
                    ballCount: 20,
                    ballRadius: 6,
                    ballSpeed: 200,
                    speedMultiplier: 1.2,
                    colors: COLOR_THEMES.cyberpunk.palettes[32],
                    currentTheme: "cyberpunk",
                    currentColorCount: 32,
                    circleRadiusRatio: 0.42,
                    lineOpacity: 0.4,
                    lineWidth: 1,
                    accelerateWithLines: false,
                    accelerationPerLine: 0.05,
                    gravityMode: "none",
                    gravityIntensity: 100,
                    gravityMass: 0.5,
                    gravityDamping: 1,
                    elasticLines: false,
                    collisionDamping: false,
                    dampingFactor: 0.9,
                    collision: {
                        enabled: true,
                        ballToBallEnabled: true,
                        ballToWallEnabled: true,
                        restitution: 1,
                        friction: 0,
                        normalForceBoost: 0.8,
                        preserveSpeedMagnitude: false,
                        mode: "normal",
                        stickyDuration: 0.5,
                        explosiveBoost: 1.5,
                        absorbingFactor: 0.5,
                        minSeparationVelocity: 0,
                        collisionCooldown: 0,
                        showCollisionPoints: false,
                        modeSpecificEffects: true
                    },
                    motionTrails: true,
                    collisionEffects: true,
                    particleEffects: true,
                    glowEffect: true,
                    spacetimeFabric: false,
                    fabricIntensity: 1,
                    fabricDensity: 12,
                    fabricOpacity: 0.4,
                    autoRespawn: true,
                    eliminationMode: false,
                    lineStealing: false,
                    linesEnabled: false,
                    powerUps: false,
                    chainsawMode: {
                        enabled: false,
                        livesMode: false,
                        startingLives: 5,
                        maxSawsOnMap: 2,
                        sawSpawnInterval: 5,
                        initialSawDelay: 3,
                        sawBehavior: "single-hit",
                        sawCharges: 3,
                        sawDuration: 15,
                        sawClashBehavior: "both-break",
                        enabledSawTypes: {
                            standard: true,
                            heavy: true,
                            light: true,
                            vortex: true,
                            emp: true
                        }
                    },
                    isPaused: false
                }
            },
            
            stickyMadness: {
                name: 'Sticky Madness',
                description: 'Balls stick together then bounce away dramatically',
                badge: 'chaos',
                features: ['8 Balls', 'Sticky', 'Elastic', 'Unpredictable'],
                config: {
                    ballCount: 8,
                    ballRadius: 11,
                    ballSpeed: 190,
                    speedMultiplier: 1,
                    colors: COLOR_THEMES.candy.palettes[8],
                    currentTheme: "candy",
                    currentColorCount: 8,
                    circleRadiusRatio: 0.36,
                    lineOpacity: 0.6,
                    lineWidth: 2,
                    accelerateWithLines: false,
                    accelerationPerLine: 0.05,
                    gravityMode: "none",
                    gravityIntensity: 100,
                    gravityMass: 1,
                    gravityDamping: 1,
                    elasticLines: true,
                    collisionDamping: false,
                    dampingFactor: 0.9,
                    collision: {
                        enabled: true,
                        ballToBallEnabled: true,
                        ballToWallEnabled: true,
                        restitution: 1.2,
                        friction: 0,
                        normalForceBoost: 1.4,
                        preserveSpeedMagnitude: false,
                        mode: "sticky",
                        stickyDuration: 0.8,
                        explosiveBoost: 1.5,
                        absorbingFactor: 0.5,
                        minSeparationVelocity: 0,
                        collisionCooldown: 0,
                        showCollisionPoints: false,
                        modeSpecificEffects: true
                    },
                    motionTrails: false,
                    collisionEffects: true,
                    particleEffects: true,
                    glowEffect: false,
                    spacetimeFabric: false,
                    fabricIntensity: 1,
                    fabricDensity: 12,
                    fabricOpacity: 0.4,
                    autoRespawn: false,
                    eliminationMode: false,
                    lineStealing: false,
                    linesEnabled: false,
                    powerUps: false,
                    chainsawMode: {
                        enabled: false,
                        livesMode: false,
                        startingLives: 5,
                        maxSawsOnMap: 2,
                        sawSpawnInterval: 5,
                        initialSawDelay: 3,
                        sawBehavior: "single-hit",
                        sawCharges: 3,
                        sawDuration: 15,
                        sawClashBehavior: "both-break",
                        enabledSawTypes: {
                            standard: true,
                            heavy: true,
                            light: true,
                            vortex: true,
                            emp: true
                        }
                    },
                    isPaused: false
                }
            }
        };

        /**
         * CONFIGURATION
         */
        const CONFIG = {
            ballCount: 4,
            ballRadius: 12,
            ballSpeed: 220,
            speedMultiplier: 1.0,
            colors: COLOR_THEMES.classic.palettes[4],
            currentTheme: 'classic',
            currentColorCount: 4,
            circleRadiusRatio: 0.35,
            lineOpacity: 0.6,
            lineWidth: 2,
            
            // Physics
            accelerateWithLines: false,
            accelerationPerLine: 0.05,
            gravityMode: 'none', // 'none', 'center', 'mutual', 'down'
            gravityIntensity: 100,
            gravityMass: 1.0,
            gravityDamping: 1.0,
            elasticLines: false,
            collisionDamping: false,
            dampingFactor: 0.9,
            
            // Advanced Collision System
            collision: {
                // Enable/Disable
                enabled: true,
                ballToBallEnabled: true,
                ballToWallEnabled: true,
                
                // Basic Physics
                restitution: 1.0,              // Elasticity coefficient (0.0 - 2.0)
                friction: 0.0,                  // Tangential friction (0.0 - 1.0)
                normalForceBoost: 1.0,          // Normal force multiplier (0.5 - 5.0)
                
                // Speed Preservation
                preserveSpeedMagnitude: false,  // Keep speed magnitude on collision
                
                // Special Modes
                mode: 'normal',                 // 'normal', 'sticky', 'explosive', 'absorbing', 'phase'
                stickyDuration: 0.5,            // Duration for sticky collisions (seconds)
                explosiveBoost: 1.5,            // Energy multiplier for explosive mode
                absorbingFactor: 0.5,           // Momentum transfer rate
                
                // Advanced
                minSeparationVelocity: 0,       // Minimum relative velocity for collision
                collisionCooldown: 0.0,         // Cooldown between collisions (seconds)
                
                // Visual Effects
                showCollisionPoints: false,     // Debug visualization
                modeSpecificEffects: true       // Enable mode-specific particles
            },
            
            // Visual
            motionTrails: false,
            collisionEffects: true,
            particleEffects: true,
            glowEffect: false,
            
            // Spacetime Fabric Visualization
            spacetimeFabric: false,
            fabricIntensity: 1.0,
            fabricDensity: 12,          // Grid lines count
            fabricOpacity: 0.4,
            
            // Game Modes
            autoRespawn: false,
            eliminationMode: true,
            lineStealing: true,
            linesEnabled: true, // Enable/disable the entire line system
            powerUps: false,
            
            // Chainsaw Mode Configuration
            chainsawMode: {
                enabled: false,
                livesMode: false,
                startingLives: 5,
                maxSawsOnMap: 2,
                sawSpawnInterval: 5,  // seconds
                initialSawDelay: 3,   // seconds
                sawBehavior: 'single-hit', // 'single-hit', 'durability', 'timed'
                sawCharges: 3,
                sawDuration: 15, // seconds
                sawClashBehavior: 'both-break', // 'both-break', 'ricochet', 'null'
                enabledSawTypes: {
                    standard: true,
                    heavy: true,
                    light: true,
                    vortex: true,
                    emp: true
                }
            },
            
            // State
            isPaused: false
        };

        /**
         * STATE
         */
        const state = {
            canvas: null,
            ctx: null,
            width: 0,
            height: 0,
            dpr: 1,
            centerX: 0,
            centerY: 0,
            mainRadius: 0,
            balls: [],
            lines: [],
            particles: [],
            effects: [],
            trails: [],
            powerups: [],
            saws: [], // Serras no mapa
            sawSpawnTimer: 0,
            sawSpawnDelay: 2, // Segundos para spawnar nova serra
            collisionManager: null, // Advanced collision system
            spacetimeFabric: null, // Spacetime fabric visualization
            lastTime: 0,
            frameCount: 0,
            fps: 60,
            fpsTime: 0,
            currentPreset: 'classicArena', // Track active preset
            isLoadingPreset: false // Flag to prevent triggering personalized during preset load
        };

        /**
         * CLASSES
         */
        
        /**
         * SPACETIME FABRIC VISUALIZATION
         * Dynamic grid system that visualizes gravity influence as curved spacetime
         */
        class SpacetimeFabric {
            constructor() {
                this.gridLines = [];
                this.enabled = false;
                this.intensity = 1.0;
                this.density = 12;
                this.opacity = 0.4;
            }

            /**
             * Generate grid structure based on gravity mode
             */
            generateGrid(centerX, centerY, radius, mode) {
                this.gridLines = [];
                
                switch(mode) {
                    case 'center':
                        this.generateCenterModeGrid(centerX, centerY, radius);
                        break;
                    case 'mutual':
                        this.generateMutualModeGrid(centerX, centerY, radius);
                        break;
                    case 'down':
                        this.generateDownModeGrid(centerX, centerY, radius);
                        break;
                    case 'none':
                        this.generateFlatGrid(centerX, centerY, radius);
                        break;
                }
            }

            /**
             * Center Mode: Concentric circles showing radial gravity field
             */
            generateCenterModeGrid(centerX, centerY, radius) {
                const rings = this.density;
                
                // Concentric circles
                for (let i = 1; i <= rings; i++) {
                    const r = (radius / rings) * i;
                    const points = Math.max(32, Math.floor(r / 10)); // More points for larger circles
                    
                    const ring = [];
                    for (let j = 0; j < points; j++) {
                        const angle = (Math.PI * 2 / points) * j;
                        ring.push({
                            x: centerX + Math.cos(angle) * r,
                            y: centerY + Math.sin(angle) * r,
                            baseX: centerX + Math.cos(angle) * r,
                            baseY: centerY + Math.sin(angle) * r,
                            r: r,
                            angle: angle
                        });
                    }
                    this.gridLines.push({ type: 'ring', points: ring, radius: r });
                }
                
                // Radial lines
                const spokes = this.density;
                for (let i = 0; i < spokes; i++) {
                    const angle = (Math.PI * 2 / spokes) * i;
                    const points = [];
                    const segments = 20;
                    
                    for (let j = 0; j <= segments; j++) {
                        const r = (radius / segments) * j;
                        points.push({
                            x: centerX + Math.cos(angle) * r,
                            y: centerY + Math.sin(angle) * r,
                            baseX: centerX + Math.cos(angle) * r,
                            baseY: centerY + Math.sin(angle) * r,
                            r: r,
                            angle: angle
                        });
                    }
                    this.gridLines.push({ type: 'spoke', points: points, angle: angle });
                }
            }

            /**
             * Mutual Mode: Rectangular grid that deforms around balls
             */
            generateMutualModeGrid(centerX, centerY, radius) {
                const divisions = this.density;
                const size = radius * 2;
                const step = size / divisions;
                
                // Horizontal lines
                for (let i = 0; i <= divisions; i++) {
                    const y = centerY - radius + i * step;
                    const points = [];
                    
                    for (let j = 0; j <= divisions * 2; j++) {
                        const x = centerX - radius + j * (step / 2);
                        points.push({
                            x: x,
                            y: y,
                            baseX: x,
                            baseY: y,
                            deformation: 0
                        });
                    }
                    this.gridLines.push({ type: 'horizontal', points: points });
                }
                
                // Vertical lines
                for (let i = 0; i <= divisions * 2; i++) {
                    const x = centerX - radius + i * (step / 2);
                    const points = [];
                    
                    for (let j = 0; j <= divisions; j++) {
                        const y = centerY - radius + j * step;
                        points.push({
                            x: x,
                            y: y,
                            baseX: x,
                            baseY: y,
                            deformation: 0
                        });
                    }
                    this.gridLines.push({ type: 'vertical', points: points });
                }
            }

            /**
             * Down Mode: Horizontal lines showing downward gravity field
             */
            generateDownModeGrid(centerX, centerY, radius) {
                const lines = this.density;
                const size = radius * 2;
                const step = size / lines;
                
                // Horizontal lines with many segments for smooth curves
                for (let i = 0; i <= lines; i++) {
                    const y = centerY - radius + i * step;
                    const points = [];
                    const segments = 40;
                    
                    for (let j = 0; j <= segments; j++) {
                        const x = centerX - radius + (size / segments) * j;
                        points.push({
                            x: x,
                            y: y,
                            baseX: x,
                            baseY: y,
                            heightFactor: i / lines // 0 at top, 1 at bottom
                        });
                    }
                    this.gridLines.push({ type: 'horizontal', points: points });
                }
                
                // Vertical reference lines (fewer, just for reference)
                const vLines = Math.floor(this.density / 2);
                for (let i = 0; i <= vLines; i++) {
                    const x = centerX - radius + i * (size / vLines);
                    const points = [];
                    const segments = 20;
                    
                    for (let j = 0; j <= segments; j++) {
                        const y = centerY - radius + (size / segments) * j;
                        points.push({
                            x: x,
                            y: y,
                            baseX: x,
                            baseY: y
                        });
                    }
                    this.gridLines.push({ type: 'vertical', points: points });
                }
            }

            /**
             * None Mode: Flat reference grid
             */
            generateFlatGrid(centerX, centerY, radius) {
                const divisions = this.density;
                const size = radius * 2;
                const step = size / divisions;
                
                // Simple horizontal lines
                for (let i = 0; i <= divisions; i++) {
                    const y = centerY - radius + i * step;
                    const points = [
                        { x: centerX - radius, y: y, baseX: centerX - radius, baseY: y },
                        { x: centerX + radius, y: y, baseX: centerX + radius, baseY: y }
                    ];
                    this.gridLines.push({ type: 'horizontal', points: points });
                }
                
                // Simple vertical lines
                for (let i = 0; i <= divisions; i++) {
                    const x = centerX - radius + i * step;
                    const points = [
                        { x: x, y: centerY - radius, baseX: x, baseY: centerY - radius },
                        { x: x, y: centerY + radius, baseX: x, baseY: centerY + radius }
                    ];
                    this.gridLines.push({ type: 'vertical', points: points });
                }
            }

            /**
             * Update deformations based on current ball positions and gravity
             */
            updateDeformations(balls, centerX, centerY, radius, mode, intensity) {
                if (!this.enabled || mode === 'none') return;
                
                const activeBalls = balls.filter(b => b.status === 'alive');
                
                switch(mode) {
                    case 'center':
                        this.deformCenterMode(centerX, centerY, intensity);
                        break;
                    case 'mutual':
                        this.deformMutualMode(activeBalls, centerX, centerY, radius, intensity);
                        break;
                    case 'down':
                        this.deformDownMode(activeBalls, centerX, centerY, radius, intensity);
                        break;
                }
            }

            /**
             * Center Mode: Create depression toward center
             */
            deformCenterMode(centerX, centerY, intensity) {
                const maxDepth = 30 * intensity;
                
                this.gridLines.forEach(line => {
                    line.points.forEach(point => {
                        const distFromCenter = point.r;
                        const maxDist = Math.max(...this.gridLines
                            .filter(l => l.type === 'ring')
                            .map(l => l.radius));
                        
                        // Inverse square-like depression (stronger at center)
                        const normalizedDist = distFromCenter / maxDist;
                        const depression = maxDepth * (1 - normalizedDist) * (1 - normalizedDist);
                        
                        // Apply depression perpendicular to surface (toward center)
                        const dx = point.baseX - centerX;
                        const dy = point.baseY - centerY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            point.x = point.baseX - (dx / dist) * depression;
                            point.y = point.baseY - (dy / dist) * depression;
                        }
                    });
                });
            }

            /**
             * Mutual Mode: Create wells around each ball
             */
            deformMutualMode(balls, centerX, centerY, radius, intensity) {
                this.gridLines.forEach(line => {
                    line.points.forEach(point => {
                        // Reset to base position
                        point.x = point.baseX;
                        point.y = point.baseY;
                        
                        // Accumulate deformations from all balls
                        let totalDx = 0;
                        let totalDy = 0;
                        
                        balls.forEach(ball => {
                            const dx = point.baseX - ball.x;
                            const dy = point.baseY - ball.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist > 1) {
                                // Gravitational well depth based on mass and distance
                                const influence = (ball.mass * 15 * intensity) / Math.sqrt(dist);
                                const maxInfluence = 50; // Cap maximum deformation
                                const cappedInfluence = Math.min(influence, maxInfluence);
                                
                                totalDx -= (dx / dist) * cappedInfluence;
                                totalDy -= (dy / dist) * cappedInfluence;
                            }
                        });
                        
                        point.x += totalDx;
                        point.y += totalDy;
                        point.deformation = Math.sqrt(totalDx * totalDx + totalDy * totalDy);
                    });
                });
            }

            /**
             * Down Mode: Curved lines showing uniform downward field
             */
            deformDownMode(balls, centerX, centerY, radius, intensity) {
                const maxCurve = 25 * intensity;
                
                this.gridLines.forEach(line => {
                    if (line.type === 'horizontal') {
                        line.points.forEach((point, idx) => {
                            // Parabolic curve - stronger in the middle
                            const normalizedX = (point.baseX - (centerX - radius)) / (radius * 2);
                            const curveFactor = 4 * normalizedX * (1 - normalizedX); // Parabola
                            
                            // Base downward curvature
                            const baseCurve = curveFactor * maxCurve * (point.heightFactor || 0);
                            point.y = point.baseY + baseCurve;
                            
                            // Additional deformation near balls
                            balls.forEach(ball => {
                                const dx = point.baseX - ball.x;
                                const dy = point.baseY - ball.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                if (dist > 1 && dist < 100) {
                                    const influence = (ball.mass * 8 * intensity) / dist;
                                    point.y += Math.min(influence, 15);
                                }
                            });
                        });
                    } else if (line.type === 'vertical') {
                        // Vertical lines also curve slightly
                        line.points.forEach(point => {
                            const normalizedY = (point.baseY - (centerY - radius)) / (radius * 2);
                            const curveFactor = normalizedY * normalizedY; // Quadratic
                            point.y = point.baseY + curveFactor * maxCurve * 0.3;
                        });
                    }
                });
            }

            /**
             * Render the spacetime fabric
             */
            draw(ctx, centerX, centerY, radius, mode) {
                if (!this.enabled || this.gridLines.length === 0) return;
                
                ctx.save();
                
                // Clip to circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.clip();
                
                // Draw grid lines
                this.gridLines.forEach(line => {
                    if (line.points.length < 2) return;
                    
                    ctx.beginPath();
                    ctx.moveTo(line.points[0].x, line.points[0].y);
                    
                    for (let i = 1; i < line.points.length; i++) {
                        ctx.lineTo(line.points[i].x, line.points[i].y);
                    }
                    
                    // Color based on mode
                    let color;
                    switch(mode) {
                        case 'center':
                            color = 'rgba(102, 126, 234, '; // Purple-blue
                            break;
                        case 'mutual':
                            color = 'rgba(126, 234, 180, '; // Green-cyan
                            break;
                        case 'down':
                            color = 'rgba(234, 126, 102, '; // Orange-red
                            break;
                        default:
                            color = 'rgba(255, 255, 255, ';
                    }
                    
                    // Variable opacity based on deformation (for mutual mode)
                    let opacity = this.opacity;
                    if (mode === 'mutual' && line.points[0].deformation !== undefined) {
                        const avgDeformation = line.points.reduce((sum, p) => sum + (p.deformation || 0), 0) / line.points.length;
                        opacity = this.opacity + Math.min(avgDeformation / 50, 0.3);
                    }
                    
                    ctx.strokeStyle = color + opacity + ')';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
                
                // Add glow effect if enabled
                if (CONFIG.glowEffect) {
                    ctx.globalCompositeOperation = 'screen';
                    ctx.globalAlpha = 0.3;
                    
                    this.gridLines.forEach(line => {
                        if (line.points.length < 2) return;
                        
                        ctx.beginPath();
                        ctx.moveTo(line.points[0].x, line.points[0].y);
                        
                        for (let i = 1; i < line.points.length; i++) {
                            ctx.lineTo(line.points[i].x, line.points[i].y);
                        }
                        
                        let color;
                        switch(mode) {
                            case 'center':
                                color = 'rgba(102, 126, 234, 0.5)';
                                break;
                            case 'mutual':
                                color = 'rgba(126, 234, 180, 0.5)';
                                break;
                            case 'down':
                                color = 'rgba(234, 126, 102, 0.5)';
                                break;
                            default:
                                color = 'rgba(255, 255, 255, 0.3)';
                        }
                        
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = color;
                        ctx.stroke();
                    });
                    
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.globalAlpha = 1.0;
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            }

            /**
             * Update grid parameters
             */
            updateSettings(enabled, intensity, density, opacity) {
                this.enabled = enabled;
                this.intensity = intensity;
                this.density = density;
                this.opacity = opacity;
            }
        }
        
        class Ball {
            constructor(id, color, x, y, vx, vy) {
                this.id = id;
                this.color = color;
                this.originalColor = color;
                this.radius = CONFIG.ballRadius;
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.mass = 1;
                this.status = 'alive';
                this.hasEverHadLine = false;
                this.lineCount = 0;
                this.speedBoost = 1.0;
                this.trail = [];
                this.maxTrailLength = 20;
                this.equippedSaw = null; // Serra equipada
                this.lives = CONFIG.chainsawMode.startingLives;
                this.maxLives = CONFIG.chainsawMode.startingLives;
                this.invulnerable = false; // Invulnerabilidade temporria aps ser atingido
                this.invulnerableTime = 0;
                this.stunned = false; // Atordoamento do EMP
                this.stunnedTime = 0;
                this.speedModifier = 1.0; // Modificador de velocidade (Heavy Saw)
                
                // Collision System Properties
                this.stuckWith = null;              // Reference to stuck ball (sticky mode)
                this.stuckTime = 0;                 // Remaining stick duration
                this.collisionFlash = 0;            // Flash intensity for visual feedback
                this.lastCollisionColor = null;     // Color of last collision partner
                this.collisionCount = 0;            // Total collisions counter
            }

            update(dt) {
                if (this.status !== 'alive' || CONFIG.isPaused) return;

                // Update invulnerability
                if (this.invulnerable) {
                    this.invulnerableTime -= dt;
                    if (this.invulnerableTime <= 0) {
                        this.invulnerable = false;
                        this.invulnerableTime = 0;
                    }
                }

                // Update stun effect (EMP)
                if (this.stunned) {
                    this.stunnedTime -= dt;
                    if (this.stunnedTime <= 0) {
                        this.stunned = false;
                        this.stunnedTime = 0;
                        this.speedModifier = 1.0;
                    }
                }
                
                // Update collision flash
                if (this.collisionFlash > 0) {
                    this.collisionFlash -= dt * 3;
                    if (this.collisionFlash < 0) this.collisionFlash = 0;
                }
                
                // Update stuck state (sticky collision mode)
                if (this.stuckWith && this.stuckTime > 0) {
                    this.stuckTime -= dt;
                    if (this.stuckTime <= 0) {
                        this.stuckWith = null;
                        this.stuckTime = 0;
                    }
                }

                // Apply speed boost from lines (only if lines are enabled)
                if (CONFIG.accelerateWithLines && CONFIG.linesEnabled && this.lineCount > 0) {
                    this.speedBoost = 1.0 + (this.lineCount * CONFIG.accelerationPerLine);
                } else {
                    this.speedBoost = 1.0;
                }

                const effectiveSpeed = CONFIG.speedMultiplier * this.speedBoost * this.speedModifier;

                // Apply gravity based on selected mode
                if (CONFIG.gravityMode === 'center') {
                    // Gravity towards center of map
                    const dx = state.centerX - this.x;
                    const dy = state.centerY - this.y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);
                    if (dist > 1) { // Avoid division by very small numbers
                        // Force formula: F = G * m / d (linear, not quadratic for better control)
                        const force = (CONFIG.gravityIntensity * this.mass * 4.0) / dist;
                        this.vx += (dx / dist) * force * dt;
                        this.vy += (dy / dist) * force * dt;
                    }
                } else if (CONFIG.gravityMode === 'down') {
                    // Downward gravity (Earth-like)
                    // Scale down the intensity for more controllable gravity
                    const gravityAcceleration = (CONFIG.gravityIntensity * this.mass) * 0.5;
                    this.vy += gravityAcceleration * dt;
                    // Apply velocity damping for downward gravity
                    this.vx *= CONFIG.gravityDamping;
                    this.vy *= CONFIG.gravityDamping;
                }
                // Note: 'mutual' gravity is handled in the main update loop

                // Update position
                this.x += this.vx * effectiveSpeed * dt;
                this.y += this.vy * effectiveSpeed * dt;

                // Update equipped saw
                if (this.equippedSaw) {
                    this.equippedSaw.update(dt);
                }

                // Update trail
                if (CONFIG.motionTrails) {
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                } else {
                    this.trail = [];
                }
            }

            draw(ctx) {
                if (this.status !== 'alive') return;

                // Draw trail
                if (CONFIG.motionTrails && this.trail.length > 1) {
                    ctx.beginPath();
                    for (let i = 1; i < this.trail.length; i++) {
                        const alpha = i / this.trail.length * 0.3;
                        ctx.strokeStyle = this.color;
                        ctx.globalAlpha = alpha;
                        ctx.lineWidth = this.radius * (i / this.trail.length);
                        ctx.moveTo(this.trail[i - 1].x, this.trail[i - 1].y);
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1.0;
                }

                // Draw glow effect
                if (CONFIG.glowEffect) {
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 2);
                    gradient.addColorStop(0, this.color);
                    gradient.addColorStop(0.5, this.color + '40');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x - this.radius * 2, this.y - this.radius * 2, this.radius * 4, this.radius * 4);
                }
                
                // Draw collision flash effect
                if (this.collisionFlash > 0) {
                    const flashRadius = this.radius * (1 + this.collisionFlash * 0.5);
                    const gradient = ctx.createRadialGradient(this.x, this.y, this.radius * 0.5, this.x, this.y, flashRadius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, ' + (this.collisionFlash * 0.8) + ')');
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, ' + (this.collisionFlash * 0.3) + ')');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, flashRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Blink if invulnerable
                if (this.invulnerable && Math.floor(this.invulnerableTime * 10) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                // Electric effect if stunned (EMP)
                if (this.stunned) {
                    const electricGradient = ctx.createRadialGradient(this.x, this.y, this.radius * 0.5, this.x, this.y, this.radius * 1.5);
                    electricGradient.addColorStop(0, 'rgba(100, 200, 255, 0)');
                    electricGradient.addColorStop(0.5, 'rgba(100, 200, 255, ' + (0.3 + Math.sin(Date.now() * 0.02) * 0.2) + ')');
                    electricGradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
                    ctx.fillStyle = electricGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw ball (always behind the saw)
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // Draw border if has lines
                if (this.lineCount > 0) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Draw sticky indicator
                if (this.stuckWith && this.stuckTime > 0) {
                    ctx.strokeStyle = 'rgba(255, 200, 0, ' + (0.5 + Math.sin(Date.now() * 0.01) * 0.3) + ')';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Draw connection line to stuck ball
                    if (this.stuckWith.status === 'alive') {
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.stuckWith.x, this.stuckWith.y);
                        ctx.strokeStyle = 'rgba(255, 200, 0, 0.4)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
                
                ctx.closePath();
                ctx.globalAlpha = 1.0;

                // Draw equipped saw ON TOP of the ball (creating armor effect)
                if (this.equippedSaw) {
                    this.equippedSaw.draw(ctx);
                }

                // Draw lives indicator if chainsaw lives mode is enabled
                if (CONFIG.chainsawMode.enabled && CONFIG.chainsawMode.livesMode && this.lives < this.maxLives) {
                    const heartSize = 4;
                    const heartSpacing = 6;
                    const totalWidth = (this.maxLives * heartSpacing) - heartSpacing;
                    const startX = this.x - totalWidth / 2;
                    // Adjust position if saw is equipped (move further up)
                    const yOffset = this.equippedSaw ? (this.radius * 1.5 + 15) : (this.radius + 12);
                    const startY = this.y - yOffset;

                    for (let i = 0; i < this.maxLives; i++) {
                        const heartX = startX + i * heartSpacing;
                        ctx.beginPath();
                        ctx.arc(heartX, startY, heartSize / 2, 0, Math.PI * 2);
                        
                        if (i < this.lives) {
                            ctx.fillStyle = '#FF3030';
                        } else {
                            ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
                        }
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }

            die() {
                if (this.status !== 'alive') return;
                this.status = 'dying';

                if (CONFIG.particleEffects) {
                    const particleCount = 30;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 150 + 50;
                        const vx = Math.cos(angle) * speed;
                        const vy = Math.sin(angle) * speed;
                        const life = Math.random() * 0.8 + 0.4;
                        const radius = Math.random() * 3 + 1;
                        state.particles.push(new Particle(this.x, this.y, vx, vy, radius, this.color, life));
                    }
                }

                // Drop equipped saw
                this.equippedSaw = null;

                setTimeout(() => {
                    this.status = 'dead';
                    if (CONFIG.autoRespawn) {
                        this.respawn();
                    }
                }, 1200);
            }

            equipSaw(saw) {
                this.equippedSaw = new EquippedSaw(this, saw.type);
                saw.status = 'collected';
                
                // Apply saw-specific effects
                if (saw.type === 'heavy') {
                    this.speedModifier = 0.85; // 15% slower
                } else if (saw.type === 'light') {
                    this.speedModifier = 1.0; // No change
                }
            }

            takeDamage() {
                if (this.invulnerable) return false;

                if (CONFIG.chainsawMode.enabled && CONFIG.chainsawMode.livesMode) {
                    this.lives--;
                    this.invulnerable = true;
                    this.invulnerableTime = 1.0; // 1 segundo de invulnerabilidade

                    // Efeito visual de dano
                    if (CONFIG.particleEffects) {
                        const particleCount = 10;
                        for (let i = 0; i < particleCount; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 100 + 30;
                            const vx = Math.cos(angle) * speed;
                            const vy = Math.sin(angle) * speed;
                            const life = Math.random() * 0.4 + 0.2;
                            const radius = Math.random() * 2 + 1;
                            state.particles.push(new Particle(this.x, this.y, vx, vy, radius, '#FF3030', life));
                        }
                    }

                    if (this.lives <= 0) {
                        this.die();
                        return true;
                    }
                    return false;
                } else {
                    this.die();
                    return true;
                }
            }

            respawn() {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * (state.mainRadius - CONFIG.ballRadius * 3);
                this.x = state.centerX + Math.cos(angle) * r;
                this.y = state.centerY + Math.sin(angle) * r;
                const vAngle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(vAngle) * CONFIG.ballSpeed;
                this.vy = Math.sin(vAngle) * CONFIG.ballSpeed;
                this.status = 'alive';
                this.hasEverHadLine = false;
                this.lineCount = 0;
                this.speedBoost = 1.0;
                this.trail = [];
                this.equippedSaw = null;
                this.lives = this.maxLives;
                this.invulnerable = false;
                this.invulnerableTime = 0;
                this.stunned = false;
                this.stunnedTime = 0;
                this.speedModifier = 1.0;
            }
        }

        class ElasticLine {
            constructor(anchorAngle, ownerBall) {
                this.anchorAngle = anchorAngle;
                this.owner = ownerBall;
                this.pulse = 0;
                this.tension = CONFIG.elasticLines ? 0.5 : 0;
            }

            update(dt) {
                if (this.pulse > 0) {
                    this.pulse -= dt * 3;
                    if (this.pulse < 0) this.pulse = 0;
                }

                // Apply elastic force if enabled (only if lines system is enabled)
                if (CONFIG.elasticLines && CONFIG.linesEnabled && this.owner.status === 'alive' && this.tension > 0) {
                    const anchorPos = this.getAnchorPos(state.centerX, state.centerY, state.mainRadius);
                    const dx = anchorPos.x - this.owner.x;
                    const dy = anchorPos.y - this.owner.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0) {
                        const force = this.tension * 50 * dt;
                        this.owner.vx += (dx / dist) * force;
                        this.owner.vy += (dy / dist) * force;
                    }
                }
            }

            draw(ctx, cx, cy, r) {
                const anchorPos = this.getAnchorPos(cx, cy, r);
                
                // Draw line
                ctx.beginPath();
                ctx.moveTo(anchorPos.x, anchorPos.y);
                ctx.lineTo(this.owner.x, this.owner.y);
                ctx.strokeStyle = this.owner.color;
                ctx.globalAlpha = CONFIG.lineOpacity + this.pulse * 0.4;
                ctx.lineWidth = CONFIG.lineWidth + this.pulse * 3;
                ctx.stroke();
                ctx.globalAlpha = 1.0;
                ctx.closePath();

                // Draw anchor point
                ctx.beginPath();
                ctx.arc(anchorPos.x, anchorPos.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = this.owner.color;
                ctx.fill();
                ctx.closePath();
            }

            getAnchorPos(cx, cy, r) {
                return {
                    x: cx + Math.cos(this.anchorAngle) * r,
                    y: cy + Math.sin(this.anchorAngle) * r
                };
            }
        }

        class Particle {
            constructor(x, y, vx, vy, radius, color, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = radius;
                this.color = color;
                this.life = life;
                this.initialLife = life;
            }

            update(dt) {
                if (CONFIG.isPaused) return;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= dt;
            }

            draw(ctx) {
                const opacity = this.life / this.initialLife;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = Math.max(0, opacity);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.closePath();
            }
        }

        class VisualEffect {
            constructor(x, y, color, maxRadius, life) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = 0;
                this.maxRadius = maxRadius;
                this.life = life;
                this.initialLife = life;
            }

            update(dt) {
                if (CONFIG.isPaused) return;
                this.life -= dt;
                this.radius = this.maxRadius * (1 - (this.life / this.initialLife));
            }

            draw(ctx) {
                const opacity = this.life / this.initialLife;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2 * opacity;
                ctx.globalAlpha = Math.max(0, opacity);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
                ctx.closePath();
            }
        }

        /**
         * SAW TYPE DEFINITIONS
         * Defines characteristics for each saw type
         */
        const SAW_TYPES = {
            standard: {
                name: 'Standard Saw',
                radiusMultiplier: 1.0,
                rotationSpeed: 8,
                bladeCount: 8,
                bladeWidth: 0.2,
                colors: {
                    primary: '#FF3030',
                    secondary: '#FF6B6B',
                    dark: '#CC0000',
                    glow: 'rgba(255, 50, 50, 0.3)'
                },
                chargesBonus: 0,
                durationBonus: 0,
                speedModifier: 1.0,
                pushForce: 1.0
            },
            heavy: {
                name: 'Heavy Saw',
                radiusMultiplier: 1.3,
                rotationSpeed: 5,
                bladeCount: 10,
                bladeWidth: 0.3,
                colors: {
                    primary: '#8B4513',
                    secondary: '#A0522D',
                    dark: '#654321',
                    glow: 'rgba(139, 69, 19, 0.4)'
                },
                chargesBonus: 1,
                durationBonus: 5,
                speedModifier: 0.85,
                pushForce: 1.5
            },
            light: {
                name: 'Light Saw',
                radiusMultiplier: 0.8,
                rotationSpeed: 15,
                bladeCount: 6,
                bladeWidth: 0.15,
                colors: {
                    primary: '#00FFFF',
                    secondary: '#7FFFD4',
                    dark: '#00CED1',
                    glow: 'rgba(0, 255, 255, 0.4)'
                },
                chargesBonus: -2, // Only 1 hit
                durationBonus: 0,
                speedModifier: 1.0,
                pushForce: 0.8,
                speedBoost: 1.15 // Gives speed boost to user
            },
            vortex: {
                name: 'Vortex Saw',
                radiusMultiplier: 1.1,
                rotationSpeed: 10,
                bladeCount: 0, // No visible blades
                bladeWidth: 0,
                colors: {
                    primary: '#8A2BE2',
                    secondary: '#9370DB',
                    dark: '#6A0DAD',
                    glow: 'rgba(138, 43, 226, 0.5)'
                },
                chargesBonus: 0,
                durationBonus: -5,
                speedModifier: 1.0,
                pushForce: 0,
                vortexStrength: 50 // Pull strength
            },
            emp: {
                name: 'EMP Saw',
                radiusMultiplier: 1.0,
                rotationSpeed: 12,
                bladeCount: 0,
                bladeWidth: 0,
                colors: {
                    primary: '#00BFFF',
                    secondary: '#87CEEB',
                    dark: '#4169E1',
                    glow: 'rgba(0, 191, 255, 0.5)'
                },
                chargesBonus: 0,
                durationBonus: 0,
                speedModifier: 1.0,
                pushForce: 0,
                stunDuration: 2.0 // Stun duration in seconds
            }
        };

        class RotatingSaw {
            constructor(x, y, type = 'standard') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.typeData = SAW_TYPES[type];
                this.rotation = 0;
                this.rotationSpeed = this.typeData.rotationSpeed;
                this.bladeCount = this.typeData.bladeCount;
                this.status = 'spawned'; // spawned, collected
                this.pulsePhase = 0;
                this.spawnAnimation = 1.0; // Spawn animation progress
            }

            // Dynamic radius based on current ball size and type
            get radius() {
                return CONFIG.ballRadius * 0.8 * this.typeData.radiusMultiplier;
            }

            get innerRadius() {
                return this.radius * 0.3;
            }

            update(dt) {
                if (CONFIG.isPaused) return;
                this.rotation += this.rotationSpeed * dt;
                this.pulsePhase += dt * 3;
                
                // Spawn animation
                if (this.spawnAnimation > 0) {
                    this.spawnAnimation -= dt * 2;
                    if (this.spawnAnimation < 0) this.spawnAnimation = 0;
                }
            }

            draw(ctx) {
                if (this.status !== 'spawned') return;

                const pulse = Math.sin(this.pulsePhase) * 0.1 + 1;
                const drawRadius = this.radius * pulse;
                const spawnScale = 1.0 - this.spawnAnimation * 0.3;

                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Spawn animation effect
                if (this.spawnAnimation > 0) {
                    ctx.globalAlpha = 1.0 - this.spawnAnimation;
                    ctx.scale(spawnScale, spawnScale);
                }
                
                ctx.rotate(this.rotation);

                // Draw type-specific appearance
                switch(this.type) {
                    case 'vortex':
                        this.drawVortexSaw(ctx, drawRadius);
                        break;
                    case 'emp':
                        this.drawEMPSaw(ctx, drawRadius);
                        break;
                    default:
                        this.drawStandardSaw(ctx, drawRadius);
                }

                ctx.restore();
            }

            drawStandardSaw(ctx, drawRadius) {
                // Draw glow effect
                const gradient = ctx.createRadialGradient(0, 0, this.innerRadius, 0, 0, drawRadius * 1.5);
                gradient.addColorStop(0, this.typeData.colors.glow);
                gradient.addColorStop(0.5, this.typeData.colors.glow.replace('0.3', '0.15').replace('0.4', '0.2'));
                gradient.addColorStop(1, this.typeData.colors.glow.replace(/[\d.]+\)/, '0)'));
                ctx.fillStyle = gradient;
                ctx.fillRect(-drawRadius * 1.5, -drawRadius * 1.5, drawRadius * 3, drawRadius * 3);

                // Draw blades
                for (let i = 0; i < this.bladeCount; i++) {
                    const angle = (Math.PI * 2 / this.bladeCount) * i;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        Math.cos(angle) * this.innerRadius,
                        Math.sin(angle) * this.innerRadius
                    );
                    
                    const tipAngle1 = angle - this.typeData.bladeWidth;
                    const tipAngle2 = angle + this.typeData.bladeWidth;
                    
                    ctx.lineTo(
                        Math.cos(tipAngle1) * drawRadius,
                        Math.sin(tipAngle1) * drawRadius
                    );
                    ctx.lineTo(
                        Math.cos(angle) * drawRadius * 1.1,
                        Math.sin(angle) * drawRadius * 1.1
                    );
                    ctx.lineTo(
                        Math.cos(tipAngle2) * drawRadius,
                        Math.sin(tipAngle2) * drawRadius
                    );
                    ctx.closePath();
                    
                    // Gradient fill for blade
                    const bladeGradient = ctx.createLinearGradient(0, 0, Math.cos(angle) * drawRadius, Math.sin(angle) * drawRadius);
                    bladeGradient.addColorStop(0, this.typeData.colors.secondary);
                    bladeGradient.addColorStop(0.5, this.typeData.colors.primary);
                    bladeGradient.addColorStop(1, this.typeData.colors.dark);
                    ctx.fillStyle = bladeGradient;
                    ctx.fill();
                    
                    ctx.strokeStyle = this.typeData.colors.dark;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Draw center circle
                ctx.beginPath();
                ctx.arc(0, 0, this.innerRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#444';
                ctx.fill();
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw center detail
                ctx.beginPath();
                ctx.arc(0, 0, this.innerRadius * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = '#666';
                ctx.fill();
            }

            drawVortexSaw(ctx, drawRadius) {
                // Vortex spiral effect
                const spiralTurns = 3;
                const segments = 50;
                
                for (let t = 0; t < spiralTurns; t += 0.5) {
                    ctx.beginPath();
                    for (let i = 0; i <= segments; i++) {
                        const progress = i / segments;
                        const angle = t * Math.PI * 2 + progress * Math.PI * 2;
                        const radius = drawRadius * progress;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    const opacity = 0.6 - (t / spiralTurns) * 0.4;
                    ctx.strokeStyle = this.typeData.colors.primary.replace(')', ', ' + opacity + ')');
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Outer glow
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, drawRadius * 1.2);
                gradient.addColorStop(0, this.typeData.colors.glow);
                gradient.addColorStop(1, this.typeData.colors.glow.replace(/[\d.]+\)/, '0)'));
                ctx.fillStyle = gradient;
                ctx.fillRect(-drawRadius * 1.2, -drawRadius * 1.2, drawRadius * 2.4, drawRadius * 2.4);

                // Center orb
                ctx.beginPath();
                ctx.arc(0, 0, this.innerRadius, 0, Math.PI * 2);
                const orbGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.innerRadius);
                orbGradient.addColorStop(0, this.typeData.colors.secondary);
                orbGradient.addColorStop(1, this.typeData.colors.primary);
                ctx.fillStyle = orbGradient;
                ctx.fill();
            }

            drawEMPSaw(ctx, drawRadius) {
                // Electric ring effect
                const ringCount = 3;
                for (let i = 0; i < ringCount; i++) {
                    const radius = drawRadius * (0.4 + i * 0.3);
                    const opacity = 0.6 - i * 0.15;
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = this.typeData.colors.primary.replace(')', ', ' + opacity + ')');
                    ctx.lineWidth = 2 + Math.sin(this.pulsePhase + i) * 1;
                    ctx.stroke();
                }

                // Electric arcs
                const arcCount = 8;
                for (let i = 0; i < arcCount; i++) {
                    const angle = (Math.PI * 2 / arcCount) * i + this.rotation * 0.5;
                    const innerR = this.innerRadius;
                    const outerR = drawRadius * 0.9;
                    
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * innerR, Math.sin(angle) * innerR);
                    
                    // Zigzag line
                    const segments = 5;
                    for (let j = 1; j <= segments; j++) {
                        const progress = j / segments;
                        const r = innerR + (outerR - innerR) * progress;
                        const offset = (Math.random() - 0.5) * 0.3;
                        const x = Math.cos(angle + offset) * r;
                        const y = Math.sin(angle + offset) * r;
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.strokeStyle = this.typeData.colors.secondary.replace(')', ', 0.7)');
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }

                // Center energy core
                ctx.beginPath();
                ctx.arc(0, 0, this.innerRadius, 0, Math.PI * 2);
                const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.innerRadius);
                coreGradient.addColorStop(0, '#FFFFFF');
                coreGradient.addColorStop(0.5, this.typeData.colors.secondary);
                coreGradient.addColorStop(1, this.typeData.colors.primary);
                ctx.fillStyle = coreGradient;
                ctx.fill();
            }

            isCollidingWithBall(ball) {
                const dx = this.x - ball.x;
                const dy = this.y - ball.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                return dist < (this.radius + ball.radius);
            }
        }

        class EquippedSaw {
            constructor(ownerBall, type = 'standard') {
                this.owner = ownerBall;
                this.type = type;
                this.typeData = SAW_TYPES[type];
                this.rotation = 0;
                this.rotationSpeed = this.typeData.rotationSpeed;
                this.bladeCount = this.typeData.bladeCount;
                
                // Durability system
                const baseDurability = CONFIG.chainsawMode.sawBehavior === 'durability' ? 
                    CONFIG.chainsawMode.sawCharges : 1;
                this.charges = baseDurability + this.typeData.chargesBonus;
                this.charges = Math.max(1, this.charges); // Minimum 1 charge
                
                const baseDuration = CONFIG.chainsawMode.sawBehavior === 'timed' ? 
                    CONFIG.chainsawMode.sawDuration : 9999;
                this.duration = baseDuration + this.typeData.durationBonus;
                this.timeRemaining = this.duration;
                
                // Vortex-specific
                this.vortexPulse = 0;
            }

            // Dynamic radius based on owner's current size and type
            get radius() {
                return this.owner.radius * 1.5 * this.typeData.radiusMultiplier;
            }

            get innerRadius() {
                return this.owner.radius;
            }

            update(dt) {
                if (CONFIG.isPaused) return;
                this.rotation += this.rotationSpeed * dt;
                this.vortexPulse += dt * 4;
                
                // Update timed duration
                if (CONFIG.chainsawMode.sawBehavior === 'timed') {
                    this.timeRemaining -= dt;
                    if (this.timeRemaining <= 0) {
                        this.break();
                    }
                }
                
                // Vortex effect - pull nearby balls
                if (this.type === 'vortex') {
                    this.applyVortexEffect(dt);
                }
            }

            applyVortexEffect(dt) {
                const vortexRange = this.radius * 3;
                const aliveBalls = state.balls.filter(b => b.status === 'alive' && b.id !== this.owner.id);
                
                aliveBalls.forEach(ball => {
                    const dx = this.owner.x - ball.x;
                    const dy = this.owner.y - ball.y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);
                    
                    if (dist < vortexRange && dist > 1) {
                        const pullStrength = (this.typeData.vortexStrength / dist) * dt;
                        ball.vx += (dx / dist) * pullStrength;
                        ball.vy += (dy / dist) * pullStrength;
                    }
                });
            }

            useCharge() {
                if (CONFIG.chainsawMode.sawBehavior === 'durability') {
                    this.charges--;
                    if (this.charges <= 0) {
                        this.break();
                        return true;
                    }
                } else if (CONFIG.chainsawMode.sawBehavior === 'single-hit') {
                    this.break();
                    return true;
                }
                return false;
            }

            break() {
                // Break effect
                if (CONFIG.particleEffects) {
                    const particleCount = 20;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 200 + 50;
                        const vx = Math.cos(angle) * speed;
                        const vy = Math.sin(angle) * speed;
                        const life = Math.random() * 0.6 + 0.3;
                        const radius = Math.random() * 3 + 1;
                        state.particles.push(new Particle(
                            this.owner.x, 
                            this.owner.y, 
                            vx, 
                            vy, 
                            radius, 
                            this.typeData.colors.primary, 
                            life
                        ));
                    }
                }
                
                this.owner.equippedSaw = null;
                this.owner.speedModifier = 1.0; // Reset speed modifier
            }

            draw(ctx) {
                if (this.owner.status !== 'alive') return;

                const x = this.owner.x;
                const y = this.owner.y;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.rotation);

                // Draw type-specific appearance
                switch(this.type) {
                    case 'vortex':
                        this.drawEquippedVortex(ctx);
                        break;
                    case 'emp':
                        this.drawEquippedEMP(ctx);
                        break;
                    default:
                        this.drawEquippedStandard(ctx);
                }

                ctx.restore();
                
                // Draw durability indicator
                this.drawDurabilityIndicator(ctx);
            }

            drawEquippedStandard(ctx) {
                // Draw outer glow effect
                const glowGradient = ctx.createRadialGradient(0, 0, this.innerRadius, 0, 0, this.radius * 1.2);
                glowGradient.addColorStop(0, this.typeData.colors.glow.replace(/[\d.]+\)/, '0)'));
                glowGradient.addColorStop(0.7, this.typeData.colors.glow);
                glowGradient.addColorStop(1, this.typeData.colors.glow.replace(/[\d.]+\)/, '0)'));
                ctx.fillStyle = glowGradient;
                ctx.fillRect(-this.radius * 1.2, -this.radius * 1.2, this.radius * 2.4, this.radius * 2.4);

                // Draw blades extending from center
                for (let i = 0; i < this.bladeCount; i++) {
                    const angle = (Math.PI * 2 / this.bladeCount) * i;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        Math.cos(angle) * this.innerRadius * 0.8,
                        Math.sin(angle) * this.innerRadius * 0.8
                    );
                    
                    const tipAngle1 = angle - this.typeData.bladeWidth;
                    const tipAngle2 = angle + this.typeData.bladeWidth;
                    
                    ctx.lineTo(
                        Math.cos(tipAngle1) * this.radius,
                        Math.sin(tipAngle1) * this.radius
                    );
                    ctx.lineTo(
                        Math.cos(angle) * this.radius * 1.1,
                        Math.sin(angle) * this.radius * 1.1
                    );
                    ctx.lineTo(
                        Math.cos(tipAngle2) * this.radius,
                        Math.sin(tipAngle2) * this.radius
                    );
                    ctx.closePath();
                    
                    const bladeGradient = ctx.createLinearGradient(0, 0, Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                    bladeGradient.addColorStop(0, this.typeData.colors.secondary);
                    bladeGradient.addColorStop(0.5, this.typeData.colors.primary);
                    bladeGradient.addColorStop(1, this.typeData.colors.dark);
                    ctx.fillStyle = bladeGradient;
                    ctx.fill();
                    
                    ctx.strokeStyle = this.typeData.colors.dark;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Draw metallic ring around the ball
                ctx.beginPath();
                ctx.arc(0, 0, this.innerRadius * 0.85, 0, Math.PI * 2);
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            drawEquippedVortex(ctx) {
                // Animated vortex spirals
                const spiralCount = 4;
                const maxRadius = this.radius * 1.2;
                
                for (let s = 0; s < spiralCount; s++) {
                    const spiralOffset = (s / spiralCount) * Math.PI * 2;
                    ctx.beginPath();
                    
                    for (let i = 0; i <= 50; i++) {
                        const progress = i / 50;
                        const angle = spiralOffset + progress * Math.PI * 4 + this.vortexPulse * (s % 2 === 0 ? 1 : -1);
                        const r = this.innerRadius + (maxRadius - this.innerRadius) * progress;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    const opacity = 0.6 - (s / spiralCount) * 0.3;
                    ctx.strokeStyle = this.typeData.colors.primary.replace(')', ', ' + opacity + ')');
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Pulsing glow
                const glowSize = this.radius * 1.5 * (1 + Math.sin(this.vortexPulse) * 0.2);
                const glowGradient = ctx.createRadialGradient(0, 0, this.innerRadius, 0, 0, glowSize);
                glowGradient.addColorStop(0, this.typeData.colors.glow.replace(/[\d.]+\)/, '0.3)'));
                glowGradient.addColorStop(1, this.typeData.colors.glow.replace(/[\d.]+\)/, '0)'));
                ctx.fillStyle = glowGradient;
                ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
            }

            drawEquippedEMP(ctx) {
                // Electric ring pulses
                const pulseTime = Date.now() * 0.003;
                const ringCount = 4;
                
                for (let i = 0; i < ringCount; i++) {
                    const phase = (pulseTime + i * 0.3) % 1;
                    const radius = this.innerRadius + (this.radius - this.innerRadius) * phase;
                    const opacity = (1 - phase) * 0.7;
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = this.typeData.colors.primary.replace(')', ', ' + opacity + ')');
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Electric arcs
                const arcCount = 12;
                for (let i = 0; i < arcCount; i++) {
                    const angle = (Math.PI * 2 / arcCount) * i;
                    const innerR = this.innerRadius * 0.9;
                    const outerR = this.radius * 1.1;
                    
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * innerR, Math.sin(angle) * innerR);
                    
                    const segments = 4;
                    for (let j = 1; j <= segments; j++) {
                        const progress = j / segments;
                        const r = innerR + (outerR - innerR) * progress;
                        const offset = (Math.random() - 0.5) * 0.2;
                        const x = Math.cos(angle + offset) * r;
                        const y = Math.sin(angle + offset) * r;
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.strokeStyle = this.typeData.colors.secondary.replace(')', ', 0.6)');
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Energy field
                const fieldGradient = ctx.createRadialGradient(0, 0, this.innerRadius, 0, 0, this.radius * 1.3);
                fieldGradient.addColorStop(0, this.typeData.colors.glow.replace(/[\d.]+\)/, '0.2)'));
                fieldGradient.addColorStop(1, this.typeData.colors.glow.replace(/[\d.]+\)/, '0)'));
                ctx.fillStyle = fieldGradient;
                ctx.fillRect(-this.radius * 1.3, -this.radius * 1.3, this.radius * 2.6, this.radius * 2.6);
            }

            drawDurabilityIndicator(ctx) {
                const x = this.owner.x;
                const yOffset = this.radius + 8;
                const y = this.owner.y - yOffset;

                if (CONFIG.chainsawMode.sawBehavior === 'durability' && this.charges > 0) {
                    // Draw charge indicators
                    const maxCharges = CONFIG.chainsawMode.sawCharges + this.typeData.chargesBonus;
                    const dotSize = 3;
                    const dotSpacing = 7;
                    const totalWidth = (maxCharges * dotSpacing) - dotSpacing;
                    const startX = x - totalWidth / 2;

                    for (let i = 0; i < maxCharges; i++) {
                        const dotX = startX + i * dotSpacing;
                        ctx.beginPath();
                        ctx.arc(dotX, y, dotSize / 2, 0, Math.PI * 2);
                        
                        if (i < this.charges) {
                            ctx.fillStyle = this.typeData.colors.primary;
                        } else {
                            ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
                        }
                        ctx.fill();
                        ctx.closePath();
                    }
                } else if (CONFIG.chainsawMode.sawBehavior === 'timed' && this.timeRemaining > 0) {
                    // Draw timer bar
                    const barWidth = 30;
                    const barHeight = 4;
                    const barX = x - barWidth / 2;
                    const barY = y - barHeight / 2;
                    
                    // Background
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Progress
                    const progress = this.timeRemaining / this.duration;
                    const progressWidth = barWidth * progress;
                    ctx.fillStyle = this.typeData.colors.primary;
                    ctx.fillRect(barX, barY, progressWidth, barHeight);
                    
                    // Border
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
            }

            getPosition() {
                return {
                    x: this.owner.x,
                    y: this.owner.y
                };
            }

            isCollidingWithBall(otherBall) {
                const dx = this.owner.x - otherBall.x;
                const dy = this.owner.y - otherBall.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                return dist < (this.radius + otherBall.radius);
            }
        }

        /**
         * COLLISION MANAGER
         * Advanced collision system with multiple modes and customizable physics
         */
        class CollisionManager {
            constructor(config) {
                this.config = config;
                this.collisionPairs = new Map(); // Track collision cooldowns
                this.stats = {
                    totalCollisions: 0,
                    ballToBallCollisions: 0,
                    ballToWallCollisions: 0
                };
            }

            // Main update loop - updates cooldowns
            update(dt) {
                // Update collision cooldowns
                if (this.config.collisionCooldown > 0) {
                    for (let [key, value] of this.collisionPairs) {
                        const newValue = value - dt;
                        if (newValue <= 0) {
                            this.collisionPairs.delete(key);
                        } else {
                            this.collisionPairs.set(key, newValue);
                        }
                    }
                }
            }

            // Main collision resolution for ball-to-ball
            resolveBallCollision(b1, b2) {
                if (!this.config.enabled || !this.config.ballToBallEnabled) return;
                if (b1.status !== 'alive' || b2.status !== 'alive') return;
                
                // Check if stuck together (sticky mode)
                if (b1.stuckWith === b2 && b1.stuckTime > 0) return;
                
                // Check cooldown
                if (this.isInCooldown(b1, b2)) return;
                
                // Phase through mode - skip all collisions
                if (this.config.mode === 'phase') return;
                
                // Detect collision
                const collision = this.detectCollision(b1, b2);
                if (!collision.occurred) return;
                
                // Apply mode-specific behavior
                switch(this.config.mode) {
                    case 'normal':
                        this.normalCollision(b1, b2, collision);
                        break;
                    case 'sticky':
                        this.stickyCollision(b1, b2, collision);
                        break;
                    case 'explosive':
                        this.explosiveCollision(b1, b2, collision);
                        break;
                    case 'absorbing':
                        this.absorbingCollision(b1, b2, collision);
                        break;
                }
                
                // Visual feedback
                b1.collisionFlash = 1.0;
                b2.collisionFlash = 1.0;
                b1.lastCollisionColor = b2.color;
                b2.lastCollisionColor = b1.color;
                b1.collisionCount++;
                b2.collisionCount++;
                
                // Create visual effects
                if (CONFIG.collisionEffects) {
                    const midX = (b1.x + b2.x) / 2;
                    const midY = (b1.y + b2.y) / 2;
                    const effectColor = this.getModeColor();
                    state.effects.push(new VisualEffect(midX, midY, effectColor, 25, 0.4));
                }
                
                // Set cooldown
                this.setCollisionCooldown(b1, b2);
                
                // Update stats
                this.stats.totalCollisions++;
                this.stats.ballToBallCollisions++;
            }

            // Detect if two balls are colliding
            detectCollision(b1, b2) {
                const dx = b2.x - b1.x;
                const dy = b2.y - b1.y;
                const distSq = dx * dx + dy * dy;
                const minDist = b1.radius + b2.radius;
                
                return {
                    occurred: distSq < minDist * minDist && distSq > 0,
                    distance: Math.sqrt(distSq),
                    minDistance: minDist,
                    dx: dx,
                    dy: dy
                };
            }

            // Normal collision with full physics
            normalCollision(b1, b2, collision) {
                const { distance, minDistance, dx, dy } = collision;
                
                // Normal vector
                const nx = dx / distance;
                const ny = dy / distance;
                
                // Separate overlapping balls (with boost)
                const overlap = (minDistance - distance) * 0.51 * this.config.normalForceBoost;
                b1.x -= nx * overlap;
                b1.y -= ny * overlap;
                b2.x += nx * overlap;
                b2.y += ny * overlap;
                
                // Calculate relative velocity
                const dvx = b2.vx - b1.vx;
                const dvy = b2.vy - b1.vy;
                const relativeVelocity = dvx * nx + dvy * ny;
                
                // Check minimum separation velocity
                if (relativeVelocity > this.config.minSeparationVelocity) return;
                
                if (this.config.preserveSpeedMagnitude) {
                    // Preserve speed magnitude mode
                    this.preserveSpeedCollision(b1, b2, nx, ny);
                } else {
                    // Normal elastic collision with restitution
                    const impulse = -(1 + this.config.restitution) * relativeVelocity;
                    const totalInvMass = 1/b1.mass + 1/b2.mass;
                    const j = impulse / totalInvMass;
                    
                    b1.vx -= (j / b1.mass) * nx;
                    b1.vy -= (j / b1.mass) * ny;
                    b2.vx += (j / b2.mass) * nx;
                    b2.vy += (j / b2.mass) * ny;
                    
                    // Apply friction to tangential component
                    if (this.config.friction > 0) {
                        this.applyFriction(b1, b2, nx, ny);
                    }
                    
                    // Apply damping if enabled (legacy support)
                    if (CONFIG.collisionDamping) {
                        b1.vx *= CONFIG.dampingFactor;
                        b1.vy *= CONFIG.dampingFactor;
                        b2.vx *= CONFIG.dampingFactor;
                        b2.vy *= CONFIG.dampingFactor;
                    }
                }
            }

            // Preserve speed magnitude collision
            preserveSpeedCollision(b1, b2, nx, ny) {
                // Store original speeds
                const speed1 = Math.sqrt(b1.vx * b1.vx + b1.vy * b1.vy);
                const speed2 = Math.sqrt(b2.vx * b2.vx + b2.vy * b2.vy);
                
                // Calculate reflection
                const dot1 = b1.vx * nx + b1.vy * ny;
                const dot2 = b2.vx * nx + b2.vy * ny;
                
                // Reflect velocities
                b1.vx -= 2 * dot1 * nx;
                b1.vy -= 2 * dot1 * ny;
                b2.vx -= 2 * dot2 * nx;
                b2.vy -= 2 * dot2 * ny;
                
                // Normalize to preserve original speeds
                const newSpeed1 = Math.sqrt(b1.vx * b1.vx + b1.vy * b1.vy);
                const newSpeed2 = Math.sqrt(b2.vx * b2.vx + b2.vy * b2.vy);
                
                if (newSpeed1 > 0) {
                    b1.vx = (b1.vx / newSpeed1) * speed1;
                    b1.vy = (b1.vy / newSpeed1) * speed1;
                }
                if (newSpeed2 > 0) {
                    b2.vx = (b2.vx / newSpeed2) * speed2;
                    b2.vy = (b2.vy / newSpeed2) * speed2;
                }
            }

            // Sticky collision mode
            stickyCollision(b1, b2, collision) {
                const { distance, minDistance, dx, dy } = collision;
                const nx = dx / distance;
                const ny = dy / distance;
                
                // Separate balls first
                const overlap = (minDistance - distance) * 0.51;
                b1.x -= nx * overlap;
                b1.y -= ny * overlap;
                b2.x += nx * overlap;
                b2.y += ny * overlap;
                
                // Make balls stick together
                b1.stuckWith = b2;
                b2.stuckWith = b1;
                b1.stuckTime = this.config.stickyDuration;
                b2.stuckTime = this.config.stickyDuration;
                
                // Average velocities (conserve momentum)
                const totalMass = b1.mass + b2.mass;
                const avgVx = (b1.vx * b1.mass + b2.vx * b2.mass) / totalMass;
                const avgVy = (b1.vy * b1.mass + b2.vy * b2.mass) / totalMass;
                b1.vx = avgVx;
                b1.vy = avgVy;
                b2.vx = avgVx;
                b2.vy = avgVy;
            }

            // Explosive collision mode
            explosiveCollision(b1, b2, collision) {
                // First do normal collision
                this.normalCollision(b1, b2, collision);
                
                // Then add extra energy
                const boost = this.config.explosiveBoost;
                b1.vx *= boost;
                b1.vy *= boost;
                b2.vx *= boost;
                b2.vy *= boost;
                
                // Create more particles for explosive mode
                if (CONFIG.particleEffects && this.config.modeSpecificEffects) {
                    const midX = (b1.x + b2.x) / 2;
                    const midY = (b1.y + b2.y) / 2;
                    for (let i = 0; i < 15; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 200 + 100;
                        const vx = Math.cos(angle) * speed;
                        const vy = Math.sin(angle) * speed;
                        state.particles.push(new Particle(midX, midY, vx, vy, Math.random() * 3 + 1, '#FF6600', 0.6));
                    }
                }
            }

            // Absorbing collision mode
            absorbingCollision(b1, b2, collision) {
                const { distance, minDistance, dx, dy } = collision;
                const nx = dx / distance;
                const ny = dy / distance;
                
                // Separate balls
                const overlap = (minDistance - distance) * 0.51;
                b1.x -= nx * overlap;
                b1.y -= ny * overlap;
                b2.x += nx * overlap;
                b2.y += ny * overlap;
                
                // b1 absorbs momentum from b2
                const factor = this.config.absorbingFactor;
                const momentumX = b2.vx * b2.mass * factor;
                const momentumY = b2.vy * b2.mass * factor;
                
                b1.vx += momentumX / b1.mass;
                b1.vy += momentumY / b1.mass;
                b2.vx *= (1 - factor);
                b2.vy *= (1 - factor);
            }

            // Apply friction to tangential velocity
            applyFriction(b1, b2, nx, ny) {
                // Tangent vector (perpendicular to normal)
                const tx = -ny;
                const ty = nx;
                
                // Tangential velocities
                const vt1 = b1.vx * tx + b1.vy * ty;
                const vt2 = b2.vx * tx + b2.vy * ty;
                
                // Apply friction
                const frictionImpulse = (vt1 - vt2) * this.config.friction * 0.5;
                b1.vx -= frictionImpulse * tx;
                b1.vy -= frictionImpulse * ty;
                b2.vx += frictionImpulse * tx;
                b2.vy += frictionImpulse * ty;
            }

            // Resolve wall collision
            resolveWallCollision(ball, centerX, centerY, radius) {
                if (!this.config.enabled || !this.config.ballToWallEnabled) return false;
                
                const dx = ball.x - centerX;
                const dy = ball.y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist + ball.radius > radius) {
                    const nx = dx / dist;
                    const ny = dy / dist;
                    
                    // Position correction with boost
                    ball.x = centerX + nx * (radius - ball.radius);
                    ball.y = centerY + ny * (radius - ball.radius);
                    
                    if (this.config.preserveSpeedMagnitude) {
                        // Preserve speed magnitude
                        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                        const dot = ball.vx * nx + ball.vy * ny;
                        ball.vx -= 2 * dot * nx;
                        ball.vy -= 2 * dot * ny;
                        
                        // Normalize to original speed
                        const newSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                        if (newSpeed > 0) {
                            ball.vx = (ball.vx / newSpeed) * speed;
                            ball.vy = (ball.vy / newSpeed) * speed;
                        }
                    } else {
                        // Normal reflection with restitution and boost
                        const dot = ball.vx * nx + ball.vy * ny;
                        const restitution = this.config.restitution;
                        let damping = CONFIG.collisionDamping ? CONFIG.dampingFactor : 1.0;
                        
                        // Extra damping for downward gravity mode
                        if (CONFIG.gravityMode === 'down') {
                            damping *= 0.95;
                        }
                        
                        ball.vx -= (1 + restitution) * dot * nx * damping;
                        ball.vy -= (1 + restitution) * dot * ny * damping;
                    }
                    
                    // Visual feedback
                    ball.collisionFlash = 1.0;
                    
                    // Update stats
                    this.stats.totalCollisions++;
                    this.stats.ballToWallCollisions++;
                    
                    return true;
                }
                return false;
            }

            // Cooldown management
            isInCooldown(b1, b2) {
                if (this.config.collisionCooldown <= 0) return false;
                const key = this.getPairKey(b1, b2);
                const cooldown = this.collisionPairs.get(key);
                return cooldown && cooldown > 0;
            }

            setCollisionCooldown(b1, b2) {
                if (this.config.collisionCooldown <= 0) return;
                const key = this.getPairKey(b1, b2);
                this.collisionPairs.set(key, this.config.collisionCooldown);
            }

            getPairKey(b1, b2) {
                return b1.id < b2.id ? `${b1.id}-${b2.id}` : `${b2.id}-${b1.id}`;
            }

            // Get color for mode-specific effects
            getModeColor() {
                switch(this.config.mode) {
                    case 'sticky': return '#FFC000';
                    case 'explosive': return '#FF3030';
                    case 'absorbing': return '#C060FF';
                    case 'phase': return '#60C0FF';
                    default: return '#FFFFFF';
                }
            }

            // Reset stats
            resetStats() {
                this.stats.totalCollisions = 0;
                this.stats.ballToBallCollisions = 0;
                this.stats.ballToWallCollisions = 0;
            }
        }

        /**
         * PHYSICS FUNCTIONS
         */
        function isPointNearSegment(px, py, a, b, threshold) {
            const l2 = (a.x - b.x) ** 2 + (a.y - b.y) ** 2;
            if (l2 === 0.0) return Math.sqrt((px - a.x) ** 2 + (py - a.y) ** 2) < threshold;

            let t = ((px - a.x) * (b.x - a.x) + (py - a.y) * (b.y - a.y)) / l2;
            t = Math.max(0, Math.min(1, t));

            const projX = a.x + t * (b.x - a.x);
            const projY = a.y + t * (b.y - a.y);
            const dist = Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);

            return dist < threshold;
        }

        function resolveBallCollision(b1, b2) {
            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
            const distSq = dx * dx + dy * dy;
            const minDist = b1.radius + b2.radius;

            if (distSq < minDist * minDist && distSq > 0) {
                const dist = Math.sqrt(distSq);
                const nx = dx / dist;
                const ny = dy / dist;

                const overlap = (minDist - dist) * 0.51;
                b1.x -= nx * overlap;
                b1.y -= ny * overlap;
                b2.x += nx * overlap;
                b2.y += ny * overlap;

                const v1n = b1.vx * nx + b1.vy * ny;
                const v2n = b2.vx * nx + b2.vy * ny;

                if (v1n < v2n) return;

                const dvx = (v2n - v1n) * nx;
                const dvy = (v2n - v1n) * ny;
                
                const damping = CONFIG.collisionDamping ? CONFIG.dampingFactor : 1.0;
                
                b1.vx += dvx * damping;
                b1.vy += dvy * damping;
                b2.vx -= dvx * damping;
                b2.vy -= dvy * damping;

                if (CONFIG.collisionEffects) {
                    const midX = (b1.x + b2.x) / 2;
                    const midY = (b1.y + b2.y) / 2;
                    state.effects.push(new VisualEffect(midX, midY, '#FFFFFF', 25, 0.4));
                }
            }
        }

        /**
         * INITIALIZATION
         */
        function init() {
            state.canvas = document.getElementById('simCanvas');
            state.ctx = state.canvas.getContext('2d');
            
            // Initialize collision manager
            state.collisionManager = new CollisionManager(CONFIG.collision);
            
            // Initialize spacetime fabric
            state.spacetimeFabric = new SpacetimeFabric();
            
            setupEventListeners();
            onResize();
            resetSimulation();
            
            state.lastTime = performance.now();
            requestAnimationFrame(loop);
        }

        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onResize);
            
            // Menu toggle
            const menuToggle = document.getElementById('menuToggle');
            const sideMenu = document.getElementById('sideMenu');
            
            menuToggle.addEventListener('click', () => {
                menuToggle.classList.toggle('active');
                sideMenu.classList.toggle('active');
            });
            
            // Speed controls
            const speedSlider = document.getElementById('speedSlider');
            const speedInput = document.getElementById('speedInput');
            const speedValue = document.getElementById('speedValue');
            
            speedSlider.addEventListener('input', (e) => {
                const value = e.target.value;
                speedInput.value = value;
                speedValue.textContent = value + '%';
                CONFIG.speedMultiplier = value / 100;
                markAsPersonalized();
            });
            
            speedInput.addEventListener('input', (e) => {
                const value = Math.max(0, Math.min(500, e.target.value));
                speedSlider.value = value;
                speedValue.textContent = value + '%';
                CONFIG.speedMultiplier = value / 100;
                markAsPersonalized();
            });
            
            // Ball count controls
            const ballCountSlider = document.getElementById('ballCountSlider');
            const ballCountInput = document.getElementById('ballCountInput');
            const ballCountValue = document.getElementById('ballCountValue');
            
            ballCountSlider.addEventListener('input', (e) => {
                const value = e.target.value;
                ballCountInput.value = value;
                ballCountValue.textContent = value;
                CONFIG.ballCount = parseInt(value);
                markAsPersonalized();
                resetSimulation();
            });
            
            ballCountInput.addEventListener('input', (e) => {
                const value = Math.max(1, Math.min(32, e.target.value));
                ballCountSlider.value = value;
                ballCountValue.textContent = value;
                CONFIG.ballCount = parseInt(value);
                markAsPersonalized();
                resetSimulation();
            });
            
            // Ball size controls
            const ballSizeSlider = document.getElementById('ballSizeSlider');
            const ballSizeInput = document.getElementById('ballSizeInput');
            const ballSizeValue = document.getElementById('ballSizeValue');
            
            ballSizeSlider.addEventListener('input', (e) => {
                const value = e.target.value;
                ballSizeInput.value = value;
                ballSizeValue.textContent = value + 'px';
                CONFIG.ballRadius = parseInt(value);
                state.balls.forEach(ball => ball.radius = CONFIG.ballRadius);
                markAsPersonalized();
            });
            
            ballSizeInput.addEventListener('input', (e) => {
                const value = Math.max(4, Math.min(30, e.target.value));
                ballSizeSlider.value = value;
                ballSizeValue.textContent = value + 'px';
                CONFIG.ballRadius = parseInt(value);
                state.balls.forEach(ball => ball.radius = CONFIG.ballRadius);
                markAsPersonalized();
            });
            
            // Circle size controls
            const circleSizeSlider = document.getElementById('circleSizeSlider');
            const circleSizeInput = document.getElementById('circleSizeInput');
            const circleSizeValue = document.getElementById('circleSizeValue');
            
            circleSizeSlider.addEventListener('input', (e) => {
                const value = e.target.value;
                circleSizeInput.value = value;
                circleSizeValue.textContent = value + '%';
                CONFIG.circleRadiusRatio = value / 100;
                onResize();
            });
            
            circleSizeInput.addEventListener('input', (e) => {
                const value = Math.max(20, Math.min(45, e.target.value));
                circleSizeSlider.value = value;
                circleSizeValue.textContent = value + '%';
                CONFIG.circleRadiusRatio = value / 100;
                onResize();
            });
            
            // Line opacity controls
            const lineOpacitySlider = document.getElementById('lineOpacitySlider');
            const lineOpacityInput = document.getElementById('lineOpacityInput');
            const lineOpacityValue = document.getElementById('lineOpacityValue');
            
            lineOpacitySlider.addEventListener('input', (e) => {
                const value = e.target.value;
                lineOpacityInput.value = value;
                lineOpacityValue.textContent = value + '%';
                CONFIG.lineOpacity = value / 100;
            });
            
            lineOpacityInput.addEventListener('input', (e) => {
                const value = Math.max(10, Math.min(100, e.target.value));
                lineOpacitySlider.value = value;
                lineOpacityValue.textContent = value + '%';
                CONFIG.lineOpacity = value / 100;
            });
            
            // Acceleration controls
            const accelerateWithLines = document.getElementById('accelerateWithLines');
            const accelerationGroup = document.getElementById('accelerationGroup');
            const accelerationSlider = document.getElementById('accelerationSlider');
            const accelerationInput = document.getElementById('accelerationInput');
            const accelerationValue = document.getElementById('accelerationValue');
            
            accelerateWithLines.addEventListener('change', (e) => {
                CONFIG.accelerateWithLines = e.target.checked;
                accelerationGroup.style.display = e.target.checked ? 'block' : 'none';
                markAsPersonalized();
            });
            
            accelerationSlider.addEventListener('input', (e) => {
                const value = e.target.value;
                accelerationInput.value = value;
                accelerationValue.textContent = value + '%';
                CONFIG.accelerationPerLine = value / 100;
            });
            
            accelerationInput.addEventListener('input', (e) => {
                const value = Math.max(1, Math.min(50, e.target.value));
                accelerationSlider.value = value;
                accelerationValue.textContent = value + '%';
                CONFIG.accelerationPerLine = value / 100;
            });
            
            // Gravity controls
            const gravityModeSelect = document.getElementById('gravityModeSelect');
            const gravityIntensityGroup = document.getElementById('gravityIntensityGroup');
            const gravityIntensitySlider = document.getElementById('gravityIntensitySlider');
            const gravityIntensityInput = document.getElementById('gravityIntensityInput');
            const gravityIntensityValue = document.getElementById('gravityIntensityValue');
            const gravityMassGroup = document.getElementById('gravityMassGroup');
            const gravityMassSlider = document.getElementById('gravityMassSlider');
            const gravityMassInput = document.getElementById('gravityMassInput');
            const gravityMassValue = document.getElementById('gravityMassValue');
            const gravityDampingGroup = document.getElementById('gravityDampingGroup');
            const gravityDampingSlider = document.getElementById('gravityDampingSlider');
            const gravityDampingInput = document.getElementById('gravityDampingInput');
            const gravityDampingValue = document.getElementById('gravityDampingValue');
            
            gravityModeSelect.addEventListener('change', (e) => {
                CONFIG.gravityMode = e.target.value;
                const isActive = e.target.value !== 'none';
                gravityIntensityGroup.style.display = isActive ? 'block' : 'none';
                gravityMassGroup.style.display = (e.target.value === 'mutual') ? 'block' : 'none';
                gravityDampingGroup.style.display = (e.target.value === 'down') ? 'block' : 'none';
                
                // Regenerate fabric grid when gravity mode changes
                if (state.spacetimeFabric && CONFIG.spacetimeFabric) {
                    state.spacetimeFabric.generateGrid(
                        state.centerX, 
                        state.centerY, 
                        state.mainRadius, 
                        CONFIG.gravityMode
                    );
                }
                markAsPersonalized();
            });
            
            gravityIntensitySlider.addEventListener('input', (e) => {
                const value = e.target.value;
                gravityIntensityInput.value = value;
                gravityIntensityValue.textContent = value;
                CONFIG.gravityIntensity = parseInt(value);
            });
            
            gravityIntensityInput.addEventListener('input', (e) => {
                const value = Math.max(0, Math.min(1000, e.target.value));
                gravityIntensitySlider.value = value;
                gravityIntensityValue.textContent = value;
                CONFIG.gravityIntensity = parseInt(value);
            });
            
            gravityMassSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value) / 10;
                gravityMassInput.value = value.toFixed(1);
                gravityMassValue.textContent = value.toFixed(1);
                CONFIG.gravityMass = value;
                // Update all ball masses
                state.balls.forEach(ball => ball.mass = value);
            });
            
            gravityMassInput.addEventListener('input', (e) => {
                const value = Math.max(0.1, Math.min(30, parseFloat(e.target.value)));
                gravityMassSlider.value = Math.round(value * 10);
                gravityMassValue.textContent = value.toFixed(1);
                CONFIG.gravityMass = value;
                // Update all ball masses
                state.balls.forEach(ball => ball.mass = value);
            });
            
            gravityDampingSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value) / 100;
                gravityDampingInput.value = value.toFixed(2);
                gravityDampingValue.textContent = value.toFixed(2);
                CONFIG.gravityDamping = value;
            });
            
            gravityDampingInput.addEventListener('input', (e) => {
                const value = Math.max(0.9, Math.min(1.0, parseFloat(e.target.value)));
                gravityDampingSlider.value = Math.round(value * 100);
                gravityDampingValue.textContent = value.toFixed(2);
                CONFIG.gravityDamping = value;
            });
            
            // Damping controls
            const collisionDamping = document.getElementById('collisionDamping');
            const dampingGroup = document.getElementById('dampingGroup');
            const dampingSlider = document.getElementById('dampingSlider');
            const dampingInput = document.getElementById('dampingInput');
            const dampingValue = document.getElementById('dampingValue');
            
            collisionDamping.addEventListener('change', (e) => {
                CONFIG.collisionDamping = e.target.checked;
                dampingGroup.style.display = e.target.checked ? 'block' : 'none';
            });
            
            dampingSlider.addEventListener('input', (e) => {
                const value = e.target.value;
                dampingInput.value = value;
                dampingValue.textContent = (value / 100).toFixed(2);
                CONFIG.dampingFactor = value / 100;
            });
            
            dampingInput.addEventListener('input', (e) => {
                const value = Math.max(50, Math.min(100, e.target.value));
                dampingSlider.value = value;
                dampingValue.textContent = (value / 100).toFixed(2);
                CONFIG.dampingFactor = value / 100;
            });
            
            // Toggle switches
            document.getElementById('elasticLines').addEventListener('change', (e) => {
                CONFIG.elasticLines = e.target.checked;
                markAsPersonalized();
            });
            
            document.getElementById('motionTrails').addEventListener('change', (e) => {
                CONFIG.motionTrails = e.target.checked;
                markAsPersonalized();
            });
            
            document.getElementById('collisionEffects').addEventListener('change', (e) => {
                CONFIG.collisionEffects = e.target.checked;
                markAsPersonalized();
            });
            
            document.getElementById('particleEffects').addEventListener('change', (e) => {
                CONFIG.particleEffects = e.target.checked;
                markAsPersonalized();
            });
            
            document.getElementById('glowEffect').addEventListener('change', (e) => {
                CONFIG.glowEffect = e.target.checked;
                markAsPersonalized();
            });
            
            // Spacetime Fabric controls
            const spacetimeFabricToggle = document.getElementById('spacetimeFabric');
            const fabricIntensityGroup = document.getElementById('fabricIntensityGroup');
            const fabricOpacityGroup = document.getElementById('fabricOpacityGroup');
            const fabricDensityGroup = document.getElementById('fabricDensityGroup');
            const fabricIntensitySlider = document.getElementById('fabricIntensitySlider');
            const fabricIntensityInput = document.getElementById('fabricIntensityInput');
            const fabricIntensityValue = document.getElementById('fabricIntensityValue');
            const fabricOpacitySlider = document.getElementById('fabricOpacitySlider');
            const fabricOpacityInput = document.getElementById('fabricOpacityInput');
            const fabricOpacityValue = document.getElementById('fabricOpacityValue');
            const fabricDensitySlider = document.getElementById('fabricDensitySlider');
            const fabricDensityInput = document.getElementById('fabricDensityInput');
            const fabricDensityValue = document.getElementById('fabricDensityValue');
            
            spacetimeFabricToggle.addEventListener('change', (e) => {
                CONFIG.spacetimeFabric = e.target.checked;
                fabricIntensityGroup.style.display = e.target.checked ? 'block' : 'none';
                fabricOpacityGroup.style.display = e.target.checked ? 'block' : 'none';
                fabricDensityGroup.style.display = e.target.checked ? 'block' : 'none';
                
                if (state.spacetimeFabric) {
                    state.spacetimeFabric.updateSettings(
                        CONFIG.spacetimeFabric,
                        CONFIG.fabricIntensity,
                        CONFIG.fabricDensity,
                        CONFIG.fabricOpacity
                    );
                    
                    if (e.target.checked) {
                        state.spacetimeFabric.generateGrid(
                            state.centerX,
                            state.centerY,
                            state.mainRadius,
                            CONFIG.gravityMode
                        );
                    }
                }
            });
            
            fabricIntensitySlider.addEventListener('input', (e) => {
                const value = e.target.value;
                fabricIntensityInput.value = value;
                fabricIntensityValue.textContent = value + '%';
                CONFIG.fabricIntensity = value / 100;
                if (state.spacetimeFabric) {
                    state.spacetimeFabric.intensity = CONFIG.fabricIntensity;
                }
            });
            
            fabricIntensityInput.addEventListener('input', (e) => {
                const value = Math.max(10, Math.min(200, e.target.value));
                fabricIntensitySlider.value = value;
                fabricIntensityValue.textContent = value + '%';
                CONFIG.fabricIntensity = value / 100;
                if (state.spacetimeFabric) {
                    state.spacetimeFabric.intensity = CONFIG.fabricIntensity;
                }
            });
            
            fabricOpacitySlider.addEventListener('input', (e) => {
                const value = e.target.value;
                fabricOpacityInput.value = value;
                fabricOpacityValue.textContent = value + '%';
                CONFIG.fabricOpacity = value / 100;
                if (state.spacetimeFabric) {
                    state.spacetimeFabric.opacity = CONFIG.fabricOpacity;
                }
            });
            
            fabricOpacityInput.addEventListener('input', (e) => {
                const value = Math.max(10, Math.min(100, e.target.value));
                fabricOpacitySlider.value = value;
                fabricOpacityValue.textContent = value + '%';
                CONFIG.fabricOpacity = value / 100;
                if (state.spacetimeFabric) {
                    state.spacetimeFabric.opacity = CONFIG.fabricOpacity;
                }
            });
            
            fabricDensitySlider.addEventListener('input', (e) => {
                const value = e.target.value;
                fabricDensityInput.value = value;
                fabricDensityValue.textContent = value;
                CONFIG.fabricDensity = parseInt(value);
                if (state.spacetimeFabric) {
                    state.spacetimeFabric.density = CONFIG.fabricDensity;
                    state.spacetimeFabric.generateGrid(
                        state.centerX,
                        state.centerY,
                        state.mainRadius,
                        CONFIG.gravityMode
                    );
                }
            });
            
            fabricDensityInput.addEventListener('input', (e) => {
                const value = Math.max(6, Math.min(24, e.target.value));
                fabricDensitySlider.value = value;
                fabricDensityValue.textContent = value;
                CONFIG.fabricDensity = parseInt(value);
                if (state.spacetimeFabric) {
                    state.spacetimeFabric.density = CONFIG.fabricDensity;
                    state.spacetimeFabric.generateGrid(
                        state.centerX,
                        state.centerY,
                        state.mainRadius,
                        CONFIG.gravityMode
                    );
                }
            });
            
            document.getElementById('autoRespawn').addEventListener('change', (e) => {
                CONFIG.autoRespawn = e.target.checked;
                markAsPersonalized();
            });
            
            document.getElementById('linesEnabled').addEventListener('change', (e) => {
                CONFIG.linesEnabled = e.target.checked;
                
                // Clear existing lines when disabling
                if (!e.target.checked) {
                    state.lines = [];
                    // Reset line counts
                    state.balls.forEach(ball => {
                        ball.lineCount = 0;
                        ball.hasEverHadLine = false;
                    });
                }
                markAsPersonalized();
            });
            
            document.getElementById('eliminationMode').addEventListener('change', (e) => {
                CONFIG.eliminationMode = e.target.checked;
                markAsPersonalized();
            });
            
            document.getElementById('lineStealing').addEventListener('change', (e) => {
                CONFIG.lineStealing = e.target.checked;
                markAsPersonalized();
            });
            
            document.getElementById('powerUps').addEventListener('change', (e) => {
                CONFIG.powerUps = e.target.checked;
                markAsPersonalized();
            });
            
            // ===== CHAINSAW MODE CONTROLS =====
            
            // Master toggle
            document.getElementById('chainsawModeEnabled').addEventListener('change', (e) => {
                CONFIG.chainsawMode.enabled = e.target.checked;
                const settingsDiv = document.getElementById('chainsawModeSettings');
                settingsDiv.style.display = e.target.checked ? 'block' : 'none';
                
                if (!e.target.checked) {
                    // Clear all saws when disabling
                    state.saws = [];
                    state.sawSpawnTimer = 0;
                    state.balls.forEach(ball => {
                        ball.equippedSaw = null;
                        ball.speedModifier = 1.0;
                    });
                } else {
                    // Reset spawn timer to initial delay
                    state.sawSpawnTimer = -CONFIG.chainsawMode.initialSawDelay;
                }
                markAsPersonalized();
            });
            
            // Lives Mode
            document.getElementById('chainsawLivesMode').addEventListener('change', (e) => {
                CONFIG.chainsawMode.livesMode = e.target.checked;
                const livesGroup = document.getElementById('startingLivesGroup');
                livesGroup.style.display = e.target.checked ? 'block' : 'none';
                
                // Reset all ball lives
                state.balls.forEach(ball => {
                    ball.maxLives = CONFIG.chainsawMode.startingLives;
                    ball.lives = ball.maxLives;
                    ball.invulnerable = false;
                    ball.invulnerableTime = 0;
                });
            });
            
            // Starting Lives
            const startingLivesSlider = document.getElementById('startingLivesSlider');
            const startingLivesInput = document.getElementById('startingLivesInput');
            const startingLivesValue = document.getElementById('startingLivesValue');
            
            startingLivesSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                startingLivesInput.value = value;
                startingLivesValue.textContent = value;
                CONFIG.chainsawMode.startingLives = value;
                state.balls.forEach(ball => {
                    ball.maxLives = value;
                    ball.lives = value;
                });
            });
            
            startingLivesInput.addEventListener('input', (e) => {
                const value = Math.max(1, Math.min(10, parseInt(e.target.value)));
                startingLivesSlider.value = value;
                startingLivesValue.textContent = value;
                CONFIG.chainsawMode.startingLives = value;
                state.balls.forEach(ball => {
                    ball.maxLives = value;
                    ball.lives = value;
                });
            });
            
            // Max Saws on Map
            const maxSawsSlider = document.getElementById('maxSawsSlider');
            const maxSawsInput = document.getElementById('maxSawsInput');
            const maxSawsValue = document.getElementById('maxSawsValue');
            
            maxSawsSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                maxSawsInput.value = value;
                maxSawsValue.textContent = value;
                CONFIG.chainsawMode.maxSawsOnMap = value;
            });
            
            maxSawsInput.addEventListener('input', (e) => {
                const value = Math.max(1, Math.min(5, parseInt(e.target.value)));
                maxSawsSlider.value = value;
                maxSawsValue.textContent = value;
                CONFIG.chainsawMode.maxSawsOnMap = value;
            });
            
            // Saw Spawn Interval
            const sawSpawnIntervalSlider = document.getElementById('sawSpawnIntervalSlider');
            const sawSpawnIntervalInput = document.getElementById('sawSpawnIntervalInput');
            const sawSpawnIntervalValue = document.getElementById('sawSpawnIntervalValue');
            
            sawSpawnIntervalSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                sawSpawnIntervalInput.value = value;
                sawSpawnIntervalValue.textContent = value + 's';
                CONFIG.chainsawMode.sawSpawnInterval = value;
            });
            
            sawSpawnIntervalInput.addEventListener('input', (e) => {
                const value = Math.max(2, Math.min(30, parseInt(e.target.value)));
                sawSpawnIntervalSlider.value = value;
                sawSpawnIntervalValue.textContent = value + 's';
                CONFIG.chainsawMode.sawSpawnInterval = value;
            });
            
            // Initial Saw Delay
            const initialSawDelaySlider = document.getElementById('initialSawDelaySlider');
            const initialSawDelayInput = document.getElementById('initialSawDelayInput');
            const initialSawDelayValue = document.getElementById('initialSawDelayValue');
            
            initialSawDelaySlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                initialSawDelayInput.value = value;
                initialSawDelayValue.textContent = value + 's';
                CONFIG.chainsawMode.initialSawDelay = value;
            });
            
            initialSawDelayInput.addEventListener('input', (e) => {
                const value = Math.max(0, Math.min(20, parseInt(e.target.value)));
                initialSawDelaySlider.value = value;
                initialSawDelayValue.textContent = value + 's';
                CONFIG.chainsawMode.initialSawDelay = value;
            });
            
            // Saw Behavior
            const sawBehaviorSelect = document.getElementById('sawBehaviorSelect');
            const sawChargesGroup = document.getElementById('sawChargesGroup');
            const sawDurationGroup = document.getElementById('sawDurationGroup');
            
            sawBehaviorSelect.addEventListener('change', (e) => {
                const behavior = e.target.value;
                CONFIG.chainsawMode.sawBehavior = behavior;
                
                sawChargesGroup.style.display = behavior === 'durability' ? 'block' : 'none';
                sawDurationGroup.style.display = behavior === 'timed' ? 'block' : 'none';
            });
            
            // Saw Charges
            const sawChargesSlider = document.getElementById('sawChargesSlider');
            const sawChargesInput = document.getElementById('sawChargesInput');
            const sawChargesValue = document.getElementById('sawChargesValue');
            
            sawChargesSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                sawChargesInput.value = value;
                sawChargesValue.textContent = value;
                CONFIG.chainsawMode.sawCharges = value;
            });
            
            sawChargesInput.addEventListener('input', (e) => {
                const value = Math.max(1, Math.min(5, parseInt(e.target.value)));
                sawChargesSlider.value = value;
                sawChargesValue.textContent = value;
                CONFIG.chainsawMode.sawCharges = value;
            });
            
            // Saw Duration
            const sawDurationSlider = document.getElementById('sawDurationSlider');
            const sawDurationInput = document.getElementById('sawDurationInput');
            const sawDurationValue = document.getElementById('sawDurationValue');
            
            sawDurationSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                sawDurationInput.value = value;
                sawDurationValue.textContent = value + 's';
                CONFIG.chainsawMode.sawDuration = value;
            });
            
            sawDurationInput.addEventListener('input', (e) => {
                const value = Math.max(5, Math.min(30, parseInt(e.target.value)));
                sawDurationSlider.value = value;
                sawDurationValue.textContent = value + 's';
                CONFIG.chainsawMode.sawDuration = value;
            });
            
            // Saw Clash Behavior
            document.getElementById('sawClashBehaviorSelect').addEventListener('change', (e) => {
                CONFIG.chainsawMode.sawClashBehavior = e.target.value;
            });
            
            // Saw Types
            document.getElementById('sawTypeStandard').addEventListener('change', (e) => {
                CONFIG.chainsawMode.enabledSawTypes.standard = e.target.checked;
            });
            
            document.getElementById('sawTypeHeavy').addEventListener('change', (e) => {
                CONFIG.chainsawMode.enabledSawTypes.heavy = e.target.checked;
            });
            
            document.getElementById('sawTypeLight').addEventListener('change', (e) => {
                CONFIG.chainsawMode.enabledSawTypes.light = e.target.checked;
            });
            
            document.getElementById('sawTypeVortex').addEventListener('change', (e) => {
                CONFIG.chainsawMode.enabledSawTypes.vortex = e.target.checked;
            });
            
            document.getElementById('sawTypeEmp').addEventListener('change', (e) => {
                CONFIG.chainsawMode.enabledSawTypes.emp = e.target.checked;
            });
            
            // ===== ADVANCED COLOR THEME SYSTEM =====
            
            /**
             * Initialize theme grid with all available themes
             */
            function initializeThemeGrid() {
                const themeGrid = document.getElementById('themeGrid');
                themeGrid.innerHTML = '';

                Object.entries(COLOR_THEMES).forEach(([themeKey, themeData]) => {
                    const card = document.createElement('div');
                    card.className = 'theme-card';
                    if (themeKey === CONFIG.currentTheme) {
                        card.classList.add('active');
                    }
                    card.dataset.theme = themeKey;

                    const name = document.createElement('div');
                    name.className = 'theme-card-name';
                    name.textContent = themeData.name;

                    const preview = document.createElement('div');
                    preview.className = 'theme-card-preview';
                    
                    // Show preview with current color count
                    const colors = themeData.palettes[CONFIG.currentColorCount];
                    const previewColors = colors.slice(0, Math.min(8, colors.length)); // Show max 8 colors in preview
                    previewColors.forEach(color => {
                        const span = document.createElement('span');
                        span.style.background = color;
                        preview.appendChild(span);
                    });

                    card.appendChild(name);
                    card.appendChild(preview);
                    themeGrid.appendChild(card);

                    // Add click event
                    card.addEventListener('click', () => {
                        selectTheme(themeKey);
                    });
                });
            }

            /**
             * Update theme info display
             */
            function updateThemeInfo() {
                const themeData = COLOR_THEMES[CONFIG.currentTheme];
                document.getElementById('currentThemeName').textContent = themeData.name;
                document.getElementById('currentThemeDescription').textContent = themeData.description;

                const preview = document.getElementById('currentThemePreview');
                preview.innerHTML = '';
                const colors = CONFIG.colors.slice(0, 4); // Show first 4 colors
                colors.forEach(color => {
                    const span = document.createElement('span');
                    span.style.background = color;
                    preview.appendChild(span);
                });
            }

            /**
             * Select a theme
             */
            function selectTheme(themeKey) {
                CONFIG.currentTheme = themeKey;
                CONFIG.colors = COLOR_THEMES[themeKey].palettes[CONFIG.currentColorCount];

                // Update UI
                document.querySelectorAll('.theme-card').forEach(card => {
                    card.classList.toggle('active', card.dataset.theme === themeKey);
                });
                updateThemeInfo();

                // Update existing balls with new colors
                updateBallColors();
            }

            /**
             * Select color count
             */
            function selectColorCount(count) {
                CONFIG.currentColorCount = count;
                CONFIG.colors = COLOR_THEMES[CONFIG.currentTheme].palettes[count];

                // Update UI
                document.querySelectorAll('.color-count-btn').forEach(btn => {
                    btn.classList.toggle('active', parseInt(btn.dataset.count) === count);
                });
                document.getElementById('colorCountValue').textContent = count + ' colors';

                // Update theme grid previews
                document.querySelectorAll('.theme-card').forEach(card => {
                    const themeKey = card.dataset.theme;
                    const preview = card.querySelector('.theme-card-preview');
                    preview.innerHTML = '';
                    
                    const colors = COLOR_THEMES[themeKey].palettes[count];
                    const previewColors = colors.slice(0, Math.min(8, colors.length));
                    previewColors.forEach(color => {
                        const span = document.createElement('span');
                        span.style.background = color;
                        preview.appendChild(span);
                    });
                });

                updateThemeInfo();

                // Update existing balls with new colors
                updateBallColors();
            }

            /**
             * Update ball colors based on current palette
             */
            function updateBallColors() {
                state.balls.forEach((ball, index) => {
                    const colorIndex = index % CONFIG.colors.length;
                    ball.color = CONFIG.colors[colorIndex];
                    ball.originalColor = CONFIG.colors[colorIndex];
                });
            }

            // Initialize theme system
            initializeThemeGrid();
            updateThemeInfo();

            // Color count buttons
            document.querySelectorAll('.color-count-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const count = parseInt(btn.dataset.count);
                    selectColorCount(count);
                });
            });
            
            // ===== PRESET SYSTEM =====
            
            /**
             * Initialize preset grid with all presets
             */
            function initializePresetGrid() {
                const presetGrid = document.getElementById('presetGrid');
                presetGrid.innerHTML = '';

                Object.entries(PRESET_DEFINITIONS).forEach(([presetKey, presetData]) => {
                    // Skip personalized preset - it will be shown dynamically
                    if (presetKey === 'personalized') return;
                    
                    const card = document.createElement('div');
                    card.className = 'preset-card';
                    if (presetKey === state.currentPreset) {
                        card.classList.add('active');
                    }
                    card.dataset.preset = presetKey;

                    // Card header with name and badge
                    const header = document.createElement('div');
                    header.className = 'preset-card-header';

                    const name = document.createElement('div');
                    name.className = 'preset-card-name';
                    name.textContent = presetData.name;

                    const badge = document.createElement('div');
                    badge.className = `preset-badge badge-${presetData.badge}`;
                    badge.textContent = presetData.badge.toUpperCase();

                    header.appendChild(name);
                    header.appendChild(badge);

                    // Description
                    const description = document.createElement('div');
                    description.className = 'preset-card-description';
                    description.textContent = presetData.description;

                    // Features
                    const features = document.createElement('div');
                    features.className = 'preset-features';
                    presetData.features.forEach(feature => {
                        const featureTag = document.createElement('span');
                        featureTag.className = 'preset-feature';
                        featureTag.textContent = feature;
                        features.appendChild(featureTag);
                    });

                    card.appendChild(header);
                    card.appendChild(description);
                    card.appendChild(features);
                    presetGrid.appendChild(card);

                    // Add click event
                    card.addEventListener('click', () => {
                        loadPreset(presetKey);
                    });
                });
            }

            /**
             * Show personalized preset at the top
             */
            function showPersonalizedPreset() {
                const presetGrid = document.getElementById('presetGrid');
                
                // Check if personalized card already exists
                let personalizedCard = presetGrid.querySelector('[data-preset="personalized"]');
                
                if (!personalizedCard) {
                    const presetData = PRESET_DEFINITIONS.personalized;
                    personalizedCard = document.createElement('div');
                    personalizedCard.className = 'preset-card active';
                    personalizedCard.dataset.preset = 'personalized';

                    const header = document.createElement('div');
                    header.className = 'preset-card-header';

                    const name = document.createElement('div');
                    name.className = 'preset-card-name';
                    name.textContent = presetData.name;

                    const badge = document.createElement('div');
                    badge.className = `preset-badge badge-${presetData.badge}`;
                    badge.textContent = 'CUSTOM';

                    header.appendChild(name);
                    header.appendChild(badge);

                    const description = document.createElement('div');
                    description.className = 'preset-card-description';
                    description.textContent = presetData.description;

                    const features = document.createElement('div');
                    features.className = 'preset-features';
                    presetData.features.forEach(feature => {
                        const featureTag = document.createElement('span');
                        featureTag.className = 'preset-feature';
                        featureTag.textContent = feature;
                        features.appendChild(featureTag);
                    });

                    personalizedCard.appendChild(header);
                    personalizedCard.appendChild(description);
                    personalizedCard.appendChild(features);
                    
                    // Insert at the beginning
                    presetGrid.insertBefore(personalizedCard, presetGrid.firstChild);
                }
                
                // Update active state
                state.currentPreset = 'personalized';
                document.querySelectorAll('.preset-card').forEach(card => {
                    card.classList.toggle('active', card.dataset.preset === 'personalized');
                });
            }

            /**
             * Load a preset configuration
             */
            function loadPreset(presetKey) {
                const preset = PRESET_DEFINITIONS[presetKey];
                if (!preset || !preset.config) return;

                console.log('=== Loading preset:', presetKey, '==='); // Debug

                // Set flag to prevent triggering personalized during load
                state.isLoadingPreset = true;

                // Deep copy configuration
                const newConfig = JSON.parse(JSON.stringify(preset.config));
                
                // Apply all settings to CONFIG
                Object.keys(newConfig).forEach(key => {
                    if (typeof newConfig[key] === 'object' && newConfig[key] !== null && !Array.isArray(newConfig[key])) {
                        // Deep merge for nested objects like collision and chainsawMode
                        CONFIG[key] = { ...CONFIG[key], ...newConfig[key] };
                    } else {
                        CONFIG[key] = newConfig[key];
                    }
                });

                console.log('Config applied:', CONFIG); // Debug

                // Update current preset BEFORE updating UI
                state.currentPreset = presetKey;

                // Update active preset card FIRST
                document.querySelectorAll('.preset-card').forEach(card => {
                    const isActive = card.dataset.preset === presetKey;
                    card.classList.toggle('active', isActive);
                });

                // Update all UI controls to reflect the loaded preset
                console.log('Updating UI controls...'); // Debug
                updateAllUIControls();

                // CRITICAL: Reset simulation MUST be called AFTER all updates
                console.log('About to call resetSimulation...'); // Debug
                
                // Use setTimeout to ensure all DOM updates are complete first
                setTimeout(() => {
                    console.log('CALLING RESET SIMULATION NOW'); // Debug
                    resetSimulation();
                    console.log('Reset complete. Active balls:', state.balls.length); // Debug
                    
                    // Clear loading flag
                    state.isLoadingPreset = false;
                    console.log('=== Preset', presetKey, 'fully loaded ==='); // Debug
                }, 100);
            }

            /**
             * Mark settings as personalized when user makes changes
             */
            function markAsPersonalized() {
                if (state.isLoadingPreset) return; // Don't trigger during preset loading
                if (state.currentPreset === 'personalized') return; // Already personalized
                
                showPersonalizedPreset();
            }

            /**
             * Update all UI controls to match current CONFIG
             */
            function updateAllUIControls() {
                // Speed
                document.getElementById('speedSlider').value = CONFIG.speedMultiplier * 100;
                document.getElementById('speedInput').value = CONFIG.speedMultiplier * 100;
                document.getElementById('speedValue').textContent = Math.round(CONFIG.speedMultiplier * 100) + '%';

                // Ball count
                document.getElementById('ballCountSlider').value = CONFIG.ballCount;
                document.getElementById('ballCountInput').value = CONFIG.ballCount;
                document.getElementById('ballCountValue').textContent = CONFIG.ballCount;

                // Ball size
                document.getElementById('ballSizeSlider').value = CONFIG.ballRadius;
                document.getElementById('ballSizeInput').value = CONFIG.ballRadius;
                document.getElementById('ballSizeValue').textContent = CONFIG.ballRadius + 'px';

                // Circle size
                document.getElementById('circleSizeSlider').value = CONFIG.circleRadiusRatio * 100;
                document.getElementById('circleSizeInput').value = CONFIG.circleRadiusRatio * 100;
                document.getElementById('circleSizeValue').textContent = Math.round(CONFIG.circleRadiusRatio * 100) + '%';

                // Line opacity
                document.getElementById('lineOpacitySlider').value = CONFIG.lineOpacity * 100;
                document.getElementById('lineOpacityInput').value = CONFIG.lineOpacity * 100;
                document.getElementById('lineOpacityValue').textContent = Math.round(CONFIG.lineOpacity * 100) + '%';

                // Physics
                document.getElementById('accelerateWithLines').checked = CONFIG.accelerateWithLines;
                document.getElementById('accelerationGroup').style.display = CONFIG.accelerateWithLines ? 'block' : 'none';
                document.getElementById('accelerationSlider').value = CONFIG.accelerationPerLine * 100;
                document.getElementById('accelerationInput').value = CONFIG.accelerationPerLine * 100;
                document.getElementById('accelerationValue').textContent = Math.round(CONFIG.accelerationPerLine * 100) + '%';

                // Gravity
                document.getElementById('gravityModeSelect').value = CONFIG.gravityMode;
                const isGravityActive = CONFIG.gravityMode !== 'none';
                document.getElementById('gravityIntensityGroup').style.display = isGravityActive ? 'block' : 'none';
                document.getElementById('gravityMassGroup').style.display = CONFIG.gravityMode === 'mutual' ? 'block' : 'none';
                document.getElementById('gravityDampingGroup').style.display = CONFIG.gravityMode === 'down' ? 'block' : 'none';
                
                document.getElementById('gravityIntensitySlider').value = CONFIG.gravityIntensity;
                document.getElementById('gravityIntensityInput').value = CONFIG.gravityIntensity;
                document.getElementById('gravityIntensityValue').textContent = CONFIG.gravityIntensity;

                document.getElementById('gravityMassSlider').value = CONFIG.gravityMass * 10;
                document.getElementById('gravityMassInput').value = CONFIG.gravityMass.toFixed(1);
                document.getElementById('gravityMassValue').textContent = CONFIG.gravityMass.toFixed(1);

                document.getElementById('gravityDampingSlider').value = CONFIG.gravityDamping * 100;
                document.getElementById('gravityDampingInput').value = CONFIG.gravityDamping.toFixed(2);
                document.getElementById('gravityDampingValue').textContent = CONFIG.gravityDamping.toFixed(2);

                // Spacetime Fabric
                document.getElementById('spacetimeFabric').checked = CONFIG.spacetimeFabric;
                const fabricControlsVisible = CONFIG.spacetimeFabric;
                document.getElementById('fabricIntensityGroup').style.display = fabricControlsVisible ? 'block' : 'none';
                document.getElementById('fabricOpacityGroup').style.display = fabricControlsVisible ? 'block' : 'none';
                document.getElementById('fabricDensityGroup').style.display = fabricControlsVisible ? 'block' : 'none';

                if (state.spacetimeFabric) {
                    state.spacetimeFabric.enabled = CONFIG.spacetimeFabric;
                    state.spacetimeFabric.intensity = CONFIG.fabricIntensity;
                    state.spacetimeFabric.density = CONFIG.fabricDensity;
                    state.spacetimeFabric.opacity = CONFIG.fabricOpacity;
                    if (CONFIG.spacetimeFabric) {
                        state.spacetimeFabric.generateGrid(state.centerX, state.centerY, state.mainRadius, CONFIG.gravityMode);
                    }
                }

                document.getElementById('fabricIntensitySlider').value = CONFIG.fabricIntensity * 100;
                document.getElementById('fabricIntensityInput').value = CONFIG.fabricIntensity * 100;
                document.getElementById('fabricIntensityValue').textContent = Math.round(CONFIG.fabricIntensity * 100) + '%';

                document.getElementById('fabricOpacitySlider').value = CONFIG.fabricOpacity * 100;
                document.getElementById('fabricOpacityInput').value = CONFIG.fabricOpacity * 100;
                document.getElementById('fabricOpacityValue').textContent = Math.round(CONFIG.fabricOpacity * 100) + '%';

                document.getElementById('fabricDensitySlider').value = CONFIG.fabricDensity;
                document.getElementById('fabricDensityInput').value = CONFIG.fabricDensity;
                document.getElementById('fabricDensityValue').textContent = CONFIG.fabricDensity;

                // Elastic and damping
                document.getElementById('elasticLines').checked = CONFIG.elasticLines;
                document.getElementById('collisionDamping').checked = CONFIG.collisionDamping;
                document.getElementById('dampingGroup').style.display = CONFIG.collisionDamping ? 'block' : 'none';
                document.getElementById('dampingSlider').value = CONFIG.dampingFactor * 100;
                document.getElementById('dampingInput').value = CONFIG.dampingFactor * 100;
                document.getElementById('dampingValue').textContent = CONFIG.dampingFactor.toFixed(2);

                // Visual effects
                document.getElementById('motionTrails').checked = CONFIG.motionTrails;
                document.getElementById('collisionEffects').checked = CONFIG.collisionEffects;
                document.getElementById('particleEffects').checked = CONFIG.particleEffects;
                document.getElementById('glowEffect').checked = CONFIG.glowEffect;

                // Game modes
                document.getElementById('linesEnabled').checked = CONFIG.linesEnabled;
                document.getElementById('autoRespawn').checked = CONFIG.autoRespawn;
                document.getElementById('eliminationMode').checked = CONFIG.eliminationMode;
                document.getElementById('lineStealing').checked = CONFIG.lineStealing;
                document.getElementById('powerUps').checked = CONFIG.powerUps;

                // Collision system
                document.getElementById('collisionsEnabled').checked = CONFIG.collision.enabled;
                document.getElementById('ballToBallCollisions').checked = CONFIG.collision.ballToBallEnabled;
                document.getElementById('ballToWallCollisions').checked = CONFIG.collision.ballToWallEnabled;

                document.getElementById('restitutionSlider').value = CONFIG.collision.restitution * 100;
                document.getElementById('restitutionInput').value = CONFIG.collision.restitution.toFixed(2);
                document.getElementById('restitutionValue').textContent = CONFIG.collision.restitution.toFixed(2);

                document.getElementById('forceBoostSlider').value = CONFIG.collision.normalForceBoost * 100;
                document.getElementById('forceBoostInput').value = CONFIG.collision.normalForceBoost * 100;
                document.getElementById('forceBoostValue').textContent = Math.round(CONFIG.collision.normalForceBoost * 100) + '%';

                document.getElementById('frictionSlider').value = CONFIG.collision.friction * 100;
                document.getElementById('frictionInput').value = CONFIG.collision.friction.toFixed(2);
                document.getElementById('frictionValue').textContent = CONFIG.collision.friction.toFixed(2);

                document.getElementById('preserveSpeed').checked = CONFIG.collision.preserveSpeedMagnitude;

                document.getElementById('collisionModeSelect').value = CONFIG.collision.mode;
                updateCollisionModeBadge(CONFIG.collision.mode);
                updateCollisionModeParams(CONFIG.collision.mode);

                document.getElementById('stickyDurationSlider').value = CONFIG.collision.stickyDuration * 100;
                document.getElementById('stickyDurationInput').value = CONFIG.collision.stickyDuration.toFixed(1);
                document.getElementById('stickyDurationValue').textContent = CONFIG.collision.stickyDuration.toFixed(1) + 's';

                document.getElementById('explosiveBoostSlider').value = CONFIG.collision.explosiveBoost * 100;
                document.getElementById('explosiveBoostInput').value = CONFIG.collision.explosiveBoost.toFixed(1);
                document.getElementById('explosiveBoostValue').textContent = Math.round(CONFIG.collision.explosiveBoost * 100) + '%';

                document.getElementById('absorbingFactorSlider').value = CONFIG.collision.absorbingFactor * 100;
                document.getElementById('absorbingFactorInput').value = CONFIG.collision.absorbingFactor.toFixed(1);
                document.getElementById('absorbingFactorValue').textContent = Math.round(CONFIG.collision.absorbingFactor * 100) + '%';

                document.getElementById('cooldownSlider').value = CONFIG.collision.collisionCooldown * 100;
                document.getElementById('cooldownInput').value = CONFIG.collision.collisionCooldown.toFixed(2);
                document.getElementById('cooldownValue').textContent = CONFIG.collision.collisionCooldown.toFixed(1) + 's';

                // Chainsaw mode
                document.getElementById('chainsawModeEnabled').checked = CONFIG.chainsawMode.enabled;
                document.getElementById('chainsawModeSettings').style.display = CONFIG.chainsawMode.enabled ? 'block' : 'none';

                document.getElementById('chainsawLivesMode').checked = CONFIG.chainsawMode.livesMode;
                document.getElementById('startingLivesGroup').style.display = CONFIG.chainsawMode.livesMode ? 'block' : 'none';

                document.getElementById('startingLivesSlider').value = CONFIG.chainsawMode.startingLives;
                document.getElementById('startingLivesInput').value = CONFIG.chainsawMode.startingLives;
                document.getElementById('startingLivesValue').textContent = CONFIG.chainsawMode.startingLives;

                document.getElementById('maxSawsSlider').value = CONFIG.chainsawMode.maxSawsOnMap;
                document.getElementById('maxSawsInput').value = CONFIG.chainsawMode.maxSawsOnMap;
                document.getElementById('maxSawsValue').textContent = CONFIG.chainsawMode.maxSawsOnMap;

                document.getElementById('sawSpawnIntervalSlider').value = CONFIG.chainsawMode.sawSpawnInterval;
                document.getElementById('sawSpawnIntervalInput').value = CONFIG.chainsawMode.sawSpawnInterval;
                document.getElementById('sawSpawnIntervalValue').textContent = CONFIG.chainsawMode.sawSpawnInterval + 's';

                document.getElementById('initialSawDelaySlider').value = CONFIG.chainsawMode.initialSawDelay;
                document.getElementById('initialSawDelayInput').value = CONFIG.chainsawMode.initialSawDelay;
                document.getElementById('initialSawDelayValue').textContent = CONFIG.chainsawMode.initialSawDelay + 's';

                document.getElementById('sawBehaviorSelect').value = CONFIG.chainsawMode.sawBehavior;
                updateSawBehaviorControls(CONFIG.chainsawMode.sawBehavior);

                document.getElementById('sawChargesSlider').value = CONFIG.chainsawMode.sawCharges;
                document.getElementById('sawChargesInput').value = CONFIG.chainsawMode.sawCharges;
                document.getElementById('sawChargesValue').textContent = CONFIG.chainsawMode.sawCharges;

                document.getElementById('sawDurationSlider').value = CONFIG.chainsawMode.sawDuration;
                document.getElementById('sawDurationInput').value = CONFIG.chainsawMode.sawDuration;
                document.getElementById('sawDurationValue').textContent = CONFIG.chainsawMode.sawDuration + 's';

                document.getElementById('sawClashBehaviorSelect').value = CONFIG.chainsawMode.sawClashBehavior;

                document.getElementById('sawTypeStandard').checked = CONFIG.chainsawMode.enabledSawTypes.standard;
                document.getElementById('sawTypeHeavy').checked = CONFIG.chainsawMode.enabledSawTypes.heavy;
                document.getElementById('sawTypeLight').checked = CONFIG.chainsawMode.enabledSawTypes.light;
                document.getElementById('sawTypeVortex').checked = CONFIG.chainsawMode.enabledSawTypes.vortex;
                document.getElementById('sawTypeEmp').checked = CONFIG.chainsawMode.enabledSawTypes.emp;

                // Update theme (without triggering preset re-initialization)
                CONFIG.currentTheme = CONFIG.currentTheme || 'classic';
                CONFIG.currentColorCount = CONFIG.currentColorCount || 4;
                
                // Update theme UI without calling selectTheme (which regenerates preset grid)
                updateThemeInfoOnly();
                updateColorCountOnly();

                // Update collision manager config
                if (state.collisionManager) {
                    state.collisionManager.config = CONFIG.collision;
                }
            }
            
            /**
             * Update theme info without triggering preset changes
             */
            function updateThemeInfoOnly() {
                const themeData = COLOR_THEMES[CONFIG.currentTheme];
                if (!themeData) return;
                
                document.getElementById('currentThemeName').textContent = themeData.name;
                document.getElementById('currentThemeDescription').textContent = themeData.description;

                const preview = document.getElementById('currentThemePreview');
                preview.innerHTML = '';
                const colors = CONFIG.colors.slice(0, 4);
                colors.forEach(color => {
                    const span = document.createElement('span');
                    span.style.background = color;
                    preview.appendChild(span);
                });
                
                // Update theme cards active state
                document.querySelectorAll('.theme-card').forEach(card => {
                    card.classList.toggle('active', card.dataset.theme === CONFIG.currentTheme);
                });
            }
            
            /**
             * Update color count UI without triggering preset changes
             */
            function updateColorCountOnly() {
                document.querySelectorAll('.color-count-btn').forEach(btn => {
                    btn.classList.toggle('active', parseInt(btn.dataset.count) === CONFIG.currentColorCount);
                });
                document.getElementById('colorCountValue').textContent = CONFIG.currentColorCount + ' colors';
                
                // Update theme grid previews
                document.querySelectorAll('.theme-card').forEach(card => {
                    const themeKey = card.dataset.theme;
                    const preview = card.querySelector('.theme-card-preview');
                    if (preview && COLOR_THEMES[themeKey]) {
                        preview.innerHTML = '';
                        
                        const colors = COLOR_THEMES[themeKey].palettes[CONFIG.currentColorCount];
                        const previewColors = colors.slice(0, Math.min(8, colors.length));
                        previewColors.forEach(color => {
                            const span = document.createElement('span');
                            span.style.background = color;
                            preview.appendChild(span);
                        });
                    }
                });
            }

            /**
             * Helper function to update collision mode badge
             */
            function updateCollisionModeBadge(mode) {
                const badge = document.getElementById('modeBadge');
                badge.className = `collision-mode-badge mode-${mode}`;
                badge.textContent = mode.toUpperCase();
            }

            /**
             * Helper function to show/hide mode-specific parameters
             */
            function updateCollisionModeParams(mode) {
                document.getElementById('stickyParams').style.display = mode === 'sticky' ? 'block' : 'none';
                document.getElementById('explosiveParams').style.display = mode === 'explosive' ? 'block' : 'none';
                document.getElementById('absorbingParams').style.display = mode === 'absorbing' ? 'block' : 'none';
            }

            /**
             * Helper function to update saw behavior controls
             */
            function updateSawBehaviorControls(behavior) {
                document.getElementById('sawChargesGroup').style.display = behavior === 'durability' ? 'block' : 'none';
                document.getElementById('sawDurationGroup').style.display = behavior === 'timed' ? 'block' : 'none';
            }

            // Initialize preset system
            initializePresetGrid();
            
            // Add global listeners to detect any configuration changes
            // This catches any sliders/inputs that weren't explicitly marked above
            setTimeout(() => {
                // All range sliders
                document.querySelectorAll('#sideMenu input[type="range"]').forEach(input => {
                    const hasListener = input.getAttribute('data-personalized-listener');
                    if (!hasListener) {
                        input.addEventListener('input', () => {
                            markAsPersonalized();
                        });
                        input.setAttribute('data-personalized-listener', 'true');
                    }
                });
                
                // All number inputs
                document.querySelectorAll('#sideMenu input[type="number"]').forEach(input => {
                    const hasListener = input.getAttribute('data-personalized-listener');
                    if (!hasListener) {
                        input.addEventListener('input', () => {
                            markAsPersonalized();
                        });
                        input.setAttribute('data-personalized-listener', 'true');
                    }
                });
                
                // All checkboxes
                document.querySelectorAll('#sideMenu input[type="checkbox"]').forEach(input => {
                    const hasListener = input.getAttribute('data-personalized-listener');
                    if (!hasListener) {
                        input.addEventListener('change', () => {
                            markAsPersonalized();
                        });
                        input.setAttribute('data-personalized-listener', 'true');
                    }
                });
                
                // All selects
                document.querySelectorAll('#sideMenu select').forEach(select => {
                    const hasListener = select.getAttribute('data-personalized-listener');
                    if (!hasListener) {
                        select.addEventListener('change', () => {
                            markAsPersonalized();
                        });
                        select.setAttribute('data-personalized-listener', 'true');
                    }
                });
            }, 500);
            
            // ===== COLLISION SYSTEM CONTROLS =====
            
            // Enable/Disable Collisions
            document.getElementById('collisionsEnabled').addEventListener('change', (e) => {
                CONFIG.collision.enabled = e.target.checked;
                markAsPersonalized();
            });
            
            document.getElementById('ballToBallCollisions').addEventListener('change', (e) => {
                CONFIG.collision.ballToBallEnabled = e.target.checked;
                markAsPersonalized();
            });
            
            document.getElementById('ballToWallCollisions').addEventListener('change', (e) => {
                CONFIG.collision.ballToWallEnabled = e.target.checked;
                markAsPersonalized();
            });
            
            // Restitution
            const restitutionSlider = document.getElementById('restitutionSlider');
            const restitutionInput = document.getElementById('restitutionInput');
            const restitutionValue = document.getElementById('restitutionValue');
            
            restitutionSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value) / 100;
                restitutionInput.value = value.toFixed(2);
                restitutionValue.textContent = value.toFixed(2);
                CONFIG.collision.restitution = value;
            });
            
            restitutionInput.addEventListener('input', (e) => {
                const value = Math.max(0, Math.min(2.0, parseFloat(e.target.value)));
                restitutionSlider.value = Math.round(value * 100);
                restitutionValue.textContent = value.toFixed(2);
                CONFIG.collision.restitution = value;
            });
            
            // Force Boost
            const forceBoostSlider = document.getElementById('forceBoostSlider');
            const forceBoostInput = document.getElementById('forceBoostInput');
            const forceBoostValue = document.getElementById('forceBoostValue');
            
            forceBoostSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                forceBoostInput.value = value;
                forceBoostValue.textContent = value + '%';
                CONFIG.collision.normalForceBoost = value / 100;
            });
            
            forceBoostInput.addEventListener('input', (e) => {
                const value = Math.max(50, Math.min(500, parseFloat(e.target.value)));
                forceBoostSlider.value = value;
                forceBoostValue.textContent = value + '%';
                CONFIG.collision.normalForceBoost = value / 100;
            });
            
            // Friction
            const frictionSlider = document.getElementById('frictionSlider');
            const frictionInput = document.getElementById('frictionInput');
            const frictionValue = document.getElementById('frictionValue');
            
            frictionSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value) / 100;
                frictionInput.value = value.toFixed(2);
                frictionValue.textContent = value.toFixed(2);
                CONFIG.collision.friction = value;
            });
            
            frictionInput.addEventListener('input', (e) => {
                const value = Math.max(0, Math.min(1.0, parseFloat(e.target.value)));
                frictionSlider.value = Math.round(value * 100);
                frictionValue.textContent = value.toFixed(2);
                CONFIG.collision.friction = value;
            });
            
            // Preserve Speed Magnitude
            document.getElementById('preserveSpeed').addEventListener('change', (e) => {
                CONFIG.collision.preserveSpeedMagnitude = e.target.checked;
            });
            
            // Collision Mode
            const collisionModeSelect = document.getElementById('collisionModeSelect');
            const modeBadge = document.getElementById('modeBadge');
            const stickyParams = document.getElementById('stickyParams');
            const explosiveParams = document.getElementById('explosiveParams');
            const absorbingParams = document.getElementById('absorbingParams');
            
            collisionModeSelect.addEventListener('change', (e) => {
                const mode = e.target.value;
                CONFIG.collision.mode = mode;
                
                // Update badge
                modeBadge.className = 'collision-mode-badge mode-' + mode;
                modeBadge.textContent = mode.toUpperCase();
                
                // Show/hide mode-specific parameters
                stickyParams.style.display = mode === 'sticky' ? 'block' : 'none';
                explosiveParams.style.display = mode === 'explosive' ? 'block' : 'none';
                absorbingParams.style.display = mode === 'absorbing' ? 'block' : 'none';
                
                markAsPersonalized();
            });
            
            // Sticky Duration
            const stickyDurationSlider = document.getElementById('stickyDurationSlider');
            const stickyDurationInput = document.getElementById('stickyDurationInput');
            const stickyDurationValue = document.getElementById('stickyDurationValue');
            
            stickyDurationSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value) / 100;
                stickyDurationInput.value = value.toFixed(1);
                stickyDurationValue.textContent = value.toFixed(1) + 's';
                CONFIG.collision.stickyDuration = value;
            });
            
            stickyDurationInput.addEventListener('input', (e) => {
                const value = Math.max(0.1, Math.min(5.0, parseFloat(e.target.value)));
                stickyDurationSlider.value = Math.round(value * 100);
                stickyDurationValue.textContent = value.toFixed(1) + 's';
                CONFIG.collision.stickyDuration = value;
            });
            
            // Explosive Boost
            const explosiveBoostSlider = document.getElementById('explosiveBoostSlider');
            const explosiveBoostInput = document.getElementById('explosiveBoostInput');
            const explosiveBoostValue = document.getElementById('explosiveBoostValue');
            
            explosiveBoostSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                explosiveBoostInput.value = (value / 100).toFixed(1);
                explosiveBoostValue.textContent = value + '%';
                CONFIG.collision.explosiveBoost = value / 100;
            });
            
            explosiveBoostInput.addEventListener('input', (e) => {
                const value = Math.max(1.1, Math.min(3.0, parseFloat(e.target.value)));
                explosiveBoostSlider.value = Math.round(value * 100);
                explosiveBoostValue.textContent = Math.round(value * 100) + '%';
                CONFIG.collision.explosiveBoost = value;
            });
            
            // Absorbing Factor
            const absorbingFactorSlider = document.getElementById('absorbingFactorSlider');
            const absorbingFactorInput = document.getElementById('absorbingFactorInput');
            const absorbingFactorValue = document.getElementById('absorbingFactorValue');
            
            absorbingFactorSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                absorbingFactorInput.value = (value / 100).toFixed(2);
                absorbingFactorValue.textContent = value + '%';
                CONFIG.collision.absorbingFactor = value / 100;
            });
            
            absorbingFactorInput.addEventListener('input', (e) => {
                const value = Math.max(0, Math.min(1.0, parseFloat(e.target.value)));
                absorbingFactorSlider.value = Math.round(value * 100);
                absorbingFactorValue.textContent = Math.round(value * 100) + '%';
                CONFIG.collision.absorbingFactor = value;
            });
            
            // Collision Cooldown
            const cooldownSlider = document.getElementById('cooldownSlider');
            const cooldownInput = document.getElementById('cooldownInput');
            const cooldownValue = document.getElementById('cooldownValue');
            
            cooldownSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value) / 100;
                cooldownInput.value = value.toFixed(2);
                cooldownValue.textContent = value.toFixed(2) + 's';
                CONFIG.collision.collisionCooldown = value;
            });
            
            cooldownInput.addEventListener('input', (e) => {
                const value = Math.max(0, Math.min(1.0, parseFloat(e.target.value)));
                cooldownSlider.value = Math.round(value * 100);
                cooldownValue.textContent = value.toFixed(2) + 's';
                CONFIG.collision.collisionCooldown = value;
            });
            
            // Buttons
            document.getElementById('resetBtn').addEventListener('click', resetSimulation);
            
            document.getElementById('pauseBtn').addEventListener('click', () => {
                CONFIG.isPaused = !CONFIG.isPaused;
                document.getElementById('pauseBtn').textContent = CONFIG.isPaused ? 'Resume' : 'Pause';
            });
            
            document.getElementById('exportBtn').addEventListener('click', () => {
                const settings = JSON.stringify(CONFIG, null, 2);
                const blob = new Blob([settings], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'physics-lab-settings.json';
                a.click();
                URL.revokeObjectURL(url);
            });
            
            document.getElementById('importBtn').addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const settings = JSON.parse(event.target.result);
                            Object.assign(CONFIG, settings);
                            updateUIFromConfig();
                            resetSimulation();
                        } catch (err) {
                            alert('Invalid settings file');
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            });
        }

        function updateUIFromConfig() {
            // Update all UI elements to match CONFIG
            document.getElementById('speedSlider').value = CONFIG.speedMultiplier * 100;
            document.getElementById('speedInput').value = CONFIG.speedMultiplier * 100;
            document.getElementById('speedValue').textContent = (CONFIG.speedMultiplier * 100) + '%';
            
            document.getElementById('ballCountSlider').value = CONFIG.ballCount;
            document.getElementById('ballCountInput').value = CONFIG.ballCount;
            document.getElementById('ballCountValue').textContent = CONFIG.ballCount;
            
            document.getElementById('ballSizeSlider').value = CONFIG.ballRadius;
            document.getElementById('ballSizeInput').value = CONFIG.ballRadius;
            document.getElementById('ballSizeValue').textContent = CONFIG.ballRadius + 'px';
            
            document.getElementById('circleSizeSlider').value = CONFIG.circleRadiusRatio * 100;
            document.getElementById('circleSizeInput').value = CONFIG.circleRadiusRatio * 100;
            document.getElementById('circleSizeValue').textContent = (CONFIG.circleRadiusRatio * 100) + '%';
            
            document.getElementById('lineOpacitySlider').value = CONFIG.lineOpacity * 100;
            document.getElementById('lineOpacityInput').value = CONFIG.lineOpacity * 100;
            document.getElementById('lineOpacityValue').textContent = (CONFIG.lineOpacity * 100) + '%';
            
            document.getElementById('accelerateWithLines').checked = CONFIG.accelerateWithLines;
            document.getElementById('accelerationSlider').value = CONFIG.accelerationPerLine * 100;
            document.getElementById('accelerationInput').value = CONFIG.accelerationPerLine * 100;
            document.getElementById('accelerationValue').textContent = (CONFIG.accelerationPerLine * 100) + '%';
            
            document.getElementById('gravityModeSelect').value = CONFIG.gravityMode;
            document.getElementById('gravityIntensitySlider').value = CONFIG.gravityIntensity;
            document.getElementById('gravityIntensityInput').value = CONFIG.gravityIntensity;
            document.getElementById('gravityIntensityValue').textContent = CONFIG.gravityIntensity;
            document.getElementById('gravityMassSlider').value = CONFIG.gravityMass * 10;
            document.getElementById('gravityMassInput').value = CONFIG.gravityMass.toFixed(1);
            document.getElementById('gravityMassValue').textContent = CONFIG.gravityMass.toFixed(1);
            document.getElementById('gravityDampingSlider').value = CONFIG.gravityDamping * 100;
            document.getElementById('gravityDampingInput').value = CONFIG.gravityDamping.toFixed(2);
            document.getElementById('gravityDampingValue').textContent = CONFIG.gravityDamping.toFixed(2);
            
            document.getElementById('elasticLines').checked = CONFIG.elasticLines;
            document.getElementById('collisionDamping').checked = CONFIG.collisionDamping;
            document.getElementById('dampingSlider').value = CONFIG.dampingFactor * 100;
            document.getElementById('dampingInput').value = CONFIG.dampingFactor * 100;
            document.getElementById('dampingValue').textContent = CONFIG.dampingFactor.toFixed(2);
            
            document.getElementById('motionTrails').checked = CONFIG.motionTrails;
            document.getElementById('collisionEffects').checked = CONFIG.collisionEffects;
            document.getElementById('particleEffects').checked = CONFIG.particleEffects;
            document.getElementById('glowEffect').checked = CONFIG.glowEffect;
            
            document.getElementById('spacetimeFabric').checked = CONFIG.spacetimeFabric;
            document.getElementById('fabricIntensitySlider').value = CONFIG.fabricIntensity * 100;
            document.getElementById('fabricIntensityInput').value = CONFIG.fabricIntensity * 100;
            document.getElementById('fabricIntensityValue').textContent = (CONFIG.fabricIntensity * 100) + '%';
            document.getElementById('fabricOpacitySlider').value = CONFIG.fabricOpacity * 100;
            document.getElementById('fabricOpacityInput').value = CONFIG.fabricOpacity * 100;
            document.getElementById('fabricOpacityValue').textContent = (CONFIG.fabricOpacity * 100) + '%';
            document.getElementById('fabricDensitySlider').value = CONFIG.fabricDensity;
            document.getElementById('fabricDensityInput').value = CONFIG.fabricDensity;
            document.getElementById('fabricDensityValue').textContent = CONFIG.fabricDensity;
            
            document.getElementById('autoRespawn').checked = CONFIG.autoRespawn;
            document.getElementById('linesEnabled').checked = CONFIG.linesEnabled;
            document.getElementById('eliminationMode').checked = CONFIG.eliminationMode;
            document.getElementById('lineStealing').checked = CONFIG.lineStealing;
            document.getElementById('powerUps').checked = CONFIG.powerUps;
            
            // Collision System UI Updates
            if (CONFIG.collision) {
                document.getElementById('collisionsEnabled').checked = CONFIG.collision.enabled;
                document.getElementById('ballToBallCollisions').checked = CONFIG.collision.ballToBallEnabled;
                document.getElementById('ballToWallCollisions').checked = CONFIG.collision.ballToWallEnabled;
                
                document.getElementById('restitutionSlider').value = CONFIG.collision.restitution * 100;
                document.getElementById('restitutionInput').value = CONFIG.collision.restitution.toFixed(2);
                document.getElementById('restitutionValue').textContent = CONFIG.collision.restitution.toFixed(2);
                
                document.getElementById('forceBoostSlider').value = CONFIG.collision.normalForceBoost * 100;
                document.getElementById('forceBoostInput').value = CONFIG.collision.normalForceBoost * 100;
                document.getElementById('forceBoostValue').textContent = (CONFIG.collision.normalForceBoost * 100) + '%';
                
                document.getElementById('frictionSlider').value = CONFIG.collision.friction * 100;
                document.getElementById('frictionInput').value = CONFIG.collision.friction.toFixed(2);
                document.getElementById('frictionValue').textContent = CONFIG.collision.friction.toFixed(2);
                
                document.getElementById('preserveSpeed').checked = CONFIG.collision.preserveSpeedMagnitude;
                
                document.getElementById('collisionModeSelect').value = CONFIG.collision.mode;
                const modeBadge = document.getElementById('modeBadge');
                modeBadge.className = 'collision-mode-badge mode-' + CONFIG.collision.mode;
                modeBadge.textContent = CONFIG.collision.mode.toUpperCase();
                
                document.getElementById('stickyDurationSlider').value = CONFIG.collision.stickyDuration * 100;
                document.getElementById('stickyDurationInput').value = CONFIG.collision.stickyDuration.toFixed(1);
                document.getElementById('stickyDurationValue').textContent = CONFIG.collision.stickyDuration.toFixed(1) + 's';
                
                document.getElementById('explosiveBoostSlider').value = CONFIG.collision.explosiveBoost * 100;
                document.getElementById('explosiveBoostInput').value = CONFIG.collision.explosiveBoost.toFixed(1);
                document.getElementById('explosiveBoostValue').textContent = (CONFIG.collision.explosiveBoost * 100) + '%';
                
                document.getElementById('absorbingFactorSlider').value = CONFIG.collision.absorbingFactor * 100;
                document.getElementById('absorbingFactorInput').value = CONFIG.collision.absorbingFactor.toFixed(2);
                document.getElementById('absorbingFactorValue').textContent = (CONFIG.collision.absorbingFactor * 100) + '%';
                
                document.getElementById('cooldownSlider').value = CONFIG.collision.collisionCooldown * 100;
                document.getElementById('cooldownInput').value = CONFIG.collision.collisionCooldown.toFixed(2);
                document.getElementById('cooldownValue').textContent = CONFIG.collision.collisionCooldown.toFixed(2) + 's';
            }
            
            // Chainsaw Mode UI Updates
            if (CONFIG.chainsawMode) {
                document.getElementById('chainsawModeEnabled').checked = CONFIG.chainsawMode.enabled;
                document.getElementById('chainsawModeSettings').style.display = CONFIG.chainsawMode.enabled ? 'block' : 'none';
                
                document.getElementById('chainsawLivesMode').checked = CONFIG.chainsawMode.livesMode;
                document.getElementById('startingLivesGroup').style.display = CONFIG.chainsawMode.livesMode ? 'block' : 'none';
                document.getElementById('startingLivesSlider').value = CONFIG.chainsawMode.startingLives;
                document.getElementById('startingLivesInput').value = CONFIG.chainsawMode.startingLives;
                document.getElementById('startingLivesValue').textContent = CONFIG.chainsawMode.startingLives;
                
                document.getElementById('maxSawsSlider').value = CONFIG.chainsawMode.maxSawsOnMap;
                document.getElementById('maxSawsInput').value = CONFIG.chainsawMode.maxSawsOnMap;
                document.getElementById('maxSawsValue').textContent = CONFIG.chainsawMode.maxSawsOnMap;
                
                document.getElementById('sawSpawnIntervalSlider').value = CONFIG.chainsawMode.sawSpawnInterval;
                document.getElementById('sawSpawnIntervalInput').value = CONFIG.chainsawMode.sawSpawnInterval;
                document.getElementById('sawSpawnIntervalValue').textContent = CONFIG.chainsawMode.sawSpawnInterval + 's';
                
                document.getElementById('initialSawDelaySlider').value = CONFIG.chainsawMode.initialSawDelay;
                document.getElementById('initialSawDelayInput').value = CONFIG.chainsawMode.initialSawDelay;
                document.getElementById('initialSawDelayValue').textContent = CONFIG.chainsawMode.initialSawDelay + 's';
                
                document.getElementById('sawBehaviorSelect').value = CONFIG.chainsawMode.sawBehavior;
                document.getElementById('sawChargesGroup').style.display = CONFIG.chainsawMode.sawBehavior === 'durability' ? 'block' : 'none';
                document.getElementById('sawDurationGroup').style.display = CONFIG.chainsawMode.sawBehavior === 'timed' ? 'block' : 'none';
                
                document.getElementById('sawChargesSlider').value = CONFIG.chainsawMode.sawCharges;
                document.getElementById('sawChargesInput').value = CONFIG.chainsawMode.sawCharges;
                document.getElementById('sawChargesValue').textContent = CONFIG.chainsawMode.sawCharges;
                
                document.getElementById('sawDurationSlider').value = CONFIG.chainsawMode.sawDuration;
                document.getElementById('sawDurationInput').value = CONFIG.chainsawMode.sawDuration;
                document.getElementById('sawDurationValue').textContent = CONFIG.chainsawMode.sawDuration + 's';
                
                document.getElementById('sawClashBehaviorSelect').value = CONFIG.chainsawMode.sawClashBehavior;
                
                document.getElementById('sawTypeStandard').checked = CONFIG.chainsawMode.enabledSawTypes.standard;
                document.getElementById('sawTypeHeavy').checked = CONFIG.chainsawMode.enabledSawTypes.heavy;
                document.getElementById('sawTypeLight').checked = CONFIG.chainsawMode.enabledSawTypes.light;
                document.getElementById('sawTypeVortex').checked = CONFIG.chainsawMode.enabledSawTypes.vortex;
                document.getElementById('sawTypeEmp').checked = CONFIG.chainsawMode.enabledSawTypes.emp;
            }
        }

        function onResize() {
            state.dpr = window.devicePixelRatio || 1;
            state.width = window.innerWidth;
            state.height = window.innerHeight;
            state.canvas.width = state.width * state.dpr;
            state.canvas.height = state.height * state.dpr;
            state.canvas.style.width = `${state.width}px`;
            state.canvas.style.height = `${state.height}px`;
            state.ctx.scale(state.dpr, state.dpr);
            state.centerX = state.width / 2;
            state.centerY = state.height / 2;
            state.mainRadius = Math.min(state.width, state.height) * CONFIG.circleRadiusRatio;
            
            // Regenerate fabric grid on resize
            if (state.spacetimeFabric && CONFIG.spacetimeFabric) {
                state.spacetimeFabric.generateGrid(
                    state.centerX,
                    state.centerY,
                    state.mainRadius,
                    CONFIG.gravityMode
                );
            }
        }

        function resetSimulation() {
            state.balls = [];
            state.lines = [];
            state.particles = [];
            state.effects = [];
            state.trails = [];
            state.powerups = [];
            state.saws = [];
            // Set negative spawn timer to implement initial delay
            state.sawSpawnTimer = CONFIG.chainsawMode.enabled ? -CONFIG.chainsawMode.initialSawDelay : 0;

            // Create balls with enough space between them
            const colors = CONFIG.colors;
            for (let i = 0; i < CONFIG.ballCount; i++) {
                let ball, attempts = 0;
                do {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * (state.mainRadius - CONFIG.ballRadius * 3);
                    const x = state.centerX + Math.cos(angle) * r;
                    const y = state.centerY + Math.sin(angle) * r;
                    const vAngle = Math.random() * Math.PI * 2;
                    const vx = Math.cos(vAngle) * CONFIG.ballSpeed;
                    const vy = Math.sin(vAngle) * CONFIG.ballSpeed;
                    const color = colors[i % colors.length];
                    ball = new Ball(i, color, x, y, vx, vy);
                    ball.mass = CONFIG.gravityMass; // Set mass from config
                    
                    let overlapping = false;
                    for (let other of state.balls) {
                        const dx = ball.x - other.x;
                        const dy = ball.y - other.y;
                        if (Math.sqrt(dx * dx + dy * dy) < (ball.radius + other.radius + 10)) {
                            overlapping = true;
                            break;
                        }
                    }
                    if (!overlapping) break;
                    attempts++;
                } while (attempts < 100);
                
                state.balls.push(ball);
            }
            
            // Initialize spacetime fabric
            if (state.spacetimeFabric && CONFIG.spacetimeFabric) {
                state.spacetimeFabric.generateGrid(
                    state.centerX,
                    state.centerY,
                    state.mainRadius,
                    CONFIG.gravityMode
                );
            }
        }

        /**
         * MAIN LOOP
         */
        function loop(timestamp) {
            const dt = (timestamp - state.lastTime) / 1000;
            state.lastTime = timestamp;
            const safeDt = Math.min(dt, 0.033);
            
            // Calculate FPS
            state.frameCount++;
            state.fpsTime += dt;
            if (state.fpsTime >= 1.0) {
                state.fps = Math.round(state.frameCount / state.fpsTime);
                state.frameCount = 0;
                state.fpsTime = 0;
                document.getElementById('fps').textContent = state.fps;
            }
            
            update(safeDt);
            draw();
            requestAnimationFrame(loop);
        }

        /**
         * CHAINSAW HELPER FUNCTIONS
         */
        function handleSawClash(ball1, ball2) {
            const behavior = CONFIG.chainsawMode.sawClashBehavior;
            
            if (behavior === 'both-break') {
                // Both saws break
                ball1.equippedSaw.useCharge();
                ball2.equippedSaw.useCharge();
                
                // Spark effect at collision point
                if (CONFIG.collisionEffects) {
                    const midX = (ball1.x + ball2.x) / 2;
                    const midY = (ball1.y + ball2.y) / 2;
                    state.effects.push(new VisualEffect(midX, midY, '#FFFF00', 50, 0.6));
                    
                    // Spark particles
                    if (CONFIG.particleEffects) {
                        for (let i = 0; i < 30; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = Math.random() * 250 + 100;
                            const vx = Math.cos(angle) * speed;
                            const vy = Math.sin(angle) * speed;
                            state.particles.push(new Particle(
                                midX, midY, vx, vy,
                                Math.random() * 3 + 1,
                                Math.random() > 0.5 ? '#FFFF00' : '#FFA500',
                                0.4
                            ));
                        }
                    }
                }
            } else if (behavior === 'ricochet') {
                // Balls ricochet with extra force
                const dx = ball2.x - ball1.x;
                const dy = ball2.y - ball1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const nx = dx / dist;
                    const ny = dy / dist;
                    
                    // Strong ricochet force
                    const ricochetForce = 500;
                    ball1.vx -= nx * ricochetForce;
                    ball1.vy -= ny * ricochetForce;
                    ball2.vx += nx * ricochetForce;
                    ball2.vy += ny * ricochetForce;
                    
                    // Shockwave effect
                    if (CONFIG.collisionEffects) {
                        const midX = (ball1.x + ball2.x) / 2;
                        const midY = (ball1.y + ball2.y) / 2;
                        state.effects.push(new VisualEffect(midX, midY, '#FFFFFF', 60, 0.5));
                        state.effects.push(new VisualEffect(midX, midY, '#FFAA00', 45, 0.7));
                    }
                }
            }
            // 'null' behavior - do nothing, saws pass through
        }

        function getRandomSawSpawnPosition() {
            const angle = Math.random() * Math.PI * 2;
            const maxR = state.mainRadius - CONFIG.ballRadius * 3;
            const r = Math.random() * maxR;
            return {
                x: state.centerX + Math.cos(angle) * r,
                y: state.centerY + Math.sin(angle) * r
            };
        }

        /**
         * MAIN UPDATE FUNCTION
         */
        function update(dt) {
            if (CONFIG.isPaused) return;
            
            const aliveBalls = state.balls.filter(b => b.status === 'alive');
            
            // Update line counts for all balls (only if lines are enabled)
            if (CONFIG.linesEnabled) {
                state.balls.forEach(ball => {
                    ball.lineCount = state.lines.filter(line => line.owner.id === ball.id).length;
                });
            } else {
                // Reset line counts when lines are disabled
                state.balls.forEach(ball => {
                    ball.lineCount = 0;
                });
            }
            
            // Chainsaw Mode Logic
            if (CONFIG.chainsawMode.enabled) {
                // Count active saws and equipped saws
                const activeSaws = state.saws.filter(s => s.status === 'spawned').length;
                const equippedSaws = aliveBalls.filter(b => b.equippedSaw !== null).length;
                const totalSaws = activeSaws + equippedSaws;
                
                // Spawn new saws if under limit
                if (totalSaws < CONFIG.chainsawMode.maxSawsOnMap) {
                    state.sawSpawnTimer += dt;
                    if (state.sawSpawnTimer >= CONFIG.chainsawMode.sawSpawnInterval) {
                        // Get enabled saw types
                        const enabledTypes = Object.keys(CONFIG.chainsawMode.enabledSawTypes)
                            .filter(type => CONFIG.chainsawMode.enabledSawTypes[type]);
                        
                        if (enabledTypes.length > 0) {
                            // Spawn a new saw at random position inside the circle
                            const angle = Math.random() * Math.PI * 2;
                            const maxR = state.mainRadius - CONFIG.ballRadius * 3;
                            const r = Math.random() * maxR;
                            const sawX = state.centerX + Math.cos(angle) * r;
                            const sawY = state.centerY + Math.sin(angle) * r;
                            
                            // Pick random type from enabled types
                            const randomType = enabledTypes[Math.floor(Math.random() * enabledTypes.length)];
                            state.saws.push(new RotatingSaw(sawX, sawY, randomType));
                            state.sawSpawnTimer = 0;
                        }
                    }
                }
                
                // Update saws
                state.saws.forEach(saw => {
                    if (saw.status === 'spawned') {
                        saw.update(dt);
                        
                        // Check collision with balls (collection)
                        aliveBalls.forEach(ball => {
                            if (!ball.equippedSaw && saw.isCollidingWithBall(ball)) {
                                ball.equipSaw(saw);
                                
                                // Collection effect
                                if (CONFIG.collisionEffects) {
                                    const effectColor = SAW_TYPES[saw.type].colors.primary;
                                    state.effects.push(new VisualEffect(saw.x, saw.y, effectColor, 35, 0.6));
                                    
                                    // Particle burst
                                    if (CONFIG.particleEffects) {
                                        for (let i = 0; i < 15; i++) {
                                            const angle = Math.random() * Math.PI * 2;
                                            const speed = Math.random() * 150 + 50;
                                            const vx = Math.cos(angle) * speed;
                                            const vy = Math.sin(angle) * speed;
                                            state.particles.push(new Particle(
                                                saw.x, saw.y, vx, vy, 
                                                Math.random() * 2 + 1, 
                                                effectColor, 
                                                0.5
                                            ));
                                        }
                                    }
                                }
                            }
                        });
                    }
                });
                
                // Remove collected saws
                state.saws = state.saws.filter(saw => saw.status !== 'collected');
                
                // Check saw-ball collisions (ball with saw hits other ball)
                for (let i = 0; i < aliveBalls.length; i++) {
                    const attacker = aliveBalls[i];
                    if (!attacker.equippedSaw) continue;
                    
                    for (let j = 0; j < aliveBalls.length; j++) {
                        if (i === j) continue;
                        const victim = aliveBalls[j];
                        
                        // Check if saw still exists (might have been destroyed in previous iteration)
                        if (!attacker.equippedSaw) break;
                        
                        if (attacker.equippedSaw.isCollidingWithBall(victim)) {
                            const attackerSawType = attacker.equippedSaw.type;
                            
                            // Saw vs Saw collision
                            if (victim.equippedSaw) {
                                handleSawClash(attacker, victim);
                                continue;
                            }
                            
                            // Different behavior per saw type
                            if (attackerSawType === 'vortex') {
                                // Vortex doesn't damage - only pulls
                                continue;
                            } else if (attackerSawType === 'emp') {
                                // EMP stuns and destroys victim's saw
                                victim.stunned = true;
                                victim.stunnedTime = SAW_TYPES.emp.stunDuration;
                                victim.speedModifier = 0.2; // 80% slower
                                
                                // Destroy victim's saw if they have one
                                if (victim.equippedSaw) {
                                    victim.equippedSaw.break();
                                }
                                
                                // EMP visual effect
                                if (CONFIG.collisionEffects) {
                                    state.effects.push(new VisualEffect(victim.x, victim.y, '#00BFFF', 50, 0.8));
                                }
                                if (CONFIG.particleEffects) {
                                    for (let k = 0; k < 20; k++) {
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = Math.random() * 200 + 80;
                                        const vx = Math.cos(angle) * speed;
                                        const vy = Math.sin(angle) * speed;
                                        state.particles.push(new Particle(
                                            victim.x, victim.y, vx, vy, 
                                            Math.random() * 3 + 1, 
                                            '#00BFFF', 
                                            0.6
                                        ));
                                    }
                                }
                                
                                // Use charge
                                attacker.equippedSaw.useCharge();
                            } else {
                                // Normal damage (standard, heavy, light)
                                const damaged = victim.takeDamage();
                                
                                // Light saw gives speed boost to attacker
                                if (attackerSawType === 'light') {
                                    const boostDuration = 2.0;
                                    const speedBoost = SAW_TYPES.light.speedBoost;
                                    attacker.vx *= speedBoost;
                                    attacker.vy *= speedBoost;
                                }
                                
                                // Heavy saw applies strong push
                                if (attackerSawType === 'heavy') {
                                    const dx = victim.x - attacker.x;
                                    const dy = victim.y - attacker.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist > 0) {
                                        const pushForce = SAW_TYPES.heavy.pushForce * 300;
                                        victim.vx += (dx / dist) * pushForce;
                                        victim.vy += (dy / dist) * pushForce;
                                    }
                                }
                                
                                // Impact effect
                                if (CONFIG.collisionEffects) {
                                    const impactColor = SAW_TYPES[attackerSawType].colors.primary;
                                    state.effects.push(new VisualEffect(victim.x, victim.y, impactColor, 40, 0.8));
                                }
                                
                                // Use charge
                                attacker.equippedSaw.useCharge();
                            }
                        }
                    }
                }
            }
            
            // Update all entities
            aliveBalls.forEach(ball => ball.update(dt));
            
            // Apply mutual gravity between balls if enabled
            if (CONFIG.gravityMode === 'mutual' && aliveBalls.length > 1) {
                for (let i = 0; i < aliveBalls.length; i++) {
                    for (let j = i + 1; j < aliveBalls.length; j++) {
                        const ball1 = aliveBalls[i];
                        const ball2 = aliveBalls[j];
                        
                        const dx = ball2.x - ball1.x;
                        const dy = ball2.y - ball1.y;
                        const distSq = dx * dx + dy * dy;
                        const dist = Math.sqrt(distSq);
                        
                        if (dist > 1) { // Avoid division by very small numbers
                            // F = G * m1 * m2 / d (linear distance for better control)
                            // Increased multiplier for visible effect
                            const force = (CONFIG.gravityIntensity * ball1.mass * ball2.mass * 10.0) / dist;
                            const fx = (dx / dist) * force * dt;
                            const fy = (dy / dist) * force * dt;
                            
                            // Apply force to both balls (Newton's 3rd law)
                            ball1.vx += fx / ball1.mass;
                            ball1.vy += fy / ball1.mass;
                            ball2.vx -= fx / ball2.mass;
                            ball2.vy -= fy / ball2.mass;
                        }
                    }
                }
            }
            
            state.lines.forEach(line => line.update(dt));
            state.particles.forEach(p => p.update(dt));
            state.effects.forEach(e => e.update(dt));
            
            // Update collision manager
            state.collisionManager.update(dt);
            
            // Update spacetime fabric deformations
            if (state.spacetimeFabric && CONFIG.spacetimeFabric) {
                state.spacetimeFabric.updateDeformations(
                    state.balls,
                    state.centerX,
                    state.centerY,
                    state.mainRadius,
                    CONFIG.gravityMode,
                    CONFIG.fabricIntensity * (CONFIG.gravityIntensity / 100)
                );
            }
            
            // Clean up dead entities
            state.particles = state.particles.filter(p => p.life > 0);
            state.effects = state.effects.filter(e => e.life > 0);
            state.lines = state.lines.filter(line => line.owner.status !== 'dead');
            
            // Ball-ball collisions (NEW COLLISION SYSTEM)
            for (let i = 0; i < aliveBalls.length; i++) {
                for (let j = i + 1; j < aliveBalls.length; j++) {
                    state.collisionManager.resolveBallCollision(aliveBalls[i], aliveBalls[j]);
                }
            }
            
            // Ball-wall collisions (NEW COLLISION SYSTEM)
            aliveBalls.forEach(ball => {
                const hadCollision = state.collisionManager.resolveWallCollision(
                    ball, 
                    state.centerX, 
                    state.centerY, 
                    state.mainRadius
                );
                
                // Create line on wall collision (only if lines are enabled)
                if (hadCollision && CONFIG.linesEnabled) {
                    const dx = ball.x - state.centerX;
                    const dy = ball.y - state.centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const contactAngle = Math.atan2(dy / dist, dx / dist);
                    state.lines.push(new ElasticLine(contactAngle, ball));
                    ball.hasEverHadLine = true;
                    
                    if (CONFIG.collisionEffects) {
                        const hitX = state.centerX + Math.cos(contactAngle) * state.mainRadius;
                        const hitY = state.centerY + Math.sin(contactAngle) * state.mainRadius;
                        state.effects.push(new VisualEffect(hitX, hitY, ball.color, 30, 0.5));
                    }
                }
            });
            
            // Line stealing
            if (CONFIG.lineStealing && CONFIG.linesEnabled) {
                aliveBalls.forEach(ball => {
                    state.lines.forEach(line => {
                        if (line.owner.id === ball.id || line.owner.status !== 'alive') return;
                        
                        const anchorPos = line.getAnchorPos(state.centerX, state.centerY, state.mainRadius);
                        const ownerPos = { x: line.owner.x, y: line.owner.y };
                        
                        if (isPointNearSegment(ball.x, ball.y, anchorPos, ownerPos, ball.radius)) {
                            line.owner = ball;
                            ball.hasEverHadLine = true;
                            line.pulse = 1.0;
                        }
                    });
                });
            }
            
            // Check for elimination
            if (CONFIG.eliminationMode && CONFIG.linesEnabled) {
                state.balls.forEach(ball => {
                    if (ball.status === 'alive' && ball.hasEverHadLine) {
                        const ownedLines = state.lines.filter(line => line.owner.id === ball.id);
                        if (ownedLines.length === 0) {
                            ball.die();
                        }
                    }
                });
            }
            
            // Update stats
            document.getElementById('activeBalls').textContent = aliveBalls.length;
            document.getElementById('totalLines').textContent = state.lines.length;
        }

        function draw() {
            const { ctx, width, height, centerX, centerY, mainRadius } = state;
            
            // Clear canvas with slight trail effect if motion trails enabled
            if (CONFIG.motionTrails) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            } else {
                ctx.fillStyle = '#000000';
            }
            ctx.fillRect(0, 0, width, height);
            
            ctx.imageSmoothingEnabled = true;
            
            // Draw main circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, mainRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
            
            // Draw spacetime fabric BEFORE other elements (acts as background)
            if (state.spacetimeFabric && CONFIG.spacetimeFabric) {
                state.spacetimeFabric.draw(ctx, centerX, centerY, mainRadius, CONFIG.gravityMode);
            }
            
            // Draw grid pattern inside circle (optional visual enhancement)
            if (CONFIG.glowEffect) {
                ctx.save();
                ctx.globalAlpha = 0.05;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 / 8) * i;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(
                        centerX + Math.cos(angle) * mainRadius,
                        centerY + Math.sin(angle) * mainRadius
                    );
                    ctx.stroke();
                }
                
                for (let r = mainRadius / 4; r < mainRadius; r += mainRadius / 4) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // Draw lines (only if lines system is enabled)
            if (CONFIG.linesEnabled) {
                state.lines.forEach(line => {
                    if (line.owner.status !== 'dead') {
                        line.draw(ctx, centerX, centerY, mainRadius);
                    }
                });
            }
            
            // Draw particles
            state.particles.forEach(p => p.draw(ctx));
            
            // Draw effects
            state.effects.forEach(e => e.draw(ctx));
            
            // Draw saws
            state.saws.forEach(saw => saw.draw(ctx));
            
            // Draw balls
            state.balls.forEach(ball => ball.draw(ctx));
        }

        // Start the application
        init();
    </script>
</body>
</html>